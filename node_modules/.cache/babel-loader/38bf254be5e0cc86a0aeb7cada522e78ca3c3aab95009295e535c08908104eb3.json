{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ZERO } from './parsers';\n/**\n * Ensures that a given number is expressed in radians. If the number is already\n * in radians, does nothing. If the value is in degrees, converts it to radians.\n * If the value has no specified unit, the unit is assumed to be radians. If the\n * value is not in radians or degrees, the value is resolved as 0 radians.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const degreesToRadians = (numberNode, fallbackRadianValue = 0) => {\n  let {\n    number,\n    unit\n  } = numberNode;\n  if (!isFinite(number)) {\n    number = fallbackRadianValue;\n    unit = 'rad';\n  } else if (numberNode.unit === 'rad' || numberNode.unit == null) {\n    return numberNode;\n  }\n  const valueIsDegrees = unit === 'deg' && number != null;\n  const value = valueIsDegrees ? number : 0;\n  const radians = value * Math.PI / 180;\n  return {\n    type: 'number',\n    number: radians,\n    unit: 'rad'\n  };\n};\n/**\n * Ensures that a given number is expressed in degrees. If the number is already\n * in degrees, does nothing. If the value is in radians or has no specified\n * unit, converts it to degrees. If the value is not in radians or degrees, the\n * value is resolved as 0 degrees.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const radiansToDegrees = (numberNode, fallbackDegreeValue = 0) => {\n  let {\n    number,\n    unit\n  } = numberNode;\n  if (!isFinite(number)) {\n    number = fallbackDegreeValue;\n    unit = 'deg';\n  } else if (numberNode.unit === 'deg') {\n    return numberNode;\n  }\n  const valueIsRadians = (unit === null || unit === 'rad') && number != null;\n  const value = valueIsRadians ? number : 0;\n  const degrees = value * 180 / Math.PI;\n  return {\n    type: 'number',\n    number: degrees,\n    unit: 'deg'\n  };\n};\n/**\n * Converts a given length to meters. Currently supported input units are\n * meters, centimeters and millimeters.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const lengthToBaseMeters = (numberNode, fallbackMeterValue = 0) => {\n  let {\n    number,\n    unit\n  } = numberNode;\n  if (!isFinite(number)) {\n    number = fallbackMeterValue;\n    unit = 'm';\n  } else if (numberNode.unit === 'm') {\n    return numberNode;\n  }\n  let scale;\n  switch (unit) {\n    default:\n      scale = 1;\n      break;\n    case 'cm':\n      scale = 1 / 100;\n      break;\n    case 'mm':\n      scale = 1 / 1000;\n      break;\n  }\n  const value = scale * number;\n  return {\n    type: 'number',\n    number: value,\n    unit: 'm'\n  };\n};\n/**\n * Normalizes the unit of a given input number so that it is expressed in a\n * preferred unit. For length nodes, the return value will be expressed in\n * meters. For angle nodes, the return value will be expressed in radians.\n *\n * Also takes a fallback number that is used when the number value is not a\n * valid number or when the unit of the given number cannot be normalized.\n */\nexport const normalizeUnit = (() => {\n  const identity = node => node;\n  const unitNormalizers = {\n    'rad': identity,\n    'deg': degreesToRadians,\n    'm': identity,\n    'mm': lengthToBaseMeters,\n    'cm': lengthToBaseMeters\n  };\n  return (node, fallback = ZERO) => {\n    if (!isFinite(node.number)) {\n      node.number = fallback.number;\n      node.unit = fallback.unit;\n    }\n    const {\n      unit\n    } = node;\n    if (unit == null) {\n      return node;\n    }\n    const normalize = unitNormalizers[unit];\n    if (normalize == null) {\n      return fallback;\n    }\n    return normalize(node);\n  };\n})();","map":{"version":3,"names":["ZERO","degreesToRadians","numberNode","fallbackRadianValue","number","unit","isFinite","valueIsDegrees","value","radians","Math","PI","type","radiansToDegrees","fallbackDegreeValue","valueIsRadians","degrees","lengthToBaseMeters","fallbackMeterValue","scale","normalizeUnit","identity","node","unitNormalizers","fallback","normalize"],"sources":["../../src/styles/conversions.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {NumberNode, ZERO} from './parsers';\n\n/**\n * Ensures that a given number is expressed in radians. If the number is already\n * in radians, does nothing. If the value is in degrees, converts it to radians.\n * If the value has no specified unit, the unit is assumed to be radians. If the\n * value is not in radians or degrees, the value is resolved as 0 radians.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const degreesToRadians =\n    (numberNode: NumberNode, fallbackRadianValue: number = 0): NumberNode => {\n      let {number, unit} = numberNode;\n      if (!isFinite(number)) {\n        number = fallbackRadianValue;\n        unit = 'rad';\n      } else if (numberNode.unit === 'rad' || numberNode.unit == null) {\n        return numberNode;\n      }\n\n      const valueIsDegrees = unit === 'deg' && number != null;\n      const value = valueIsDegrees ? number : 0;\n      const radians = value * Math.PI / 180;\n\n      return {type: 'number', number: radians, unit: 'rad'};\n    };\n\n/**\n * Ensures that a given number is expressed in degrees. If the number is already\n * in degrees, does nothing. If the value is in radians or has no specified\n * unit, converts it to degrees. If the value is not in radians or degrees, the\n * value is resolved as 0 degrees.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const radiansToDegrees =\n    (numberNode: NumberNode, fallbackDegreeValue: number = 0): NumberNode => {\n      let {number, unit} = numberNode;\n\n      if (!isFinite(number)) {\n        number = fallbackDegreeValue;\n        unit = 'deg';\n      } else if (numberNode.unit === 'deg') {\n        return numberNode;\n      }\n\n      const valueIsRadians =\n          (unit === null || unit === 'rad') && number != null;\n\n      const value = valueIsRadians ? number : 0;\n      const degrees = value * 180 / Math.PI;\n\n      return {type: 'number', number: degrees, unit: 'deg'};\n    };\n\n/**\n * Converts a given length to meters. Currently supported input units are\n * meters, centimeters and millimeters.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const lengthToBaseMeters =\n    (numberNode: NumberNode, fallbackMeterValue: number = 0): NumberNode => {\n      let {number, unit} = numberNode;\n\n      if (!isFinite(number)) {\n        number = fallbackMeterValue;\n        unit = 'm';\n      } else if (numberNode.unit === 'm') {\n        return numberNode;\n      }\n\n      let scale;\n\n      switch (unit) {\n        default:\n          scale = 1;\n          break;\n        case 'cm':\n          scale = 1 / 100;\n          break;\n        case 'mm':\n          scale = 1 / 1000;\n          break;\n      }\n\n      const value = scale * number;\n      return {type: 'number', number: value, unit: 'm'};\n    };\n\n/**\n * Normalizes the unit of a given input number so that it is expressed in a\n * preferred unit. For length nodes, the return value will be expressed in\n * meters. For angle nodes, the return value will be expressed in radians.\n *\n * Also takes a fallback number that is used when the number value is not a\n * valid number or when the unit of the given number cannot be normalized.\n */\nexport const normalizeUnit = (() => {\n  const identity = (node: NumberNode) => node;\n  const unitNormalizers: {[index: string]: (node: NumberNode) => NumberNode} = {\n    'rad': identity,\n    'deg': degreesToRadians,\n    'm': identity,\n    'mm': lengthToBaseMeters,\n    'cm': lengthToBaseMeters\n  };\n\n  return (node: NumberNode, fallback: NumberNode = ZERO) => {\n    if (!isFinite(node.number)) {\n      node.number = fallback.number;\n      node.unit = fallback.unit;\n    }\n\n    const {unit} = node;\n\n    if (unit == null) {\n      return node;\n    }\n\n    const normalize = unitNormalizers[unit];\n\n    if (normalize == null) {\n      return fallback;\n    }\n\n    return normalize(node);\n  };\n})();"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}