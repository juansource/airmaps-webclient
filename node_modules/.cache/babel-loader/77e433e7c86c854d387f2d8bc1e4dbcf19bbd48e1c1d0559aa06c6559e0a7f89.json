{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BackSide, BoxGeometry, CubeCamera, EquirectangularReflectionMapping, HalfFloatType, LinearSRGBColorSpace, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, SRGBColorSpace, TextureLoader, Vector3, WebGLCubeRenderTarget } from 'three';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { deserializeUrl, timePasses } from '../utilities.js';\nimport EnvironmentScene from './EnvironmentScene.js';\nimport EnvironmentSceneAlt from './EnvironmentSceneAlt.js';\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nexport default class TextureUtils {\n  constructor(threeRenderer) {\n    this.threeRenderer = threeRenderer;\n    this.lottieLoaderUrl = '';\n    this.withCredentials = false;\n    this._ldrLoader = null;\n    this._hdrLoader = null;\n    this._lottieLoader = null;\n    this.generatedEnvironmentMap = null;\n    this.generatedEnvironmentMapAlt = null;\n    this.skyboxCache = new Map();\n    this.blurMaterial = null;\n    this.blurScene = null;\n  }\n  get ldrLoader() {\n    if (this._ldrLoader == null) {\n      this._ldrLoader = new TextureLoader();\n    }\n    this._ldrLoader.setWithCredentials(this.withCredentials);\n    return this._ldrLoader;\n  }\n  get hdrLoader() {\n    if (this._hdrLoader == null) {\n      this._hdrLoader = new RGBELoader();\n      this._hdrLoader.setDataType(HalfFloatType);\n    }\n    this._hdrLoader.setWithCredentials(this.withCredentials);\n    return this._hdrLoader;\n  }\n  async getLottieLoader() {\n    if (this._lottieLoader == null) {\n      const {\n        LottieLoader\n      } = await import( /* webpackIgnore: true */this.lottieLoaderUrl);\n      this._lottieLoader = new LottieLoader();\n    }\n    this._lottieLoader.setWithCredentials(this.withCredentials);\n    return this._lottieLoader;\n  }\n  async loadImage(url) {\n    const texture = await new Promise((resolve, reject) => this.ldrLoader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n    texture.flipY = false;\n    return texture;\n  }\n  async loadLottie(url, quality) {\n    const loader = await this.getLottieLoader();\n    loader.setQuality(quality);\n    const texture = await new Promise((resolve, reject) => loader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n    return texture;\n  }\n  async loadEquirect(url, progressCallback = () => {}) {\n    try {\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? this.hdrLoader : this.ldrLoader;\n      const texture = await new Promise((resolve, reject) => loader.load(url, resolve, event => {\n        progressCallback(event.loaded / event.total * 0.9);\n      }, reject));\n      progressCallback(1.0);\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n      if (!isHDR) {\n        texture.colorSpace = SRGBColorSpace;\n      }\n      return texture;\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = () => {}) {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n    let skyboxLoads = Promise.resolve(null);\n    let environmentMapLoads;\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    }\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads = this.loadEquirectFromUrl(environmentMapUrl, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();\n    }\n    const [environmentMap, skybox] = await Promise.all([environmentMapLoads, skyboxLoads]);\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n    return {\n      environmentMap,\n      skybox\n    };\n  }\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  async loadEquirectFromUrl(url, progressCallback) {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads = this.loadEquirect(url, progressCallback);\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n    return this.skyboxCache.get(url);\n  }\n  async GenerateEnvironmentMap(scene, name) {\n    await timePasses();\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n    const outputColorSpace = renderer.outputColorSpace;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n    cubeCamera.update(renderer, scene);\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n    return generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  async loadGeneratedEnvironmentMap() {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new EnvironmentScene(), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  async loadGeneratedEnvironmentMapAlt() {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new EnvironmentSceneAlt(), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n  blurCubemap(cubeTarget, sigma) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n  halfblur(targetIn, targetOut, sigmaRadians, direction) {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    const blurUniforms = this.blurMaterial.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene);\n  }\n  getBlurShader(maxSamples) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n      name: 'SphericalGaussianBlur',\n      defines: {\n        'n': maxSamples\n      },\n      uniforms: {\n        'envMap': {\n          value: null\n        },\n        'samples': {\n          value: 1\n        },\n        'weights': {\n          value: weights\n        },\n        'latitudinal': {\n          value: false\n        },\n        'dTheta': {\n          value: 0\n        },\n        'poleAxis': {\n          value: poleAxis\n        }\n      },\n      vertexShader: /* glsl */`\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n      fragmentShader: /* glsl */`\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    });\n    return shaderMaterial;\n  }\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}","map":{"version":3,"names":["BackSide","BoxGeometry","CubeCamera","EquirectangularReflectionMapping","HalfFloatType","LinearSRGBColorSpace","Mesh","NoBlending","NoToneMapping","RGBAFormat","Scene","ShaderMaterial","SRGBColorSpace","TextureLoader","Vector3","WebGLCubeRenderTarget","RGBELoader","deserializeUrl","timePasses","EnvironmentScene","EnvironmentSceneAlt","GENERATED_SIGMA","MAX_SAMPLES","HDR_FILE_RE","TextureUtils","constructor","threeRenderer","lottieLoaderUrl","withCredentials","_ldrLoader","_hdrLoader","_lottieLoader","generatedEnvironmentMap","generatedEnvironmentMapAlt","skyboxCache","Map","blurMaterial","blurScene","ldrLoader","setWithCredentials","hdrLoader","setDataType","getLottieLoader","LottieLoader","loadImage","url","texture","Promise","resolve","reject","load","name","flipY","loadLottie","quality","loader","setQuality","loadEquirect","progressCallback","isHDR","test","event","loaded","total","mapping","colorSpace","generateEnvironmentMapAndSkybox","skyboxUrl","environmentMapUrl","useAltEnvironment","skyboxLoads","environmentMapLoads","loadEquirectFromUrl","loadGeneratedEnvironmentMapAlt","loadGeneratedEnvironmentMap","environmentMap","skybox","all","Error","has","skyboxMapLoads","set","get","GenerateEnvironmentMap","scene","renderer","cubeTarget","generateMipmaps","type","format","depthBuffer","cubeCamera","renderTarget","outputColorSpace","toneMapping","update","blurCubemap","sigma","getBlurShader","box","blurMesh","add","tempTarget","clone","halfblur","targetIn","targetOut","sigmaRadians","direction","STANDARD_DEVIATIONS","pixels","width","radiansPerPixel","isFinite","Math","PI","sigmaPixels","samples","floor","console","warn","weights","sum","i","x","weight","exp","push","length","blurUniforms","uniforms","value","maxSamples","Float32Array","poleAxis","shaderMaterial","defines","vertexShader","fragmentShader","blending","depthTest","depthWrite","side","dispose","promise"],"sources":["../../src/three-components/TextureUtils.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BackSide, BoxGeometry, CubeCamera, CubeTexture, EquirectangularReflectionMapping, HalfFloatType, LinearSRGBColorSpace, Loader, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, SRGBColorSpace, Texture, TextureLoader, Vector3, WebGLCubeRenderTarget, WebGLRenderer} from 'three';\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';\n\nimport {deserializeUrl, timePasses} from '../utilities.js';\n\nimport EnvironmentScene from './EnvironmentScene.js';\nimport EnvironmentSceneAlt from './EnvironmentSceneAlt.js';\n\nexport interface EnvironmentMapAndSkybox {\n  environmentMap: Texture;\n  skybox: Texture|null;\n}\n\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\n\nexport default class TextureUtils {\n  public lottieLoaderUrl = '';\n  public withCredentials = false;\n\n  private _ldrLoader: TextureLoader|null = null;\n  private _hdrLoader: RGBELoader|null = null;\n  private _lottieLoader: Loader|null = null;\n\n  private generatedEnvironmentMap: Promise<CubeTexture>|null = null;\n  private generatedEnvironmentMapAlt: Promise<CubeTexture>|null = null;\n\n  private skyboxCache = new Map<string, Promise<Texture>>();\n\n  private blurMaterial: ShaderMaterial|null = null;\n  private blurScene: Scene|null = null;\n\n  constructor(private threeRenderer: WebGLRenderer) {\n  }\n\n  get ldrLoader(): TextureLoader {\n    if (this._ldrLoader == null) {\n      this._ldrLoader = new TextureLoader();\n    }\n    this._ldrLoader.setWithCredentials(this.withCredentials);\n    return this._ldrLoader;\n  }\n\n  get hdrLoader(): RGBELoader {\n    if (this._hdrLoader == null) {\n      this._hdrLoader = new RGBELoader();\n      this._hdrLoader.setDataType(HalfFloatType);\n    }\n    this._hdrLoader.setWithCredentials(this.withCredentials);\n    return this._hdrLoader;\n  }\n\n  async getLottieLoader(): Promise<any> {\n    if (this._lottieLoader == null) {\n      const {LottieLoader} =\n          await import(/* webpackIgnore: true */ this.lottieLoaderUrl);\n      this._lottieLoader = new LottieLoader() as Loader;\n    }\n    this._lottieLoader.setWithCredentials(this.withCredentials);\n    return this._lottieLoader;\n  }\n\n  async loadImage(url: string): Promise<Texture> {\n    const texture: Texture = await new Promise<Texture>(\n        (resolve, reject) =>\n            this.ldrLoader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n    texture.flipY = false;\n\n    return texture;\n  }\n\n  async loadLottie(url: string, quality: number): Promise<Texture> {\n    const loader = await this.getLottieLoader();\n    loader.setQuality(quality);\n    const texture: Texture = await new Promise<Texture>(\n        (resolve, reject) => loader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n\n    return texture;\n  }\n\n  async loadEquirect(\n      url: string, progressCallback: (progress: number) => void = () => {}):\n      Promise<Texture> {\n    try {\n      const isHDR: boolean = HDR_FILE_RE.test(url);\n      const loader = isHDR ? this.hdrLoader : this.ldrLoader;\n      const texture: Texture = await new Promise<Texture>(\n          (resolve, reject) => loader.load(\n              url, resolve, (event: {loaded: number, total: number}) => {\n                progressCallback(event.loaded / event.total * 0.9);\n              }, reject));\n\n      progressCallback(1.0);\n\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n\n      if (!isHDR) {\n        texture.colorSpace = SRGBColorSpace;\n      }\n\n      return texture;\n\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(\n      skyboxUrl: string|null = null, environmentMapUrl: string|null = null,\n      progressCallback: (progress: number) => void = () => {}):\n      Promise<EnvironmentMapAndSkybox> {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n\n    let skyboxLoads: Promise<Texture|null> = Promise.resolve(null);\n    let environmentMapLoads: Promise<Texture>;\n\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    }\n\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads =\n          this.loadEquirectFromUrl(environmentMapUrl, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads =\n          this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ?\n          this.loadGeneratedEnvironmentMapAlt() :\n          this.loadGeneratedEnvironmentMap();\n    }\n\n    const [environmentMap, skybox] =\n        await Promise.all([environmentMapLoads, skyboxLoads]);\n\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n\n    return {environmentMap, skybox};\n  }\n\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  private async loadEquirectFromUrl(\n      url: string,\n      progressCallback: (progress: number) => void): Promise<Texture> {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads = this.loadEquirect(url, progressCallback);\n\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n\n    return this.skyboxCache.get(url)!;\n  }\n\n  private async GenerateEnvironmentMap(scene: Scene, name: string) {\n    await timePasses();\n\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n\n    const outputColorSpace = renderer.outputColorSpace;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    cubeCamera.update(renderer, scene);\n\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n\n    return generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  private async loadGeneratedEnvironmentMap(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap =\n          this.GenerateEnvironmentMap(new EnvironmentScene(), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  private async loadGeneratedEnvironmentMapAlt(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt =\n          this.GenerateEnvironmentMap(new EnvironmentSceneAlt(), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n\n  private blurCubemap(cubeTarget: WebGLCubeRenderTarget, sigma: number) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial!);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n\n  private halfblur(\n      targetIn: WebGLCubeRenderTarget, targetOut: WebGLCubeRenderTarget,\n      sigmaRadians: number, direction: 'latitudinal'|'longitudinal') {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ?\n        Math.PI / (2 * pixels) :\n        2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ?\n        1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) :\n        MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${\n          sigmaRadians}, is too large and will clip, as it requested ${\n          samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    const blurUniforms = this.blurMaterial!.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene!);\n  }\n\n  private getBlurShader(maxSamples: number) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n\n      name: 'SphericalGaussianBlur',\n\n      defines: {'n': maxSamples},\n\n      uniforms: {\n        'envMap': {value: null},\n        'samples': {value: 1},\n        'weights': {value: weights},\n        'latitudinal': {value: false},\n        'dTheta': {value: 0},\n        'poleAxis': {value: poleAxis}\n      },\n\n      vertexShader: /* glsl */ `\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n\n      fragmentShader: /* glsl */ `\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n\n    });\n\n    return shaderMaterial;\n  }\n\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}\n"],"mappings":";;;;AAAA;;;;;;;;;;;;;;AAeA,SAAQA,QAAQ,EAAEC,WAAW,EAAEC,UAAU,EAAeC,gCAAgC,EAAEC,aAAa,EAAEC,oBAAoB,EAAUC,IAAI,EAAEC,UAAU,EAAEC,aAAa,EAAEC,UAAU,EAAEC,KAAK,EAAEC,cAAc,EAAEC,cAAc,EAAWC,aAAa,EAAEC,OAAO,EAAEC,qBAAqB,QAAsB,OAAO;AAC9S,SAAQC,UAAU,QAAO,0CAA0C;AAEnE,SAAQC,cAAc,EAAEC,UAAU,QAAO,iBAAiB;AAE1D,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,OAAOC,mBAAmB,MAAM,0BAA0B;AAO1D,MAAMC,eAAe,GAAG,IAAI;AAC5B;AACA;AACA,MAAMC,WAAW,GAAG,EAAE;AAEtB,MAAMC,WAAW,GAAG,eAAe;AAEnC,eAAc,MAAOC,YAAY;EAgB/BC,YAAoBC,aAA4B;IAA5B,KAAAA,aAAa,GAAbA,aAAa;IAf1B,KAAAC,eAAe,GAAG,EAAE;IACpB,KAAAC,eAAe,GAAG,KAAK;IAEtB,KAAAC,UAAU,GAAuB,IAAI;IACrC,KAAAC,UAAU,GAAoB,IAAI;IAClC,KAAAC,aAAa,GAAgB,IAAI;IAEjC,KAAAC,uBAAuB,GAA8B,IAAI;IACzD,KAAAC,0BAA0B,GAA8B,IAAI;IAE5D,KAAAC,WAAW,GAAG,IAAIC,GAAG,EAA4B;IAEjD,KAAAC,YAAY,GAAwB,IAAI;IACxC,KAAAC,SAAS,GAAe,IAAI;EAGpC;EAEA,IAAIC,SAASA,CAAA;IACX,IAAI,IAAI,CAACT,UAAU,IAAI,IAAI,EAAE;MAC3B,IAAI,CAACA,UAAU,GAAG,IAAIhB,aAAa,EAAE;;IAEvC,IAAI,CAACgB,UAAU,CAACU,kBAAkB,CAAC,IAAI,CAACX,eAAe,CAAC;IACxD,OAAO,IAAI,CAACC,UAAU;EACxB;EAEA,IAAIW,SAASA,CAAA;IACX,IAAI,IAAI,CAACV,UAAU,IAAI,IAAI,EAAE;MAC3B,IAAI,CAACA,UAAU,GAAG,IAAId,UAAU,EAAE;MAClC,IAAI,CAACc,UAAU,CAACW,WAAW,CAACrC,aAAa,CAAC;;IAE5C,IAAI,CAAC0B,UAAU,CAACS,kBAAkB,CAAC,IAAI,CAACX,eAAe,CAAC;IACxD,OAAO,IAAI,CAACE,UAAU;EACxB;EAEA,MAAMY,eAAeA,CAAA;IACnB,IAAI,IAAI,CAACX,aAAa,IAAI,IAAI,EAAE;MAC9B,MAAM;QAACY;MAAY,CAAC,GAChB,MAAM,MAAM,EAAC,yBAA0B,IAAI,CAAChB,eAAe,CAAC;MAChE,IAAI,CAACI,aAAa,GAAG,IAAIY,YAAY,EAAY;;IAEnD,IAAI,CAACZ,aAAa,CAACQ,kBAAkB,CAAC,IAAI,CAACX,eAAe,CAAC;IAC3D,OAAO,IAAI,CAACG,aAAa;EAC3B;EAEA,MAAMa,SAASA,CAACC,GAAW;IACzB,MAAMC,OAAO,GAAY,MAAM,IAAIC,OAAO,CACtC,CAACC,OAAO,EAAEC,MAAM,KACZ,IAAI,CAACX,SAAS,CAACY,IAAI,CAACL,GAAG,EAAEG,OAAO,EAAE,MAAK,CAAE,CAAC,EAAEC,MAAM,CAAC,CAAC;IAC5DH,OAAO,CAACK,IAAI,GAAGN,GAAG;IAClBC,OAAO,CAACM,KAAK,GAAG,KAAK;IAErB,OAAON,OAAO;EAChB;EAEA,MAAMO,UAAUA,CAACR,GAAW,EAAES,OAAe;IAC3C,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACb,eAAe,EAAE;IAC3Ca,MAAM,CAACC,UAAU,CAACF,OAAO,CAAC;IAC1B,MAAMR,OAAO,GAAY,MAAM,IAAIC,OAAO,CACtC,CAACC,OAAO,EAAEC,MAAM,KAAKM,MAAM,CAACL,IAAI,CAACL,GAAG,EAAEG,OAAO,EAAE,MAAK,CAAE,CAAC,EAAEC,MAAM,CAAC,CAAC;IACrEH,OAAO,CAACK,IAAI,GAAGN,GAAG;IAElB,OAAOC,OAAO;EAChB;EAEA,MAAMW,YAAYA,CACdZ,GAAW,EAAEa,gBAAA,GAA+CA,CAAA,KAAK,CAAE,CAAC;IAEtE,IAAI;MACF,MAAMC,KAAK,GAAYpC,WAAW,CAACqC,IAAI,CAACf,GAAG,CAAC;MAC5C,MAAMU,MAAM,GAAGI,KAAK,GAAG,IAAI,CAACnB,SAAS,GAAG,IAAI,CAACF,SAAS;MACtD,MAAMQ,OAAO,GAAY,MAAM,IAAIC,OAAO,CACtC,CAACC,OAAO,EAAEC,MAAM,KAAKM,MAAM,CAACL,IAAI,CAC5BL,GAAG,EAAEG,OAAO,EAAGa,KAAsC,IAAI;QACvDH,gBAAgB,CAACG,KAAK,CAACC,MAAM,GAAGD,KAAK,CAACE,KAAK,GAAG,GAAG,CAAC;MACpD,CAAC,EAAEd,MAAM,CAAC,CAAC;MAEnBS,gBAAgB,CAAC,GAAG,CAAC;MAErBZ,OAAO,CAACK,IAAI,GAAGN,GAAG;MAClBC,OAAO,CAACkB,OAAO,GAAG7D,gCAAgC;MAElD,IAAI,CAACwD,KAAK,EAAE;QACVb,OAAO,CAACmB,UAAU,GAAGrD,cAAc;;MAGrC,OAAOkC,OAAO;KAEf,SAAS;MACR,IAAIY,gBAAgB,EAAE;QACpBA,gBAAgB,CAAC,CAAC,CAAC;;;EAGzB;EAEA;;;;;EAKA,MAAMQ,+BAA+BA,CACjCC,SAAA,GAAyB,IAAI,EAAEC,iBAAA,GAAiC,IAAI,EACpEV,gBAAA,GAA+CA,CAAA,KAAK,CAAE,CAAC;IAEzD,MAAMW,iBAAiB,GAAGD,iBAAiB,KAAK,QAAQ;IACxD,IAAIA,iBAAiB,KAAK,QAAQ,IAAIA,iBAAiB,KAAK,SAAS,EAAE;MACrEA,iBAAiB,GAAG,IAAI;;IAE1BA,iBAAiB,GAAGnD,cAAc,CAACmD,iBAAiB,CAAC;IAErD,IAAIE,WAAW,GAA0BvB,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC9D,IAAIuB,mBAAqC;IAEzC;IACA,IAAI,CAAC,CAACJ,SAAS,EAAE;MACfG,WAAW,GAAG,IAAI,CAACE,mBAAmB,CAACL,SAAS,EAAET,gBAAgB,CAAC;;IAGrE,IAAI,CAAC,CAACU,iBAAiB,EAAE;MACvB;MACAG,mBAAmB,GACf,IAAI,CAACC,mBAAmB,CAACJ,iBAAiB,EAAEV,gBAAgB,CAAC;KAClE,MAAM,IAAI,CAAC,CAACS,SAAS,EAAE;MACtB;MACAI,mBAAmB,GACf,IAAI,CAACC,mBAAmB,CAACL,SAAS,EAAET,gBAAgB,CAAC;KAC1D,MAAM;MACL;MACAa,mBAAmB,GAAGF,iBAAiB,GACnC,IAAI,CAACI,8BAA8B,EAAE,GACrC,IAAI,CAACC,2BAA2B,EAAE;;IAGxC,MAAM,CAACC,cAAc,EAAEC,MAAM,CAAC,GAC1B,MAAM7B,OAAO,CAAC8B,GAAG,CAAC,CAACN,mBAAmB,EAAED,WAAW,CAAC,CAAC;IAEzD,IAAIK,cAAc,IAAI,IAAI,EAAE;MAC1B,MAAM,IAAIG,KAAK,CAAC,iCAAiC,CAAC;;IAGpD,OAAO;MAACH,cAAc;MAAEC;IAAM,CAAC;EACjC;EAEA;;;EAGQ,MAAMJ,mBAAmBA,CAC7B3B,GAAW,EACXa,gBAA4C;IAC9C,IAAI,CAAC,IAAI,CAACxB,WAAW,CAAC6C,GAAG,CAAClC,GAAG,CAAC,EAAE;MAC9B,MAAMmC,cAAc,GAAG,IAAI,CAACvB,YAAY,CAACZ,GAAG,EAAEa,gBAAgB,CAAC;MAE/D,IAAI,CAACxB,WAAW,CAAC+C,GAAG,CAACpC,GAAG,EAAEmC,cAAc,CAAC;;IAG3C,OAAO,IAAI,CAAC9C,WAAW,CAACgD,GAAG,CAACrC,GAAG,CAAE;EACnC;EAEQ,MAAMsC,sBAAsBA,CAACC,KAAY,EAAEjC,IAAY;IAC7D,MAAMjC,UAAU,EAAE;IAElB,MAAMmE,QAAQ,GAAG,IAAI,CAAC3D,aAAa;IACnC,MAAM4D,UAAU,GAAG,IAAIvE,qBAAqB,CAAC,GAAG,EAAE;MAChDwE,eAAe,EAAE,KAAK;MACtBC,IAAI,EAAEpF,aAAa;MACnBqF,MAAM,EAAEhF,UAAU;MAClBwD,UAAU,EAAE5D,oBAAoB;MAChCqF,WAAW,EAAE;KACd,CAAC;IACF,MAAMC,UAAU,GAAG,IAAIzF,UAAU,CAAC,GAAG,EAAE,GAAG,EAAEoF,UAAU,CAAC;IACvD,MAAMtD,uBAAuB,GAAG2D,UAAU,CAACC,YAAY,CAAC9C,OAAO;IAC/Dd,uBAAuB,CAACmB,IAAI,GAAGA,IAAI;IAEnC,MAAM0C,gBAAgB,GAAGR,QAAQ,CAACQ,gBAAgB;IAClD,MAAMC,WAAW,GAAGT,QAAQ,CAACS,WAAW;IACxCT,QAAQ,CAACS,WAAW,GAAGtF,aAAa;IACpC6E,QAAQ,CAACQ,gBAAgB,GAAGxF,oBAAoB;IAEhDsF,UAAU,CAACI,MAAM,CAACV,QAAQ,EAAED,KAAK,CAAC;IAElC,IAAI,CAACY,WAAW,CAACV,UAAU,EAAEjE,eAAe,CAAC;IAE7CgE,QAAQ,CAACS,WAAW,GAAGA,WAAW;IAClCT,QAAQ,CAACQ,gBAAgB,GAAGA,gBAAgB;IAE5C,OAAO7D,uBAAuB;EAChC;EAEA;;;EAGQ,MAAM0C,2BAA2BA,CAAA;IACvC,IAAI,IAAI,CAAC1C,uBAAuB,IAAI,IAAI,EAAE;MACxC,IAAI,CAACA,uBAAuB,GACxB,IAAI,CAACmD,sBAAsB,CAAC,IAAIhE,gBAAgB,EAAE,EAAE,QAAQ,CAAC;;IAEnE,OAAO,IAAI,CAACa,uBAAuB;EACrC;EAEA;;;;;EAKQ,MAAMyC,8BAA8BA,CAAA;IAC1C,IAAI,IAAI,CAACxC,0BAA0B,IAAI,IAAI,EAAE;MAC3C,IAAI,CAACA,0BAA0B,GAC3B,IAAI,CAACkD,sBAAsB,CAAC,IAAI/D,mBAAmB,EAAE,EAAE,SAAS,CAAC;;IAEvE,OAAO,IAAI,CAACa,0BAA0B;EACxC;EAEQ+D,WAAWA,CAACV,UAAiC,EAAEW,KAAa;IAClE,IAAI,IAAI,CAAC7D,YAAY,IAAI,IAAI,EAAE;MAC7B,IAAI,CAACA,YAAY,GAAG,IAAI,CAAC8D,aAAa,CAAC5E,WAAW,CAAC;MACnD,MAAM6E,GAAG,GAAG,IAAIlG,WAAW,EAAE;MAC7B,MAAMmG,QAAQ,GAAG,IAAI9F,IAAI,CAAC6F,GAAG,EAAE,IAAI,CAAC/D,YAAa,CAAC;MAClD,IAAI,CAACC,SAAS,GAAG,IAAI3B,KAAK,EAAE;MAC5B,IAAI,CAAC2B,SAAS,CAACgE,GAAG,CAACD,QAAQ,CAAC;;IAE9B,MAAME,UAAU,GAAGhB,UAAU,CAACiB,KAAK,EAAE;IACrC,IAAI,CAACC,QAAQ,CAAClB,UAAU,EAAEgB,UAAU,EAAEL,KAAK,EAAE,aAAa,CAAC;IAC3D,IAAI,CAACO,QAAQ,CAACF,UAAU,EAAEhB,UAAU,EAAEW,KAAK,EAAE,cAAc,CAAC;IAC5D;IACA;IACA;IACA;IACA;IACA;EACF;EAEQO,QAAQA,CACZC,QAA+B,EAAEC,SAAgC,EACjEC,YAAoB,EAAEC,SAAuC;IAC/D;IACA;IACA,MAAMC,mBAAmB,GAAG,CAAC;IAE7B,MAAMC,MAAM,GAAGL,QAAQ,CAACM,KAAK;IAC7B,MAAMC,eAAe,GAAGC,QAAQ,CAACN,YAAY,CAAC,GAC1CO,IAAI,CAACC,EAAE,IAAI,CAAC,GAAGL,MAAM,CAAC,GACtB,CAAC,GAAGI,IAAI,CAACC,EAAE,IAAI,CAAC,GAAG7F,WAAW,GAAG,CAAC,CAAC;IACvC,MAAM8F,WAAW,GAAGT,YAAY,GAAGK,eAAe;IAClD,MAAMK,OAAO,GAAGJ,QAAQ,CAACN,YAAY,CAAC,GAClC,CAAC,GAAGO,IAAI,CAACI,KAAK,CAACT,mBAAmB,GAAGO,WAAW,CAAC,GACjD9F,WAAW;IAEf,IAAI+F,OAAO,GAAG/F,WAAW,EAAE;MACzBiG,OAAO,CAACC,IAAI,CAAC,iBACTb,YAAY,iDACZU,OAAO,uCAAuC/F,WAAW,EAAE,CAAC;;IAGlE,MAAMmG,OAAO,GAAG,EAAE;IAClB,IAAIC,GAAG,GAAG,CAAC;IAEX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrG,WAAW,EAAE,EAAEqG,CAAC,EAAE;MACpC,MAAMC,CAAC,GAAGD,CAAC,GAAGP,WAAW;MACzB,MAAMS,MAAM,GAAGX,IAAI,CAACY,GAAG,CAAC,CAACF,CAAC,GAAGA,CAAC,GAAG,CAAC,CAAC;MACnCH,OAAO,CAACM,IAAI,CAACF,MAAM,CAAC;MAEpB,IAAIF,CAAC,IAAI,CAAC,EAAE;QACVD,GAAG,IAAIG,MAAM;OAEd,MAAM,IAAIF,CAAC,GAAGN,OAAO,EAAE;QACtBK,GAAG,IAAI,CAAC,GAAGG,MAAM;;;IAIrB,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,CAACO,MAAM,EAAEL,CAAC,EAAE,EAAE;MACvCF,OAAO,CAACE,CAAC,CAAC,GAAGF,OAAO,CAACE,CAAC,CAAC,GAAGD,GAAG;;IAG/B,MAAMO,YAAY,GAAG,IAAI,CAAC7F,YAAa,CAAC8F,QAAQ;IAChDD,YAAY,CAAC,QAAQ,CAAC,CAACE,KAAK,GAAG1B,QAAQ,CAAC3D,OAAO;IAC/CmF,YAAY,CAAC,SAAS,CAAC,CAACE,KAAK,GAAGd,OAAO;IACvCY,YAAY,CAAC,SAAS,CAAC,CAACE,KAAK,GAAGV,OAAO;IACvCQ,YAAY,CAAC,aAAa,CAAC,CAACE,KAAK,GAAGvB,SAAS,KAAK,aAAa;IAC/DqB,YAAY,CAAC,QAAQ,CAAC,CAACE,KAAK,GAAGnB,eAAe;IAE9C,MAAMrB,UAAU,GAAG,IAAIzF,UAAU,CAAC,GAAG,EAAE,GAAG,EAAEwG,SAAS,CAAC;IACtDf,UAAU,CAACI,MAAM,CAAC,IAAI,CAACrE,aAAa,EAAE,IAAI,CAACW,SAAU,CAAC;EACxD;EAEQ6D,aAAaA,CAACkC,UAAkB;IACtC,MAAMX,OAAO,GAAG,IAAIY,YAAY,CAACD,UAAU,CAAC;IAC5C,MAAME,QAAQ,GAAG,IAAIxH,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACrC,MAAMyH,cAAc,GAAG,IAAI5H,cAAc,CAAC;MAExCwC,IAAI,EAAE,uBAAuB;MAE7BqF,OAAO,EAAE;QAAC,GAAG,EAAEJ;MAAU,CAAC;MAE1BF,QAAQ,EAAE;QACR,QAAQ,EAAE;UAACC,KAAK,EAAE;QAAI,CAAC;QACvB,SAAS,EAAE;UAACA,KAAK,EAAE;QAAC,CAAC;QACrB,SAAS,EAAE;UAACA,KAAK,EAAEV;QAAO,CAAC;QAC3B,aAAa,EAAE;UAACU,KAAK,EAAE;QAAK,CAAC;QAC7B,QAAQ,EAAE;UAACA,KAAK,EAAE;QAAC,CAAC;QACpB,UAAU,EAAE;UAACA,KAAK,EAAEG;QAAQ;OAC7B;MAEDG,YAAY,EAAE,UAAW;;;;;;;;;;KAU1B;MAECC,cAAc,EAAE,UAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAmD1B;MAEDC,QAAQ,EAAEpI,UAAU;MACpBqI,SAAS,EAAE,KAAK;MAChBC,UAAU,EAAE,KAAK;MACjBC,IAAI,EAAE9I;KAEP,CAAC;IAEF,OAAOuI,cAAc;EACvB;EAEA,MAAMQ,OAAOA,CAAA;IACX,KAAK,MAAM,GAAGC,OAAO,CAAC,IAAI,IAAI,CAAC9G,WAAW,EAAE;MAC1C,MAAM0C,MAAM,GAAG,MAAMoE,OAAO;MAC5BpE,MAAM,CAACmE,OAAO,EAAE;;IAElB,IAAI,IAAI,CAAC/G,uBAAuB,IAAI,IAAI,EAAE;MACxC,CAAC,MAAM,IAAI,CAACA,uBAAuB,EAAE+G,OAAO,EAAE;MAC9C,IAAI,CAAC/G,uBAAuB,GAAG,IAAI;;IAErC,IAAI,IAAI,CAACC,0BAA0B,IAAI,IAAI,EAAE;MAC3C,CAAC,MAAM,IAAI,CAACA,0BAA0B,EAAE8G,OAAO,EAAE;MACjD,IAAI,CAAC9G,0BAA0B,GAAG,IAAI;;IAExC,IAAI,IAAI,CAACG,YAAY,IAAI,IAAI,EAAE;MAC7B,IAAI,CAACA,YAAY,CAAC2G,OAAO,EAAE;;EAE/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}