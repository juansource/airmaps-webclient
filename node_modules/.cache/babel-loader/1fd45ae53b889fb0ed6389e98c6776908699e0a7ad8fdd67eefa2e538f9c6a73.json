{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { LoopOnce, LoopPingPong, LoopRepeat } from 'three';\nimport { $getModelIsVisible, $needsRender, $onModelLoad, $renderer, $scene, $tick } from '../model-viewer-base.js';\nconst MILLISECONDS_PER_SECOND = 1000.0;\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\nconst DEFAULT_PLAY_OPTIONS = {\n  repetitions: Infinity,\n  pingpong: false\n};\nexport const AnimationMixin = ModelViewerElement => {\n  var _a;\n  class AnimationModelViewerElement extends ModelViewerElement {\n    constructor(...args) {\n      super(args);\n      this.autoplay = false;\n      this.animationName = undefined;\n      this.animationCrossfadeDuration = 300;\n      this[_a] = true;\n      this[$scene].subscribeMixerEvent('loop', e => {\n        const count = e.action._loopCount;\n        this.dispatchEvent(new CustomEvent('loop', {\n          detail: {\n            count\n          }\n        }));\n      });\n      this[$scene].subscribeMixerEvent('finished', () => {\n        this[$paused] = true;\n        this.dispatchEvent(new CustomEvent('finished'));\n      });\n    }\n    /**\n     * Returns an array\n     */\n    get availableAnimations() {\n      if (this.loaded) {\n        return this[$scene].animationNames;\n      }\n      return [];\n    }\n    get duration() {\n      return this[$scene].duration;\n    }\n    get paused() {\n      return this[$paused];\n    }\n    get currentTime() {\n      return this[$scene].animationTime;\n    }\n    set currentTime(value) {\n      this[$scene].animationTime = value;\n      this[$needsRender]();\n    }\n    get timeScale() {\n      return this[$scene].animationTimeScale;\n    }\n    set timeScale(value) {\n      this[$scene].animationTimeScale = value;\n    }\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n      this[$paused] = true;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n    play(options) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$changeAnimation](options);\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n    [(_a = $paused, $onModelLoad)]() {\n      super[$onModelLoad]();\n      this[$paused] = true;\n      if (this.animationName != null) {\n        this[$changeAnimation]();\n      }\n      if (this.autoplay) {\n        this.play();\n      }\n    }\n    [$tick](_time, delta) {\n      super[$tick](_time, delta);\n      if (this[$paused] || !this[$getModelIsVisible]() && !this[$renderer].isPresenting) {\n        return;\n      }\n      this[$scene].updateAnimation(delta / MILLISECONDS_PER_SECOND);\n      this[$needsRender]();\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n    [$changeAnimation](options = DEFAULT_PLAY_OPTIONS) {\n      var _b;\n      const repetitions = (_b = options.repetitions) !== null && _b !== void 0 ? _b : Infinity;\n      const mode = options.pingpong ? LoopPingPong : repetitions === 1 ? LoopOnce : LoopRepeat;\n      this[$scene].playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND, mode, repetitions);\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n  }\n  __decorate([property({\n    type: Boolean\n  })], AnimationModelViewerElement.prototype, \"autoplay\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'animation-name'\n  })], AnimationModelViewerElement.prototype, \"animationName\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'animation-crossfade-duration'\n  })], AnimationModelViewerElement.prototype, \"animationCrossfadeDuration\", void 0);\n  return AnimationModelViewerElement;\n};","map":{"version":3,"names":["property","LoopOnce","LoopPingPong","LoopRepeat","$getModelIsVisible","$needsRender","$onModelLoad","$renderer","$scene","$tick","MILLISECONDS_PER_SECOND","$changeAnimation","Symbol","$paused","DEFAULT_PLAY_OPTIONS","repetitions","Infinity","pingpong","AnimationMixin","ModelViewerElement","AnimationModelViewerElement","constructor","args","autoplay","animationName","undefined","animationCrossfadeDuration","_a","subscribeMixerEvent","e","count","action","_loopCount","dispatchEvent","CustomEvent","detail","availableAnimations","loaded","animationNames","duration","paused","currentTime","animationTime","value","timeScale","animationTimeScale","pause","play","options","length","_time","delta","isPresenting","updateAnimation","updated","changedProperties","has","_b","mode","playAnimation","__decorate","type","Boolean","String","attribute","Number"],"sources":["../../src/features/animation.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit/decorators.js';\nimport {LoopOnce, LoopPingPong, LoopRepeat} from 'three';\n\nimport ModelViewerElementBase, {$getModelIsVisible, $needsRender, $onModelLoad, $renderer, $scene, $tick} from '../model-viewer-base.js';\nimport {Constructor} from '../utilities.js';\n\nconst MILLISECONDS_PER_SECOND = 1000.0\n\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\n\ninterface PlayAnimationOptions {\n  repetitions: number, pingpong: boolean,\n}\n\nconst DEFAULT_PLAY_OPTIONS: PlayAnimationOptions = {\n  repetitions: Infinity,\n  pingpong: false\n};\n\nexport declare interface AnimationInterface {\n  autoplay: boolean;\n  animationName: string|void;\n  animationCrossfadeDuration: number;\n  readonly availableAnimations: Array<string>;\n  readonly paused: boolean;\n  readonly duration: number;\n  currentTime: number;\n  timeScale: number;\n  pause(): void;\n  play(options?: PlayAnimationOptions): void;\n}\n\nexport const AnimationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnimationInterface>&T => {\n  class AnimationModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean}) autoplay: boolean = false;\n    @property({type: String, attribute: 'animation-name'})\n    animationName: string|undefined = undefined;\n    @property({type: Number, attribute: 'animation-crossfade-duration'})\n    animationCrossfadeDuration: number = 300;\n\n    protected[$paused]: boolean = true;\n\n    constructor(...args: any[]) {\n      super(args);\n\n      this[$scene].subscribeMixerEvent('loop', (e) => {\n        const count = e.action._loopCount;\n        this.dispatchEvent(new CustomEvent('loop', {detail: {count}}));\n      });\n      this[$scene].subscribeMixerEvent('finished', () => {\n        this[$paused] = true;\n        this.dispatchEvent(new CustomEvent('finished'));\n      });\n    }\n\n    /**\n     * Returns an array\n     */\n    get availableAnimations(): Array<string> {\n      if (this.loaded) {\n        return this[$scene].animationNames;\n      }\n\n      return [];\n    }\n\n    get duration(): number {\n      return this[$scene].duration;\n    }\n\n    get paused(): boolean {\n      return this[$paused];\n    }\n\n    get currentTime(): number {\n      return this[$scene].animationTime;\n    }\n\n    set currentTime(value: number) {\n      this[$scene].animationTime = value;\n      this[$needsRender]();\n    }\n\n    get timeScale(): number {\n      return this[$scene].animationTimeScale;\n    }\n\n    set timeScale(value: number) {\n      this[$scene].animationTimeScale = value;\n    }\n\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n\n      this[$paused] = true;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n\n    play(options?: PlayAnimationOptions) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n\n        this[$changeAnimation](options);\n\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      this[$paused] = true;\n\n      if (this.animationName != null) {\n        this[$changeAnimation]();\n      }\n\n      if (this.autoplay) {\n        this.play();\n      }\n    }\n\n    [$tick](_time: number, delta: number) {\n      super[$tick](_time, delta);\n\n      if (this[$paused] ||\n          (!this[$getModelIsVisible]() && !this[$renderer].isPresenting)) {\n        return;\n      }\n\n      this[$scene].updateAnimation(delta / MILLISECONDS_PER_SECOND);\n\n      this[$needsRender]();\n    }\n\n    updated(changedProperties: Map<string, any>) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n\n    [$changeAnimation](options: PlayAnimationOptions = DEFAULT_PLAY_OPTIONS) {\n      const repetitions = options.repetitions ?? Infinity;\n      const mode = options.pingpong ?\n          LoopPingPong :\n          (repetitions === 1 ? LoopOnce : LoopRepeat);\n      this[$scene].playAnimation(\n          this.animationName,\n          this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND,\n          mode,\n          repetitions);\n\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n  }\n\n  return AnimationModelViewerElement;\n};\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;AAeA,SAAQA,QAAQ,QAAO,mBAAmB;AAC1C,SAAQC,QAAQ,EAAEC,YAAY,EAAEC,UAAU,QAAO,OAAO;AAExD,SAAgCC,kBAAkB,EAAEC,YAAY,EAAEC,YAAY,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,QAAO,yBAAyB;AAGxI,MAAMC,uBAAuB,GAAG,MAAM;AAEtC,MAAMC,gBAAgB,GAAGC,MAAM,CAAC,iBAAiB,CAAC;AAClD,MAAMC,OAAO,GAAGD,MAAM,CAAC,QAAQ,CAAC;AAMhC,MAAME,oBAAoB,GAAyB;EACjDC,WAAW,EAAEC,QAAQ;EACrBC,QAAQ,EAAE;CACX;AAeD,OAAO,MAAMC,cAAc,GACvBC,kBAAqB,IAAuC;;EAC9D,MAAMC,2BAA4B,SAAQD,kBAAkB;IAS1DE,YAAY,GAAGC,IAAW;MACxB,KAAK,CAACA,IAAI,CAAC;MATc,KAAAC,QAAQ,GAAY,KAAK;MAEpD,KAAAC,aAAa,GAAqBC,SAAS;MAE3C,KAAAC,0BAA0B,GAAW,GAAG;MAE/B,KAAAC,EAAA,CAAS,GAAY,IAAI;MAKhC,IAAI,CAACnB,MAAM,CAAC,CAACoB,mBAAmB,CAAC,MAAM,EAAGC,CAAC,IAAI;QAC7C,MAAMC,KAAK,GAAGD,CAAC,CAACE,MAAM,CAACC,UAAU;QACjC,IAAI,CAACC,aAAa,CAAC,IAAIC,WAAW,CAAC,MAAM,EAAE;UAACC,MAAM,EAAE;YAACL;UAAK;QAAC,CAAC,CAAC,CAAC;MAChE,CAAC,CAAC;MACF,IAAI,CAACtB,MAAM,CAAC,CAACoB,mBAAmB,CAAC,UAAU,EAAE,MAAK;QAChD,IAAI,CAACf,OAAO,CAAC,GAAG,IAAI;QACpB,IAAI,CAACoB,aAAa,CAAC,IAAIC,WAAW,CAAC,UAAU,CAAC,CAAC;MACjD,CAAC,CAAC;IACJ;IAEA;;;IAGA,IAAIE,mBAAmBA,CAAA;MACrB,IAAI,IAAI,CAACC,MAAM,EAAE;QACf,OAAO,IAAI,CAAC7B,MAAM,CAAC,CAAC8B,cAAc;;MAGpC,OAAO,EAAE;IACX;IAEA,IAAIC,QAAQA,CAAA;MACV,OAAO,IAAI,CAAC/B,MAAM,CAAC,CAAC+B,QAAQ;IAC9B;IAEA,IAAIC,MAAMA,CAAA;MACR,OAAO,IAAI,CAAC3B,OAAO,CAAC;IACtB;IAEA,IAAI4B,WAAWA,CAAA;MACb,OAAO,IAAI,CAACjC,MAAM,CAAC,CAACkC,aAAa;IACnC;IAEA,IAAID,WAAWA,CAACE,KAAa;MAC3B,IAAI,CAACnC,MAAM,CAAC,CAACkC,aAAa,GAAGC,KAAK;MAClC,IAAI,CAACtC,YAAY,CAAC,EAAE;IACtB;IAEA,IAAIuC,SAASA,CAAA;MACX,OAAO,IAAI,CAACpC,MAAM,CAAC,CAACqC,kBAAkB;IACxC;IAEA,IAAID,SAASA,CAACD,KAAa;MACzB,IAAI,CAACnC,MAAM,CAAC,CAACqC,kBAAkB,GAAGF,KAAK;IACzC;IAEAG,KAAKA,CAAA;MACH,IAAI,IAAI,CAACjC,OAAO,CAAC,EAAE;QACjB;;MAGF,IAAI,CAACA,OAAO,CAAC,GAAG,IAAI;MACpB,IAAI,CAACoB,aAAa,CAAC,IAAIC,WAAW,CAAC,OAAO,CAAC,CAAC;IAC9C;IAEAa,IAAIA,CAACC,OAA8B;MACjC,IAAI,IAAI,CAACZ,mBAAmB,CAACa,MAAM,GAAG,CAAC,EAAE;QACvC,IAAI,CAACpC,OAAO,CAAC,GAAG,KAAK;QAErB,IAAI,CAACF,gBAAgB,CAAC,CAACqC,OAAO,CAAC;QAE/B,IAAI,CAACf,aAAa,CAAC,IAAIC,WAAW,CAAC,MAAM,CAAC,CAAC;;IAE/C;IAEA,EAAAP,EAAA,GAtEUd,OAAO,EAsEhBP,YAAY,KAAC;MACZ,KAAK,CAACA,YAAY,CAAC,EAAE;MAErB,IAAI,CAACO,OAAO,CAAC,GAAG,IAAI;MAEpB,IAAI,IAAI,CAACW,aAAa,IAAI,IAAI,EAAE;QAC9B,IAAI,CAACb,gBAAgB,CAAC,EAAE;;MAG1B,IAAI,IAAI,CAACY,QAAQ,EAAE;QACjB,IAAI,CAACwB,IAAI,EAAE;;IAEf;IAEA,CAACtC,KAAK,EAAEyC,KAAa,EAAEC,KAAa;MAClC,KAAK,CAAC1C,KAAK,CAAC,CAACyC,KAAK,EAAEC,KAAK,CAAC;MAE1B,IAAI,IAAI,CAACtC,OAAO,CAAC,IACZ,CAAC,IAAI,CAACT,kBAAkB,CAAC,EAAE,IAAI,CAAC,IAAI,CAACG,SAAS,CAAC,CAAC6C,YAAa,EAAE;QAClE;;MAGF,IAAI,CAAC5C,MAAM,CAAC,CAAC6C,eAAe,CAACF,KAAK,GAAGzC,uBAAuB,CAAC;MAE7D,IAAI,CAACL,YAAY,CAAC,EAAE;IACtB;IAEAiD,OAAOA,CAACC,iBAAmC;MACzC,KAAK,CAACD,OAAO,CAACC,iBAAiB,CAAC;MAEhC,IAAIA,iBAAiB,CAACC,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,CAACjC,QAAQ,EAAE;QACtD,IAAI,CAACwB,IAAI,EAAE;;MAGb,IAAIQ,iBAAiB,CAACC,GAAG,CAAC,eAAe,CAAC,EAAE;QAC1C,IAAI,CAAC7C,gBAAgB,CAAC,EAAE;;IAE5B;IAEA,CAACA,gBAAgB,EAAEqC,OAAA,GAAgClC,oBAAoB;;MACrE,MAAMC,WAAW,GAAG,CAAA0C,EAAA,GAAAT,OAAO,CAACjC,WAAW,cAAA0C,EAAA,cAAAA,EAAA,GAAIzC,QAAQ;MACnD,MAAM0C,IAAI,GAAGV,OAAO,CAAC/B,QAAQ,GACzBf,YAAY,GACXa,WAAW,KAAK,CAAC,GAAGd,QAAQ,GAAGE,UAAW;MAC/C,IAAI,CAACK,MAAM,CAAC,CAACmD,aAAa,CACtB,IAAI,CAACnC,aAAa,EAClB,IAAI,CAACE,0BAA0B,GAAGhB,uBAAuB,EACzDgD,IAAI,EACJ3C,WAAW,CAAC;MAEhB;MACA;MACA,IAAI,IAAI,CAACF,OAAO,CAAC,EAAE;QACjB,IAAI,CAACL,MAAM,CAAC,CAAC6C,eAAe,CAAC,CAAC,CAAC;QAC/B,IAAI,CAAChD,YAAY,CAAC,EAAE;;IAExB;;EApI2BuD,UAAA,EAA1B5D,QAAQ,CAAC;IAAC6D,IAAI,EAAEC;EAAO,CAAC,CAAC,C,4DAA2B;EAErDF,UAAA,EADC5D,QAAQ,CAAC;IAAC6D,IAAI,EAAEE,MAAM;IAAEC,SAAS,EAAE;EAAgB,CAAC,CAAC,C,iEACV;EAE5CJ,UAAA,EADC5D,QAAQ,CAAC;IAAC6D,IAAI,EAAEI,MAAM;IAAED,SAAS,EAAE;EAA8B,CAAC,CAAC,C,8EAC3B;EAmI3C,OAAO5C,2BAA2B;AACpC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}