{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventDispatcher, Matrix4, PerspectiveCamera, Vector3 } from 'three';\nimport { XREstimatedLight } from 'three/examples/jsm/webxr/XREstimatedLight.js';\nimport { $currentBackground, $currentEnvironmentMap } from '../features/environment.js';\nimport { $onResize } from '../model-viewer-base.js';\nimport { assertIsArCandidate } from '../utilities.js';\nimport { Damper } from './Damper.js';\nimport { PlacementBox } from './PlacementBox.js';\nimport { ChangeSource } from './SmoothControls.js';\n// number of initial null pose XRFrames allowed before we post not-tracking\nconst INIT_FRAMES = 30;\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.8;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP_HIGH = 1.3;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\n// For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\nconst MIN_VIEWPORT_SCALE = 0.25;\n// Furthest away you can move an object (meters).\nconst MAX_DISTANCE = 10;\nexport const ARStatus = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed'\n};\nexport const ARTracking = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking'\n};\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\nexport class ARRenderer extends EventDispatcher {\n  constructor(renderer) {\n    super();\n    this.renderer = renderer;\n    this.currentSession = null;\n    this.placeOnWall = false;\n    this.placementBox = null;\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.initialHitSource = null;\n    this.transientHitTestSource = null;\n    this.inputSource = null;\n    this._presentedScene = null;\n    this.resolveCleanup = null;\n    this.exitWebXRButtonContainer = null;\n    this.overlay = null;\n    this.xrLight = null;\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.oldTarget = new Vector3();\n    this.placementComplete = false;\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.lastDragPosition = new Vector3();\n    this.firstRatio = 0;\n    this.lastAngle = 0;\n    this.goalPosition = new Vector3();\n    this.goalYaw = 0;\n    this.goalScale = 1;\n    this.xDamper = new Damper();\n    this.yDamper = new Damper();\n    this.zDamper = new Damper();\n    this.yawDamper = new Damper();\n    this.scaleDamper = new Damper();\n    this.onExitWebXRButtonContainerClick = () => this.stopPresenting();\n    this.onUpdateScene = () => {\n      if (this.placementBox != null && this.isPresenting) {\n        this.placementBox.dispose();\n        this.placementBox = new PlacementBox(this.presentedScene, this.placeOnWall ? 'back' : 'bottom');\n      }\n    };\n    this.onSelectStart = event => {\n      const hitSource = this.transientHitTestSource;\n      if (hitSource == null) {\n        return;\n      }\n      const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);\n      const scene = this.presentedScene;\n      const box = this.placementBox;\n      if (fingers.length === 1) {\n        this.inputSource = event.inputSource;\n        const {\n          axes\n        } = this.inputSource.gamepad;\n        const hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);\n        box.show = true;\n        if (hitPosition != null) {\n          this.isTranslating = true;\n          this.lastDragPosition.copy(hitPosition);\n        } else if (this.placeOnWall === false) {\n          this.isRotating = true;\n          this.lastAngle = axes[0] * ROTATION_RATE;\n        }\n      } else if (fingers.length === 2) {\n        box.show = true;\n        this.isTwoFingering = true;\n        const {\n          separation\n        } = this.fingerPolar(fingers);\n        this.firstRatio = separation / scene.scale.x;\n      }\n    };\n    this.onSelectEnd = () => {\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = false;\n      this.inputSource = null;\n      this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x;\n      this.placementBox.show = false;\n    };\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n  }\n  async resolveARSession() {\n    assertIsArCandidate();\n    const session = await navigator.xr.requestSession('immersive-ar', {\n      requiredFeatures: ['hit-test'],\n      optionalFeatures: ['dom-overlay', 'light-estimation'],\n      domOverlay: this.overlay ? {\n        root: this.overlay\n      } : undefined\n    });\n    this.threeRenderer.xr.setReferenceSpaceType('local');\n    await this.threeRenderer.xr.setSession(session);\n    this.threeRenderer.xr.cameraAutoUpdate = false;\n    return session;\n  }\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this._presentedScene;\n  }\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr.isSessionSupported('immersive-ar');\n    } catch (error) {\n      console.warn('Request to present in WebXR denied:');\n      console.warn(error);\n      console.warn('Falling back to next ar-mode');\n      return false;\n    }\n  }\n  /**\n   * Present a scene in AR\n   */\n  async present(scene, environmentEstimation = false) {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n    let waitForAnimationFrame = new Promise((resolve, _reject) => {\n      requestAnimationFrame(() => resolve());\n    });\n    scene.setHotspotsVisibility(false);\n    scene.queueRender();\n    // Render a frame to turn off the hotspots\n    await waitForAnimationFrame;\n    // This sets isPresenting to true\n    this._presentedScene = scene;\n    this.overlay = scene.element.shadowRoot.querySelector('div.default');\n    if (environmentEstimation === true) {\n      this.xrLight = new XREstimatedLight(this.threeRenderer);\n      this.xrLight.addEventListener('estimationstart', () => {\n        if (!this.isPresenting || this.xrLight == null) {\n          return;\n        }\n        const scene = this.presentedScene;\n        scene.add(this.xrLight);\n        scene.environment = this.xrLight.environment;\n      });\n    }\n    const currentSession = await this.resolveARSession();\n    currentSession.addEventListener('end', () => {\n      this.postSessionCleanup();\n    }, {\n      once: true\n    });\n    const exitButton = scene.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button');\n    exitButton.classList.add('enabled');\n    exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);\n    this.exitWebXRButtonContainer = exitButton;\n    const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.turntableRotation = scene.yaw;\n    this.goalYaw = scene.yaw;\n    this.goalScale = 1;\n    scene.background = null;\n    this.oldShadowIntensity = scene.shadowIntensity;\n    scene.setShadowIntensity(0.01); // invisible, but not changing the shader\n    this.oldTarget.copy(scene.getTarget());\n    scene.element.addEventListener('load', this.onUpdateScene);\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = this.placeOnWall === true ? undefined : new XRRay(new DOMPoint(0, 0, 0), {\n      x: 0,\n      y: -Math.sin(radians),\n      z: -Math.cos(radians)\n    });\n    currentSession.requestHitTestSource({\n      space: viewerRefSpace,\n      offsetRay: ray\n    }).then(hitTestSource => {\n      this.initialHitSource = hitTestSource;\n    });\n    this.currentSession = currentSession;\n    this.placementBox = new PlacementBox(scene, this.placeOnWall ? 'back' : 'bottom');\n    this.placementComplete = false;\n    this.lastTick = performance.now();\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.SESSION_STARTED\n    });\n  }\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n    const cleanupPromise = new Promise(resolve => {\n      this.resolveCleanup = resolve;\n    });\n    try {\n      await this.currentSession.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end WebXR AR session');\n      console.warn(error);\n      this.postSessionCleanup();\n    }\n  }\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting() {\n    return this.presentedScene != null;\n  }\n  get target() {\n    return this.oldTarget;\n  }\n  updateTarget() {\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n  postSessionCleanup() {\n    const session = this.currentSession;\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n    const scene = this.presentedScene;\n    this._presentedScene = null;\n    if (scene != null) {\n      const {\n        element\n      } = scene;\n      if (this.xrLight != null) {\n        scene.remove(this.xrLight);\n        this.xrLight.dispose();\n        this.xrLight = null;\n      }\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      scene.setShadowOffset(0);\n      const yaw = this.turntableRotation;\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n      const intensity = this.oldShadowIntensity;\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n      scene.setEnvironmentAndSkybox(element[$currentEnvironmentMap], element[$currentBackground]);\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.xrCamera = null;\n      scene.element.removeEventListener('load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element.requestUpdate('maxCameraOrbit');\n      element[$onResize](element.getBoundingClientRect());\n      requestAnimationFrame(() => {\n        scene.element.dispatchEvent(new CustomEvent('camera-change', {\n          detail: {\n            source: ChangeSource.NONE\n          }\n        }));\n      });\n    }\n    // Force the Renderer to update its size\n    this.renderer.height = 0;\n    const exitButton = this.exitWebXRButtonContainer;\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener('click', this.onExitWebXRButtonContainerClick);\n      this.exitWebXRButtonContainer = null;\n    }\n    const hitSource = this.transientHitTestSource;\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n    const hitSourceInitial = this.initialHitSource;\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n    if (this.placementBox != null) {\n      this.placementBox.dispose();\n      this.placementBox = null;\n    }\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup();\n    }\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.NOT_PRESENTING\n    });\n  }\n  updateView(view) {\n    const scene = this.presentedScene;\n    const xr = this.threeRenderer.xr;\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const {\n      elements\n    } = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    }\n    // Use automatic dynamic viewport scaling if supported.\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n    const layer = xr.getBaseLayer();\n    if (layer != null) {\n      const viewport = layer instanceof XRWebGLLayer ? layer.getViewport(view) : xr.getBinding().getViewSubImage(layer, view).viewport;\n      this.threeRenderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);\n    }\n  }\n  placeInitially() {\n    const scene = this.presentedScene;\n    const {\n      position,\n      element\n    } = scene;\n    const xrCamera = scene.getCamera();\n    const {\n      width,\n      height\n    } = this.overlay.getBoundingClientRect();\n    scene.setSize(width, height);\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n    const {\n      theta,\n      radius\n    } = element.getCameraOrbit();\n    // Orient model to match the 3D camera view\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n    position.copy(xrCamera.position).add(cameraDirection.multiplyScalar(radius));\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n    this.goalPosition.copy(position);\n    scene.setHotspotsVisibility(true);\n    const {\n      session\n    } = this.frame;\n    session.addEventListener('selectstart', this.onSelectStart);\n    session.addEventListener('selectend', this.onSelectEnd);\n    session.requestHitTestSourceForTransientInput({\n      profile: 'generic-touchscreen'\n    }).then(hitTestSource => {\n      this.transientHitTestSource = hitTestSource;\n    });\n  }\n  getTouchLocation() {\n    const {\n      axes\n    } = this.inputSource.gamepad;\n    let location = this.placementBox.getExpandedHit(this.presentedScene, axes[0], axes[1]);\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE) return null;\n    }\n    return location;\n  }\n  getHitPoint(hitResult) {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = hitResult.getPose(refSpace);\n    if (pose == null) {\n      return null;\n    }\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    }\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ? hitPosition.setFromMatrixPosition(hitMatrix) : null;\n  }\n  moveToFloor(frame) {\n    const hitSource = this.initialHitSource;\n    if (hitSource == null) {\n      return;\n    }\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n    if (hitPoint == null) {\n      return;\n    }\n    this.placementBox.show = true;\n    // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.OBJECT_PLACED\n    });\n  }\n  fingerPolar(fingers) {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw\n    };\n  }\n  processInput(frame) {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene;\n    const scale = scene.scale.x;\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const {\n          separation,\n          deltaYaw\n        } = this.fingerPolar(fingers);\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n        if (scene.canScale) {\n          const scale = separation / this.firstRatio;\n          this.goalScale = scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW ? 1 : scale;\n        }\n      }\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const {\n        separation\n      } = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n    if (this.isRotating) {\n      const angle = this.inputSource.gamepad.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n        let hit = null;\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0]);\n        }\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n        if (hit == null) {\n          return;\n        }\n        this.goalPosition.sub(this.lastDragPosition);\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y;\n          // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n          if (offset < 0) {\n            this.placementBox.offsetHeight = offset / scale;\n            this.presentedScene.setShadowOffset(offset);\n            // Interpolate hit ray up to drag plane\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n  moveScene(delta) {\n    const scene = this.presentedScene;\n    const {\n      position,\n      yaw\n    } = scene;\n    const boundingRadius = scene.boundingSphere.radius;\n    const goal = this.goalPosition;\n    const oldScale = scene.scale.x;\n    const box = this.placementBox;\n    let source = ChangeSource.NONE;\n    if (!goal.equals(position) || this.goalScale !== oldScale) {\n      source = ChangeSource.USER_INTERACTION;\n      let {\n        x,\n        y,\n        z\n      } = position;\n      x = this.xDamper.update(x, goal.x, delta, boundingRadius);\n      y = this.yDamper.update(y, goal.y, delta, boundingRadius);\n      z = this.zDamper.update(z, goal.z, delta, boundingRadius);\n      position.set(x, y, z);\n      const newScale = this.scaleDamper.update(oldScale, this.goalScale, delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n      if (!this.isTranslating) {\n        const offset = goal.y - y;\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / newScale;\n          scene.setShadowOffset(offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n    }\n    box.updateOpacity(delta);\n    scene.updateTarget(delta);\n    // yaw must be updated last, since this also updates the shadow position.\n    scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);\n    // camera changes on every frame - user-interaction only if touching the\n    // screen, plus damping time.\n    scene.element.dispatchEvent(new CustomEvent('camera-change', {\n      detail: {\n        source\n      }\n    }));\n  }\n  /**\n   * Only public to make it testable.\n   */\n  onWebXRFrame(time, frame) {\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = frame.getViewerPose(refSpace);\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.NOT_TRACKING\n      });\n    }\n    const scene = this.presentedScene;\n    if (pose == null || scene == null || !scene.element.loaded) {\n      this.threeRenderer.clear();\n      return;\n    }\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.TRACKING\n      });\n    }\n    // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n    let isFirstView = true;\n    for (const view of pose.views) {\n      this.updateView(view);\n      if (isFirstView) {\n        this.moveToFloor(frame);\n        this.processInput(frame);\n        const delta = time - this.lastTick;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n        scene.renderShadow(this.threeRenderer);\n      }\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n}","map":{"version":3,"names":["EventDispatcher","Matrix4","PerspectiveCamera","Vector3","XREstimatedLight","$currentBackground","$currentEnvironmentMap","$onResize","assertIsArCandidate","Damper","PlacementBox","ChangeSource","INIT_FRAMES","AR_SHADOW_INTENSITY","ROTATION_RATE","HIT_ANGLE_DEG","SCALE_SNAP_HIGH","SCALE_SNAP_LOW","MIN_VIEWPORT_SCALE","MAX_DISTANCE","ARStatus","NOT_PRESENTING","SESSION_STARTED","OBJECT_PLACED","FAILED","ARTracking","TRACKING","NOT_TRACKING","vector3","matrix4","hitPosition","camera","ARRenderer","constructor","renderer","currentSession","placeOnWall","placementBox","lastTick","turntableRotation","oldShadowIntensity","frame","initialHitSource","transientHitTestSource","inputSource","_presentedScene","resolveCleanup","exitWebXRButtonContainer","overlay","xrLight","tracking","frames","initialized","oldTarget","placementComplete","isTranslating","isRotating","isTwoFingering","lastDragPosition","firstRatio","lastAngle","goalPosition","goalYaw","goalScale","xDamper","yDamper","zDamper","yawDamper","scaleDamper","onExitWebXRButtonContainerClick","stopPresenting","onUpdateScene","isPresenting","dispose","presentedScene","onSelectStart","event","hitSource","fingers","getHitTestResultsForTransientInput","scene","box","length","axes","gamepad","getHit","show","copy","separation","fingerPolar","scale","x","onSelectEnd","y","offsetHeight","threeRenderer","xr","enabled","resolveARSession","session","navigator","requestSession","requiredFeatures","optionalFeatures","domOverlay","root","undefined","setReferenceSpaceType","setSession","cameraAutoUpdate","supportsPresentation","isSessionSupported","error","console","warn","present","environmentEstimation","waitForAnimationFrame","Promise","resolve","_reject","requestAnimationFrame","setHotspotsVisibility","queueRender","element","shadowRoot","querySelector","addEventListener","add","environment","postSessionCleanup","once","exitButton","classList","viewerRefSpace","requestReferenceSpace","yaw","background","shadowIntensity","setShadowIntensity","getTarget","radians","Math","PI","ray","XRRay","DOMPoint","sin","z","cos","requestHitTestSource","space","offsetRay","then","hitTestSource","performance","now","dispatchEvent","type","status","cleanupPromise","end","target","updateTarget","boundingBox","min","setTarget","removeEventListener","remove","position","set","setShadowOffset","intensity","setEnvironmentAndSkybox","point","xrCamera","orientHotspots","requestUpdate","getBoundingClientRect","CustomEvent","detail","source","NONE","height","cancel","hitSourceInitial","updateView","view","updateCamera","getCamera","elements","matrixWorld","atan2","placeInitially","requestViewportScale","recommendedViewportScale","max","layer","getBaseLayer","viewport","XRWebGLLayer","getViewport","getBinding","getViewSubImage","setViewport","width","setSize","projectionMatrixInverse","projectionMatrix","invert","theta","radius","getCameraOrbit","cameraDirection","getWorldDirection","multiplyScalar","sub","requestHitTestSourceForTransientInput","profile","getTouchLocation","location","getExpandedHit","getHitPoint","hitResult","refSpace","getReferenceSpace","pose","getPose","hitMatrix","fromArray","transform","matrix","setFromMatrixPosition","moveToFloor","hitTestResults","getHitTestResults","hit","hitPoint","fingerOne","fingerTwo","deltaX","deltaY","angle","deltaYaw","sqrt","processInput","canScale","forEach","finger","results","offset","cameraPosition","alpha","moveScene","delta","boundingRadius","boundingSphere","goal","oldScale","equals","USER_INTERACTION","update","newScale","updateOpacity","onWebXRFrame","time","getViewerPose","loaded","clear","isFirstView","views","preRender","renderShadow","render"],"sources":["../../src/three-components/ARRenderer.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Event as ThreeEvent, EventDispatcher, Matrix4, PerspectiveCamera, Vector3, WebGLRenderer} from 'three';\nimport {XREstimatedLight} from 'three/examples/jsm/webxr/XREstimatedLight.js';\n\nimport {CameraChangeDetails, ControlsInterface} from '../features/controls.js';\nimport {$currentBackground, $currentEnvironmentMap} from '../features/environment.js';\nimport ModelViewerElementBase, {$onResize} from '../model-viewer-base.js';\nimport {assertIsArCandidate} from '../utilities.js';\n\nimport {Damper} from './Damper.js';\nimport {ModelScene} from './ModelScene.js';\nimport {PlacementBox} from './PlacementBox.js';\nimport {Renderer} from './Renderer.js';\nimport {ChangeSource} from './SmoothControls.js';\n\n// number of initial null pose XRFrames allowed before we post not-tracking\nconst INIT_FRAMES = 30;\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.8;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP_HIGH = 1.3;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\n// For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\nconst MIN_VIEWPORT_SCALE = 0.25;\n// Furthest away you can move an object (meters).\nconst MAX_DISTANCE = 10;\n\nexport type ARStatus =\n    'not-presenting'|'session-started'|'object-placed'|'failed';\n\nexport const ARStatus: {[index: string]: ARStatus} = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed'\n};\n\nexport interface ARStatusEvent extends ThreeEvent {\n  status: ARStatus,\n}\n\nexport type ARTracking = 'tracking'|'not-tracking';\n\nexport const ARTracking: {[index: string]: ARTracking} = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking'\n};\n\nexport interface ARTrackingEvent extends ThreeEvent {\n  status: ARTracking,\n}\n\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\n\nexport class ARRenderer extends EventDispatcher<\n    {status: {status: ARStatus}, tracking: {status: ARTracking}}> {\n  public threeRenderer: WebGLRenderer;\n  public currentSession: XRSession|null = null;\n  public placeOnWall = false;\n\n  private placementBox: PlacementBox|null = null;\n  private lastTick: number|null = null;\n  private turntableRotation: number|null = null;\n  private oldShadowIntensity: number|null = null;\n  private frame: XRFrame|null = null;\n  private initialHitSource: XRHitTestSource|null = null;\n  private transientHitTestSource: XRTransientInputHitTestSource|null = null;\n  private inputSource: XRInputSource|null = null;\n  private _presentedScene: ModelScene|null = null;\n  private resolveCleanup: ((...args: any[]) => void)|null = null;\n  private exitWebXRButtonContainer: HTMLElement|null = null;\n  private overlay: HTMLElement|null = null;\n  private xrLight: XREstimatedLight|null = null;\n\n  private tracking = true;\n  private frames = 0;\n  private initialized = false;\n  private oldTarget = new Vector3();\n  private placementComplete = false;\n  private isTranslating = false;\n  private isRotating = false;\n  private isTwoFingering = false;\n  private lastDragPosition = new Vector3();\n  private firstRatio = 0;\n  private lastAngle = 0;\n  private goalPosition = new Vector3();\n  private goalYaw = 0;\n  private goalScale = 1;\n  private xDamper = new Damper();\n  private yDamper = new Damper();\n  private zDamper = new Damper();\n  private yawDamper = new Damper();\n  private scaleDamper = new Damper();\n\n  private onExitWebXRButtonContainerClick = () => this.stopPresenting();\n\n  constructor(private renderer: Renderer) {\n    super();\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n  }\n\n  async resolveARSession(): Promise<XRSession> {\n    assertIsArCandidate();\n\n    const session: XRSession =\n        await navigator.xr!.requestSession!('immersive-ar', {\n          requiredFeatures: ['hit-test'],\n          optionalFeatures: ['dom-overlay', 'light-estimation'],\n          domOverlay: this.overlay ? {root: this.overlay} : undefined\n        });\n\n    this.threeRenderer.xr.setReferenceSpaceType('local');\n\n    await this.threeRenderer.xr.setSession(session);\n\n    this.threeRenderer.xr.cameraAutoUpdate = false;\n\n    return session;\n  }\n\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this._presentedScene;\n  }\n\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation(): Promise<boolean> {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr!.isSessionSupported('immersive-ar');\n    } catch (error) {\n      console.warn('Request to present in WebXR denied:');\n      console.warn(error);\n      console.warn('Falling back to next ar-mode');\n      return false;\n    }\n  }\n\n  /**\n   * Present a scene in AR\n   */\n  async present(scene: ModelScene, environmentEstimation: boolean = false):\n      Promise<void> {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n\n    let waitForAnimationFrame = new Promise<void>((resolve, _reject) => {\n      requestAnimationFrame(() => resolve());\n    });\n\n    scene.setHotspotsVisibility(false);\n    scene.queueRender();\n    // Render a frame to turn off the hotspots\n    await waitForAnimationFrame;\n\n    // This sets isPresenting to true\n    this._presentedScene = scene;\n    this.overlay = scene.element.shadowRoot!.querySelector('div.default');\n\n    if (environmentEstimation === true) {\n      this.xrLight = new XREstimatedLight(this.threeRenderer);\n\n      this.xrLight.addEventListener('estimationstart', () => {\n        if (!this.isPresenting || this.xrLight == null) {\n          return;\n        }\n\n        const scene = this.presentedScene!;\n        scene.add(this.xrLight);\n\n        scene.environment = this.xrLight.environment;\n      });\n    }\n\n    const currentSession = await this.resolveARSession();\n\n    currentSession.addEventListener('end', () => {\n      this.postSessionCleanup();\n    }, {once: true});\n\n    const exitButton = scene.element.shadowRoot!.querySelector(\n                           '.slot.exit-webxr-ar-button') as HTMLElement;\n    exitButton.classList.add('enabled');\n    exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);\n    this.exitWebXRButtonContainer = exitButton;\n\n    const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');\n\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n\n    this.turntableRotation = scene.yaw;\n    this.goalYaw = scene.yaw;\n    this.goalScale = 1;\n\n    scene.background = null;\n\n    this.oldShadowIntensity = scene.shadowIntensity;\n    scene.setShadowIntensity(0.01);  // invisible, but not changing the shader\n\n    this.oldTarget.copy(scene.getTarget());\n\n    scene.element.addEventListener('load', this.onUpdateScene);\n\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = this.placeOnWall === true ?\n        undefined :\n        new XRRay(\n            new DOMPoint(0, 0, 0),\n            {x: 0, y: -Math.sin(radians), z: -Math.cos(radians)});\n    currentSession\n        .requestHitTestSource!\n        ({space: viewerRefSpace, offsetRay: ray})!.then(hitTestSource => {\n          this.initialHitSource = hitTestSource;\n        });\n\n    this.currentSession = currentSession;\n    this.placementBox =\n        new PlacementBox(scene, this.placeOnWall ? 'back' : 'bottom');\n    this.placementComplete = false;\n\n    this.lastTick = performance.now();\n    this.dispatchEvent({type: 'status', status: ARStatus.SESSION_STARTED});\n  }\n\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n\n    const cleanupPromise = new Promise((resolve) => {\n      this.resolveCleanup = resolve;\n    });\n\n    try {\n      await this.currentSession!.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end WebXR AR session');\n      console.warn(error);\n\n      this.postSessionCleanup();\n    }\n  }\n\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting(): boolean {\n    return this.presentedScene != null;\n  }\n\n  get target(): Vector3 {\n    return this.oldTarget;\n  }\n\n  updateTarget() {\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n\n  onUpdateScene = () => {\n    if (this.placementBox != null && this.isPresenting) {\n      this.placementBox!.dispose();\n      this.placementBox = new PlacementBox(\n          this.presentedScene!, this.placeOnWall ? 'back' : 'bottom');\n    }\n  };\n\n  private postSessionCleanup() {\n    const session = this.currentSession;\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n\n    const scene = this.presentedScene;\n    this._presentedScene = null;\n    if (scene != null) {\n      const {element} = scene;\n\n      if (this.xrLight != null) {\n        scene.remove(this.xrLight);\n        (this.xrLight as any).dispose();\n        this.xrLight = null;\n      }\n\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      scene.setShadowOffset(0);\n      const yaw = this.turntableRotation;\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n      const intensity = this.oldShadowIntensity;\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n      scene.setEnvironmentAndSkybox(\n          (element as any)[$currentEnvironmentMap],\n          (element as any)[$currentBackground]);\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.xrCamera = null;\n\n      scene.element.removeEventListener('load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element.requestUpdate('maxCameraOrbit');\n      element[$onResize](element.getBoundingClientRect());\n\n      requestAnimationFrame(() => {\n        scene.element.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n            'camera-change', {detail: {source: ChangeSource.NONE}}));\n      });\n    }\n\n    // Force the Renderer to update its size\n    this.renderer.height = 0;\n\n    const exitButton = this.exitWebXRButtonContainer;\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener(\n          'click', this.onExitWebXRButtonContainerClick);\n      this.exitWebXRButtonContainer = null;\n    }\n\n    const hitSource = this.transientHitTestSource;\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n\n    const hitSourceInitial = this.initialHitSource;\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n\n    if (this.placementBox != null) {\n      this.placementBox!.dispose();\n      this.placementBox = null;\n    }\n\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup!();\n    }\n\n    this.dispatchEvent({type: 'status', status: ARStatus.NOT_PRESENTING});\n  }\n\n  private updateView(view: XRView) {\n    const scene = this.presentedScene!;\n    const xr = this.threeRenderer.xr;\n\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const {elements} = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    }\n\n    // Use automatic dynamic viewport scaling if supported.\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n    const layer = xr.getBaseLayer();\n    if (layer != null) {\n      const viewport = layer instanceof XRWebGLLayer ?\n          layer!.getViewport(view)! :\n          xr.getBinding().getViewSubImage(layer, view).viewport;\n      this.threeRenderer.setViewport(\n          viewport.x, viewport.y, viewport.width, viewport.height);\n    }\n  }\n\n  private placeInitially() {\n    const scene = this.presentedScene!;\n    const {position, element} = scene;\n    const xrCamera = scene.getCamera();\n\n    const {width, height} = this.overlay!.getBoundingClientRect();\n    scene.setSize(width, height);\n\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n\n    const {theta, radius} =\n        (element as ModelViewerElementBase & ControlsInterface)\n            .getCameraOrbit();\n    // Orient model to match the 3D camera view\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n\n    position.copy(xrCamera.position)\n        .add(cameraDirection.multiplyScalar(radius));\n\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n\n    this.goalPosition.copy(position);\n\n    scene.setHotspotsVisibility(true);\n\n    const {session} = this.frame!;\n    session.addEventListener('selectstart', this.onSelectStart);\n    session.addEventListener('selectend', this.onSelectEnd);\n    session\n        .requestHitTestSourceForTransientInput!\n        ({profile: 'generic-touchscreen'})!.then(hitTestSource => {\n          this.transientHitTestSource = hitTestSource;\n        });\n  }\n\n  private getTouchLocation(): Vector3|null {\n    const {axes} = this.inputSource!.gamepad!;\n    let location = this.placementBox!.getExpandedHit(\n        this.presentedScene!, axes[0], axes[1]);\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene!.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE)\n        return null;\n    }\n    return location;\n  }\n\n  private getHitPoint(hitResult: XRHitTestResult): Vector3|null {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace()!;\n    const pose = hitResult.getPose(refSpace);\n    if (pose == null) {\n      return null;\n    }\n\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    }\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ?\n        hitPosition.setFromMatrixPosition(hitMatrix) :\n        null;\n  }\n\n  public moveToFloor(frame: XRFrame) {\n    const hitSource = this.initialHitSource;\n    if (hitSource == null) {\n      return;\n    }\n\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n    if (hitPoint == null) {\n      return;\n    }\n\n    this.placementBox!.show = true;\n\n    // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({type: 'status', status: ARStatus.OBJECT_PLACED});\n  }\n\n  private onSelectStart = (event: Event) => {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    const fingers = this.frame!.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene!;\n    const box = this.placementBox!;\n\n    if (fingers.length === 1) {\n      this.inputSource = (event as XRInputSourceEvent).inputSource;\n      const {axes} = this.inputSource!.gamepad!;\n\n      const hitPosition = box.getHit(this.presentedScene!, axes[0], axes[1]);\n      box.show = true;\n\n      if (hitPosition != null) {\n        this.isTranslating = true;\n        this.lastDragPosition.copy(hitPosition);\n      } else if (this.placeOnWall === false) {\n        this.isRotating = true;\n        this.lastAngle = axes[0] * ROTATION_RATE;\n      }\n    } else if (fingers.length === 2) {\n      box.show = true;\n      this.isTwoFingering = true;\n      const {separation} = this.fingerPolar(fingers);\n      this.firstRatio = separation / scene.scale.x;\n    }\n  };\n\n  private onSelectEnd = () => {\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.inputSource = null;\n    this.goalPosition.y +=\n        this.placementBox!.offsetHeight * this.presentedScene!.scale.x;\n    this.placementBox!.show = false\n  };\n\n  private fingerPolar(fingers: XRTransientInputHitTestResult[]):\n      {separation: number, deltaYaw: number} {\n    const fingerOne = fingers[0].inputSource.gamepad!.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad!.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw\n    };\n  }\n\n  private processInput(frame: XRFrame) {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene!;\n    const scale = scene.scale.x;\n\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const {separation, deltaYaw} = this.fingerPolar(fingers);\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n        if (scene.canScale) {\n          const scale = separation / this.firstRatio;\n          this.goalScale =\n              (scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW) ? 1 : scale;\n        }\n      }\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const {separation} = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n\n    if (this.isRotating) {\n      const angle = this.inputSource!.gamepad!.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n\n        let hit = null;\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0])\n        }\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n        if (hit == null) {\n          return;\n        }\n\n        this.goalPosition.sub(this.lastDragPosition);\n\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y;\n          // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n          if (offset < 0) {\n            this.placementBox!.offsetHeight = offset / scale;\n            this.presentedScene!.setShadowOffset(offset);\n            // Interpolate hit ray up to drag plane\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n\n  private moveScene(delta: number) {\n    const scene = this.presentedScene!;\n    const {position, yaw} = scene;\n    const boundingRadius = scene.boundingSphere.radius;\n    const goal = this.goalPosition;\n    const oldScale = scene.scale.x;\n    const box = this.placementBox!;\n    let source = ChangeSource.NONE;\n\n    if (!goal.equals(position) || this.goalScale !== oldScale) {\n      source = ChangeSource.USER_INTERACTION;\n      let {x, y, z} = position;\n      x = this.xDamper.update(x, goal.x, delta, boundingRadius);\n      y = this.yDamper.update(y, goal.y, delta, boundingRadius);\n      z = this.zDamper.update(z, goal.z, delta, boundingRadius);\n      position.set(x, y, z);\n\n      const newScale =\n          this.scaleDamper.update(oldScale, this.goalScale, delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n\n      if (!this.isTranslating) {\n        const offset = goal.y - y;\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / newScale;\n          scene.setShadowOffset(offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n    }\n    box.updateOpacity(delta);\n    scene.updateTarget(delta);\n    // yaw must be updated last, since this also updates the shadow position.\n    scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);\n    // camera changes on every frame - user-interaction only if touching the\n    // screen, plus damping time.\n    scene.element.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n        'camera-change', {detail: {source}}));\n  }\n\n  /**\n   * Only public to make it testable.\n   */\n  public onWebXRFrame(time: number, frame: XRFrame) {\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace()!;\n    const pose = frame.getViewerPose(refSpace);\n\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({type: 'tracking', status: ARTracking.NOT_TRACKING});\n    }\n\n    const scene = this.presentedScene;\n    if (pose == null || scene == null || !scene.element.loaded) {\n      this.threeRenderer.clear();\n      return;\n    }\n\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({type: 'tracking', status: ARTracking.TRACKING});\n    }\n\n    // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n    let isFirstView: boolean = true;\n    for (const view of pose.views) {\n      this.updateView(view);\n\n      if (isFirstView) {\n        this.moveToFloor(frame);\n\n        this.processInput(frame);\n\n        const delta = time - this.lastTick!;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n\n        scene.renderShadow(this.threeRenderer);\n      }\n\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}