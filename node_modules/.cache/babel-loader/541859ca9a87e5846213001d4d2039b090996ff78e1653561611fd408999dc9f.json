{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Material } from 'three';\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nexport class CorrelatedSceneGraph {\n  constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(threeGLTF, upstreamCorrelatedSceneGraph) {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n  static [$correlateOriginalThreeGLTF](threeGLTF) {\n    const gltf = threeGLTF.parser.json;\n    const associations = threeGLTF.parser.associations;\n    const gltfElementMap = new Map();\n    const defaultMaterial = {\n      name: 'Default'\n    };\n    const defaultReference = {\n      type: 'materials',\n      index: -1\n    };\n    for (const threeMaterial of associations.keys()) {\n      // Note: GLTFLoader creates a \"default\" material that has no\n      // corresponding glTF element in the case that no materials are\n      // specified in the source glTF. In this case we append a default\n      // material to allow this to be operated upon.\n      if (threeMaterial instanceof Material && associations.get(threeMaterial) == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n        threeMaterial.name = defaultMaterial.name;\n        associations.set(threeMaterial, {\n          materials: defaultReference.index\n        });\n      }\n    }\n    // Creates a reverse look up map (gltf-object to Three-object)\n    for (const [threeObject, gltfMappings] of associations) {\n      if (gltfMappings) {\n        const objWithUserData = threeObject;\n        objWithUserData.userData = objWithUserData.userData || {};\n        objWithUserData.userData.associations = gltfMappings;\n      }\n      for (const mapping in gltfMappings) {\n        if (mapping != null && mapping !== 'primitives') {\n          const type = mapping;\n          const elementArray = gltf[type] || [];\n          const gltfElement = elementArray[gltfMappings[type]];\n          if (gltfElement == null) {\n            // TODO: Maybe throw here...\n            continue;\n          }\n          let threeObjects = gltfElementMap.get(gltfElement);\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            gltfElementMap.set(gltfElement, threeObjects);\n          }\n          threeObjects.add(threeObject);\n        }\n      }\n    }\n    return new CorrelatedSceneGraph(threeGLTF, gltf, associations, gltfElementMap);\n  }\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedSceneGraph instance.\n   */\n  static [$correlateCloneThreeGLTF](cloneThreeGLTF, upstreamCorrelatedSceneGraph) {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap = new Map();\n    const cloneGLTFElementMap = new Map();\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](originalThreeGLTF.scenes[i], cloneThreeGLTF.scenes[i], (object, cloneObject) => {\n        const elementReference = upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n        if (elementReference == null) {\n          return;\n        }\n        for (const mapping in elementReference) {\n          if (mapping != null && mapping !== 'primitives') {\n            const type = mapping;\n            const index = elementReference[type];\n            const cloneElement = cloneGLTF[type][index];\n            const mappings = cloneThreeObjectMap.get(cloneObject) || {};\n            mappings[type] = index;\n            cloneThreeObjectMap.set(cloneObject, mappings);\n            const cloneObjects = cloneGLTFElementMap.get(cloneElement) || new Set();\n            cloneObjects.add(cloneObject);\n            cloneGLTFElementMap.set(cloneElement, cloneObjects);\n          }\n        }\n      });\n    }\n    return new CorrelatedSceneGraph(cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);\n  }\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a\n   * callback for each Object3D or Material encountered, including the initial\n   * scene. Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  static [$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {\n    const traverse = (a, b) => {\n      callback(a, b);\n      if (a.isObject3D) {\n        const meshA = a;\n        const meshB = b;\n        if (meshA.material) {\n          if (Array.isArray(meshA.material)) {\n            for (let i = 0; i < meshA.material.length; ++i) {\n              callback(meshA.material[i], meshB.material[i]);\n            }\n          } else {\n            callback(meshA.material, meshB.material);\n          }\n        }\n        for (let i = 0; i < a.children.length; ++i) {\n          traverse(a.children[i], b.children[i]);\n        }\n      }\n    };\n    traverse(sceneOne, sceneTwo);\n  }\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF() {\n    return this[$threeGLTF];\n  }\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf() {\n    return this[$gltf];\n  }\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap() {\n    return this[$gltfElementMap];\n  }\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap() {\n    return this[$threeObjectMap];\n  }\n}","map":{"version":3,"names":["Material","$threeGLTF","Symbol","$gltf","$gltfElementMap","$threeObjectMap","$parallelTraverseThreeScene","$correlateOriginalThreeGLTF","$correlateCloneThreeGLTF","CorrelatedSceneGraph","constructor","threeGLTF","gltf","threeObjectMap","gltfElementMap","from","upstreamCorrelatedSceneGraph","parser","json","associations","Map","defaultMaterial","name","defaultReference","type","index","threeMaterial","keys","get","materials","length","push","set","threeObject","gltfMappings","objWithUserData","userData","mapping","elementArray","gltfElement","threeObjects","Set","add","cloneThreeGLTF","originalThreeGLTF","originalGLTF","cloneGLTF","JSON","parse","stringify","cloneThreeObjectMap","cloneGLTFElementMap","i","scenes","object","cloneObject","elementReference","cloneElement","mappings","cloneObjects","sceneOne","sceneTwo","callback","traverse","a","b","isObject3D","meshA","meshB","material","Array","isArray","children"],"sources":["../../../src/three-components/gltf-instance/correlated-scene-graph.ts"],"sourcesContent":["import {Group, Material, Mesh, Object3D, Texture} from 'three';\nimport {GLTF as ThreeGLTF, GLTFReference, GLTFReferenceType} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {GLTF, GLTFElement} from '../../three-components/gltf-instance/gltf-2.0.js';\n\n\n\nexport type ThreeSceneObject = Object3D|Material|Texture;\ntype ThreeSceneObjectCallback = (a: ThreeSceneObject, b: ThreeSceneObject) =>\n    void;\n\nexport type ThreeObjectSet = Set<ThreeSceneObject>;\n\nexport type GLTFElementToThreeObjectMap = Map<GLTFElement, ThreeObjectSet>;\nexport type ThreeObjectToGLTFElementHandleMap =\n    Map<ThreeSceneObject, GLTFReference>;\n\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\n\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nexport class CorrelatedSceneGraph {\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(\n      threeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph?: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](\n          threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n\n  private static[$correlateOriginalThreeGLTF](threeGLTF: ThreeGLTF):\n      CorrelatedSceneGraph {\n    const gltf = threeGLTF.parser.json as GLTF;\n\n    const associations =\n        threeGLTF.parser.associations as Map<ThreeSceneObject, GLTFReference>;\n    const gltfElementMap: GLTFElementToThreeObjectMap = new Map();\n\n    const defaultMaterial = {name: 'Default'} as Material;\n    const defaultReference = {type: 'materials', index: -1};\n\n    for (const threeMaterial of associations.keys()) {\n      // Note: GLTFLoader creates a \"default\" material that has no\n      // corresponding glTF element in the case that no materials are\n      // specified in the source glTF. In this case we append a default\n      // material to allow this to be operated upon.\n      if (threeMaterial instanceof Material &&\n          associations.get(threeMaterial) == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n\n        threeMaterial.name = defaultMaterial.name;\n        associations.set(threeMaterial, {materials: defaultReference.index});\n      }\n    }\n\n    // Creates a reverse look up map (gltf-object to Three-object)\n    for (const [threeObject, gltfMappings] of associations) {\n      if (gltfMappings) {\n        const objWithUserData = threeObject as {userData: {associations: {}}};\n        objWithUserData.userData = objWithUserData.userData || {};\n        objWithUserData.userData.associations = gltfMappings;\n      }\n\n      for (const mapping in gltfMappings) {\n        if (mapping != null && mapping !== 'primitives') {\n          const type = mapping as GLTFReferenceType;\n          const elementArray = gltf[type] || [];\n          const gltfElement = elementArray[gltfMappings[type]!];\n          if (gltfElement == null) {\n            // TODO: Maybe throw here...\n            continue;\n          }\n\n          let threeObjects = gltfElementMap.get(gltfElement);\n\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            gltfElementMap.set(gltfElement, threeObjects);\n          }\n\n          threeObjects.add(threeObject);\n        }\n      }\n    }\n\n    return new CorrelatedSceneGraph(\n        threeGLTF, gltf, associations, gltfElementMap);\n  }\n\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedSceneGraph instance.\n   */\n  private static[$correlateCloneThreeGLTF](\n      cloneThreeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF: GLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap: ThreeObjectToGLTFElementHandleMap = new Map();\n    const cloneGLTFElementMap: GLTFElementToThreeObjectMap = new Map();\n\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](\n          originalThreeGLTF.scenes[i],\n          cloneThreeGLTF.scenes[i],\n          (object: ThreeSceneObject, cloneObject: ThreeSceneObject) => {\n            const elementReference =\n                upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n\n            if (elementReference == null) {\n              return;\n            }\n\n            for (const mapping in elementReference) {\n              if (mapping != null && mapping !== 'primitives') {\n                const type = mapping as GLTFReferenceType;\n                const index = elementReference[type]!;\n                const cloneElement = cloneGLTF[type]![index];\n\n                const mappings =\n                    cloneThreeObjectMap.get(cloneObject) || {} as GLTFReference;\n                mappings[type] = index;\n                cloneThreeObjectMap.set(cloneObject, mappings);\n\n                const cloneObjects: Set<typeof cloneObject> =\n                    cloneGLTFElementMap.get(cloneElement) || new Set();\n                cloneObjects.add(cloneObject);\n\n                cloneGLTFElementMap.set(cloneElement, cloneObjects);\n              }\n            }\n          });\n    }\n\n    return new CorrelatedSceneGraph(\n        cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);\n  }\n\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a\n   * callback for each Object3D or Material encountered, including the initial\n   * scene. Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  private static[$parallelTraverseThreeScene](\n      sceneOne: Group, sceneTwo: Group, callback: ThreeSceneObjectCallback) {\n    const traverse = (a: Object3D, b: Object3D) => {\n      callback(a, b);\n\n      if (a.isObject3D) {\n        const meshA = a as Mesh;\n        const meshB = b as Mesh;\n        if (meshA.material) {\n          if (Array.isArray(meshA.material)) {\n            for (let i = 0; i < meshA.material.length; ++i) {\n              callback(meshA.material[i], (meshB.material as Material[])[i]);\n            }\n          } else {\n            callback(meshA.material, meshB.material as Material);\n          }\n        }\n\n        for (let i = 0; i < a.children.length; ++i) {\n          traverse(a.children[i], b.children[i]);\n        }\n      }\n    };\n\n    traverse(sceneOne, sceneTwo);\n  }\n\n  private[$threeGLTF]: ThreeGLTF;\n  private[$gltf]: GLTF;\n  private[$gltfElementMap]: GLTFElementToThreeObjectMap;\n  private[$threeObjectMap]: ThreeObjectToGLTFElementHandleMap;\n\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF(): ThreeGLTF {\n    return this[$threeGLTF];\n  }\n\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf(): GLTF {\n    return this[$gltf];\n  }\n\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap(): GLTFElementToThreeObjectMap {\n    return this[$gltfElementMap];\n  }\n\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap(): ThreeObjectToGLTFElementHandleMap {\n    return this[$threeObjectMap];\n  }\n\n  constructor(\n      threeGLTF: ThreeGLTF, gltf: GLTF,\n      threeObjectMap: ThreeObjectToGLTFElementHandleMap,\n      gltfElementMap: GLTFElementToThreeObjectMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}