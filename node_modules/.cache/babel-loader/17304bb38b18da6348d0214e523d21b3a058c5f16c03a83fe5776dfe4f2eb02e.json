{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ClampToEdgeWrapping, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, RepeatWrapping, Vector2 } from 'three';\nimport { toVector2D } from '../../model-viewer-base.js';\nimport { Filter, Wrap } from '../../three-components/gltf-instance/gltf-2.0.js';\nimport { $correlatedObjects, $onUpdate, ThreeDOMElement } from './three-dom-element.js';\n// Convertion between gltf standards and threejs standards.\nconst wrapModeToWrapping = new Map([[Wrap.Repeat, RepeatWrapping], [Wrap.ClampToEdge, ClampToEdgeWrapping], [Wrap.MirroredRepeat, MirroredRepeatWrapping]]);\nconst wrappingToWrapMode = new Map([[RepeatWrapping, Wrap.Repeat], [ClampToEdgeWrapping, Wrap.ClampToEdge], [MirroredRepeatWrapping, Wrap.MirroredRepeat]]);\nconst minFilterToMinification = new Map([[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter], [Filter.NearestMipmapNearest, NearestMipmapNearestFilter], [Filter.LinearMipmapNearest, LinearMipmapNearestFilter], [Filter.NearestMipmapLinear, NearestMipmapLinearFilter], [Filter.LinearMipmapLinear, LinearMipmapLinearFilter]]);\nconst minificationToMinFilter = new Map([[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear], [NearestMipmapNearestFilter, Filter.NearestMipmapNearest], [LinearMipmapNearestFilter, Filter.LinearMipmapNearest], [NearestMipmapLinearFilter, Filter.NearestMipmapLinear], [LinearMipmapLinearFilter, Filter.LinearMipmapLinear]]);\nconst magFilterToMagnification = new Map([[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter]]);\nconst magnificationToMagFilter = new Map([[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear]]);\n// Checks for threejs standards.\nconst isMinFilter = (() => {\n  return value => minificationToMinFilter.has(value);\n})();\nconst isMagFilter = (() => {\n  return value => magnificationToMagFilter.has(value);\n})();\nconst isWrapping = (() => {\n  return value => wrappingToWrapMode.has(value);\n})();\nconst isValidSamplerValue = (property, value) => {\n  switch (property) {\n    case 'minFilter':\n      return isMinFilter(value);\n    case 'magFilter':\n      return isMagFilter(value);\n    case 'wrapS':\n    case 'wrapT':\n      return isWrapping(value);\n    case 'rotation':\n    case 'repeat':\n    case 'offset':\n      return true;\n    default:\n      throw new Error(`Cannot configure property \"${property}\" on Sampler`);\n  }\n};\nconst $threeTexture = Symbol('threeTexture');\nconst $threeTextures = Symbol('threeTextures');\nconst $setProperty = Symbol('setProperty');\n/**\n * Sampler facade implementation for Three.js textures\n */\nexport class Sampler extends ThreeDOMElement {\n  get [$threeTexture]() {\n    var _a;\n    return (_a = this[$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;\n  }\n  get [$threeTextures]() {\n    return this[$correlatedObjects];\n  }\n  constructor(onUpdate, texture) {\n    super(onUpdate, new Set(texture ? [texture] : []));\n  }\n  get name() {\n    return this[$threeTexture].name || '';\n  }\n  get minFilter() {\n    return minificationToMinFilter.get(this[$threeTexture].minFilter);\n  }\n  get magFilter() {\n    return magnificationToMagFilter.get(this[$threeTexture].magFilter);\n  }\n  get wrapS() {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapS);\n  }\n  get wrapT() {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapT);\n  }\n  get rotation() {\n    return this[$threeTexture].rotation;\n  }\n  get scale() {\n    return toVector2D(this[$threeTexture].repeat);\n  }\n  get offset() {\n    return toVector2D(this[$threeTexture].offset);\n  }\n  setMinFilter(filter) {\n    this[$setProperty]('minFilter', minFilterToMinification.get(filter));\n  }\n  setMagFilter(filter) {\n    this[$setProperty]('magFilter', magFilterToMagnification.get(filter));\n  }\n  setWrapS(mode) {\n    this[$setProperty]('wrapS', wrapModeToWrapping.get(mode));\n  }\n  setWrapT(mode) {\n    this[$setProperty]('wrapT', wrapModeToWrapping.get(mode));\n  }\n  setRotation(rotation) {\n    if (rotation == null) {\n      // Reset rotation.\n      rotation = 0;\n    }\n    this[$setProperty]('rotation', rotation);\n  }\n  setScale(scale) {\n    if (scale == null) {\n      // Reset scale.\n      scale = {\n        u: 1,\n        v: 1\n      };\n    }\n    this[$setProperty]('repeat', new Vector2(scale.u, scale.v));\n  }\n  setOffset(offset) {\n    if (offset == null) {\n      // Reset offset.\n      offset = {\n        u: 0,\n        v: 0\n      };\n    }\n    this[$setProperty]('offset', new Vector2(offset.u, offset.v));\n  }\n  [$setProperty](property, value) {\n    if (isValidSamplerValue(property, value)) {\n      for (const texture of this[$threeTextures]) {\n        texture[property] = value;\n        texture.needsUpdate = true;\n      }\n    }\n    this[$onUpdate]();\n  }\n}","map":{"version":3,"names":["ClampToEdgeWrapping","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","RepeatWrapping","Vector2","toVector2D","Filter","Wrap","$correlatedObjects","$onUpdate","ThreeDOMElement","wrapModeToWrapping","Map","Repeat","ClampToEdge","MirroredRepeat","wrappingToWrapMode","minFilterToMinification","Nearest","Linear","NearestMipmapNearest","LinearMipmapNearest","NearestMipmapLinear","LinearMipmapLinear","minificationToMinFilter","magFilterToMagnification","magnificationToMagFilter","isMinFilter","value","has","isMagFilter","isWrapping","isValidSamplerValue","property","Error","$threeTexture","Symbol","$threeTextures","$setProperty","Sampler","_a","values","next","constructor","onUpdate","texture","Set","name","minFilter","get","magFilter","wrapS","wrapT","rotation","scale","repeat","offset","setMinFilter","filter","setMagFilter","setWrapS","mode","setWrapT","setRotation","setScale","u","v","setOffset","needsUpdate"],"sources":["../../../src/features/scene-graph/sampler.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ClampToEdgeWrapping, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MagnificationTextureFilter, MinificationTextureFilter, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, RepeatWrapping, Texture as ThreeTexture, Vector2, Wrapping} from 'three';\n\nimport {toVector2D, Vector2D} from '../../model-viewer-base.js';\nimport {Filter, MagFilter, MinFilter, Wrap, WrapMode} from '../../three-components/gltf-instance/gltf-2.0.js';\nimport {Sampler as DefaultedSampler} from '../../three-components/gltf-instance/gltf-defaulted.js';\n\nimport {Sampler as SamplerInterface, Vector2DInterface} from './api.js';\nimport {$correlatedObjects, $onUpdate, ThreeDOMElement} from './three-dom-element.js';\n\n// Convertion between gltf standards and threejs standards.\nconst wrapModeToWrapping = new Map<WrapMode, Wrapping>([\n  [Wrap.Repeat, RepeatWrapping],\n  [Wrap.ClampToEdge, ClampToEdgeWrapping],\n  [Wrap.MirroredRepeat, MirroredRepeatWrapping]\n]);\nconst wrappingToWrapMode = new Map<Wrapping, WrapMode>([\n  [RepeatWrapping, Wrap.Repeat],\n  [ClampToEdgeWrapping, Wrap.ClampToEdge],\n  [MirroredRepeatWrapping, Wrap.MirroredRepeat]\n]);\nconst minFilterToMinification = new Map<MinFilter, MinificationTextureFilter>([\n  [Filter.Nearest, NearestFilter],\n  [Filter.Linear, LinearFilter],\n  [Filter.NearestMipmapNearest, NearestMipmapNearestFilter],\n  [Filter.LinearMipmapNearest, LinearMipmapNearestFilter],\n  [Filter.NearestMipmapLinear, NearestMipmapLinearFilter],\n  [Filter.LinearMipmapLinear, LinearMipmapLinearFilter]\n]);\nconst minificationToMinFilter = new Map<MinificationTextureFilter, MinFilter>([\n  [NearestFilter, Filter.Nearest],\n  [LinearFilter, Filter.Linear],\n  [NearestMipmapNearestFilter, Filter.NearestMipmapNearest],\n  [LinearMipmapNearestFilter, Filter.LinearMipmapNearest],\n  [NearestMipmapLinearFilter, Filter.NearestMipmapLinear],\n  [LinearMipmapLinearFilter, Filter.LinearMipmapLinear]\n]);\nconst magFilterToMagnification = new Map<MagFilter, MagnificationTextureFilter>(\n    [[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter]]);\nconst magnificationToMagFilter = new Map<MagnificationTextureFilter, MagFilter>(\n    [[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear]]);\n\n// Checks for threejs standards.\nconst isMinFilter = (() => {\n  return (value: unknown): value is MinificationTextureFilter =>\n             minificationToMinFilter.has(value as MinificationTextureFilter);\n})();\n\nconst isMagFilter = (() => {\n  return (value: unknown): value is MagnificationTextureFilter =>\n             magnificationToMagFilter.has(value as MagnificationTextureFilter);\n})();\n\nconst isWrapping = (() => {\n  return (value: unknown): value is Wrapping =>\n             wrappingToWrapMode.has(value as Wrapping);\n})();\n\nconst isValidSamplerValue =\n    <P extends 'minFilter'|'magFilter'|'wrapS'|'wrapT'|'rotation'|'repeat'|\n     'offset'>(property: P, value: unknown): value is DefaultedSampler[P] => {\n      switch (property) {\n        case 'minFilter':\n          return isMinFilter(value);\n        case 'magFilter':\n          return isMagFilter(value);\n        case 'wrapS':\n        case 'wrapT':\n          return isWrapping(value);\n        case 'rotation':\n        case 'repeat':\n        case 'offset':\n          return true;\n        default:\n          throw new Error(`Cannot configure property \"${property}\" on Sampler`);\n      }\n    };\n\nconst $threeTexture = Symbol('threeTexture');\nconst $threeTextures = Symbol('threeTextures');\nconst $setProperty = Symbol('setProperty');\n\n/**\n * Sampler facade implementation for Three.js textures\n */\nexport class Sampler extends ThreeDOMElement implements SamplerInterface {\n  private get[$threeTexture]() {\n    return this[$correlatedObjects]?.values().next().value as ThreeTexture;\n  }\n\n  private get[$threeTextures]() {\n    return this[$correlatedObjects] as Set<ThreeTexture>;\n  }\n\n  constructor(onUpdate: () => void, texture: ThreeTexture) {\n    super(onUpdate, new Set<ThreeTexture>(texture ? [texture] : []));\n  }\n\n  get name(): string {\n    return this[$threeTexture].name || '';\n  }\n\n  get minFilter(): MinFilter {\n    return minificationToMinFilter.get(this[$threeTexture].minFilter)!;\n  }\n\n  get magFilter(): MagFilter {\n    return magnificationToMagFilter.get(this[$threeTexture].magFilter)!;\n  }\n\n  get wrapS(): WrapMode {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapS)!;\n  }\n\n  get wrapT(): WrapMode {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapT)!;\n  }\n\n  get rotation(): number {\n    return this[$threeTexture].rotation;\n  }\n\n  get scale(): Vector2D {\n    return toVector2D(this[$threeTexture].repeat);\n  }\n\n  get offset(): Vector2D|null {\n    return toVector2D(this[$threeTexture].offset);\n  }\n\n  setMinFilter(filter: MinFilter) {\n    this[$setProperty]('minFilter', minFilterToMinification.get(filter)!);\n  }\n\n  setMagFilter(filter: MagFilter) {\n    this[$setProperty]('magFilter', magFilterToMagnification.get(filter)!);\n  }\n\n  setWrapS(mode: WrapMode) {\n    this[$setProperty]('wrapS', wrapModeToWrapping.get(mode)!);\n  }\n\n  setWrapT(mode: WrapMode) {\n    this[$setProperty]('wrapT', wrapModeToWrapping.get(mode)!);\n  }\n\n  setRotation(rotation: number|null): void {\n    if (rotation == null) {\n      // Reset rotation.\n      rotation = 0;\n    }\n    this[$setProperty]('rotation', rotation);\n  }\n\n  setScale(scale: Vector2DInterface|null): void {\n    if (scale == null) {\n      // Reset scale.\n      scale = {u: 1, v: 1};\n    }\n    this[$setProperty]('repeat', new Vector2(scale.u, scale.v));\n  }\n\n  setOffset(offset: Vector2DInterface|null): void {\n    if (offset == null) {\n      // Reset offset.\n      offset = {u: 0, v: 0};\n    }\n    this[$setProperty]('offset', new Vector2(offset.u, offset.v));\n  }\n\n  private[$setProperty]<P extends 'minFilter'|'magFilter'|'wrapS'|'wrapT'|\n                        'rotation'|'repeat'|'offset'>(\n      property: P, value: MinFilter|MagFilter|Wrapping|number|Vector2) {\n    if (isValidSamplerValue(property, value)) {\n      for (const texture of this[$threeTextures]) {\n        (texture[property] as MinFilter | MagFilter | Wrapping | number |\n         Vector2) = value;\n        texture.needsUpdate = true;\n      }\n    }\n    this[$onUpdate]();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}