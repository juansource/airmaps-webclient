{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\nconst compatibleObject = object => {\n  // @TODO: Need properer variantMaterials format validation?\n  return object.material !== undefined &&\n  // easier than (!object.isMesh && !object.isLine &&\n  // !object.isPoints)\n  object.userData &&\n  // just in case\n  object.userData.variantMaterials &&\n  // Is this line costly?\n  !!Array.from(object.userData.variantMaterials.values()).filter(m => compatibleMaterial(m.material));\n};\n/**\n * @param material {THREE.Material}\n * @return {boolean}\n */\nconst compatibleMaterial = material => {\n  // @TODO: support multi materials?\n  return material && material.isMaterial && !Array.isArray(material);\n};\nexport default class GLTFExporterMaterialsVariantsExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_variants';\n    this.variantNames = [];\n  }\n  beforeParse(objects) {\n    // Find all variant names and store them to the table\n    const variantNameSet = new Set();\n    for (const object of objects) {\n      object.traverse(o => {\n        if (!compatibleObject(o)) {\n          return;\n        }\n        const variantMaterials = o.userData.variantMaterials;\n        const variantDataMap = o.userData.variantData;\n        for (const [variantName, variantData] of variantDataMap) {\n          const variantMaterial = variantMaterials.get(variantData.index);\n          // Ignore unloaded variant materials\n          if (variantMaterial && compatibleMaterial(variantMaterial.material)) {\n            variantNameSet.add(variantName);\n          }\n        }\n      });\n    }\n    // We may want to sort?\n    variantNameSet.forEach(name => this.variantNames.push(name));\n  }\n  writeMesh(mesh, meshDef) {\n    if (!compatibleObject(mesh)) {\n      return;\n    }\n    const userData = mesh.userData;\n    const variantMaterials = userData.variantMaterials;\n    const variantDataMap = userData.variantData;\n    const mappingTable = new Map();\n    // Removes gaps in the variant indices list (caused by deleting variants).\n    const reIndexedVariants = new Map();\n    const variants = Array.from(variantDataMap.values()).sort((a, b) => {\n      return a.index - b.index;\n    });\n    for (const [i, variantData] of variants.entries()) {\n      reIndexedVariants.set(variantData.index, i);\n    }\n    for (const variantData of variantDataMap.values()) {\n      const variantInstance = variantMaterials.get(variantData.index);\n      if (!variantInstance || !compatibleMaterial(variantInstance.material)) {\n        continue;\n      }\n      const materialIndex = this.writer.processMaterial(variantInstance.material);\n      if (!mappingTable.has(materialIndex)) {\n        mappingTable.set(materialIndex, {\n          material: materialIndex,\n          variants: []\n        });\n      }\n      mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index));\n    }\n    const mappingsDef = Array.from(mappingTable.values()).map(m => {\n      return m.variants.sort((a, b) => a - b) && m;\n    }).sort((a, b) => a.material - b.material);\n    if (mappingsDef.length === 0) {\n      return;\n    }\n    const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ? this.writer.processMaterial(userData.originalMaterial) : -1;\n    for (const primitiveDef of meshDef.primitives) {\n      // Override primitiveDef.material with original material.\n      if (originalMaterialIndex >= 0) {\n        primitiveDef.material = originalMaterialIndex;\n      }\n      primitiveDef.extensions = primitiveDef.extensions || {};\n      primitiveDef.extensions[this.name] = {\n        mappings: mappingsDef\n      };\n    }\n  }\n  afterParse() {\n    if (this.variantNames.length === 0) {\n      return;\n    }\n    const root = this.writer.json;\n    root.extensions = root.extensions || {};\n    const variantsDef = this.variantNames.map(n => {\n      return {\n        name: n\n      };\n    });\n    root.extensions[this.name] = {\n      variants: variantsDef\n    };\n    this.writer.extensionsUsed[this.name] = true;\n  }\n}","map":{"version":3,"names":["compatibleObject","object","material","undefined","userData","variantMaterials","Array","from","values","filter","m","compatibleMaterial","isMaterial","isArray","GLTFExporterMaterialsVariantsExtension","constructor","writer","name","variantNames","beforeParse","objects","variantNameSet","Set","traverse","o","variantDataMap","variantData","variantName","variantMaterial","get","index","add","forEach","push","writeMesh","mesh","meshDef","mappingTable","Map","reIndexedVariants","variants","sort","a","b","i","entries","set","variantInstance","materialIndex","processMaterial","has","mappingsDef","map","length","originalMaterialIndex","originalMaterial","primitiveDef","primitives","extensions","mappings","afterParse","root","json","variantsDef","n","extensionsUsed"],"sources":["../../../src/three-components/gltf-instance/VariantMaterialExporterPlugin.ts"],"sourcesContent":["/* @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the 'License');\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an 'AS IS' BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * Materials variants extension\r\n *\r\n * Specification:\r\n * https://github.com/takahirox/three-gltf-extensions/tree/main/loaders/KHR_materials_variants\r\n */\r\n\r\n/**\r\n * The code in this file is based on\r\n * https://github.com/takahirox/three-gltf-extensions/tree/main/exporters/KHR_materials_variants\r\n */\r\n\r\nimport {Material, Mesh, Object3D} from 'three';\r\n\r\nimport {VariantData} from '../../features/scene-graph/model';\r\n\r\nimport {UserDataVariantMapping} from './VariantMaterialLoaderPlugin';\r\n\r\n\r\n\r\n/**\r\n * @param object {THREE.Object3D}\r\n * @return {boolean}\r\n */\r\nconst compatibleObject = (object: Object3D) => {\r\n  // @TODO: Need properer variantMaterials format validation?\r\n  return (object as Mesh).material !==\r\n      undefined &&        // easier than (!object.isMesh && !object.isLine &&\r\n                          // !object.isPoints)\r\n      object.userData &&  // just in case\r\n      object.userData.variantMaterials &&\r\n      // Is this line costly?\r\n      !!Array\r\n            .from((object.userData.variantMaterials as\r\n                   Map<number, UserDataVariantMapping>)\r\n                      .values())\r\n            .filter(m => compatibleMaterial(m.material));\r\n};\r\n\r\n/**\r\n * @param material {THREE.Material}\r\n * @return {boolean}\r\n */\r\nconst compatibleMaterial = (material: Material|null) => {\r\n  // @TODO: support multi materials?\r\n  return material && material.isMaterial && !Array.isArray(material);\r\n};\r\n\r\nexport default class GLTFExporterMaterialsVariantsExtension {\r\n  writer: any;  // @TODO: Replace with GLTFWriter when GLTFExporter plugin TS\r\n                // declaration is ready\r\n  name: string;\r\n  variantNames: string[];\r\n\r\n  constructor(writer: any) {\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_variants';\r\n    this.variantNames = [];\r\n  }\r\n\r\n  beforeParse(objects: Object3D[]) {\r\n    // Find all variant names and store them to the table\r\n    const variantNameSet = new Set<string>();\r\n    for (const object of objects) {\r\n      object.traverse(o => {\r\n        if (!compatibleObject(o)) {\r\n          return;\r\n        }\r\n        const variantMaterials =\r\n            o.userData.variantMaterials as Map<number, UserDataVariantMapping>;\r\n        const variantDataMap =\r\n            o.userData.variantData as Map<string, VariantData>;\r\n        for (const [variantName, variantData] of variantDataMap) {\r\n          const variantMaterial = variantMaterials.get(variantData.index);\r\n          // Ignore unloaded variant materials\r\n          if (variantMaterial && compatibleMaterial(variantMaterial.material)) {\r\n            variantNameSet.add(variantName);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // We may want to sort?\r\n    variantNameSet.forEach(name => this.variantNames.push(name));\r\n  }\r\n\r\n  writeMesh(mesh: Mesh, meshDef: any) {\r\n    if (!compatibleObject(mesh)) {\r\n      return;\r\n    }\r\n\r\n    const userData = mesh.userData;\r\n    const variantMaterials =\r\n        userData.variantMaterials as Map<number, UserDataVariantMapping>;\r\n    const variantDataMap = userData.variantData as Map<string, VariantData>;\r\n    const mappingTableã€€=\r\n        new Map<number, {material: number, variants: number[]}>();\r\n\r\n    // Removes gaps in the variant indices list (caused by deleting variants).\r\n    const reIndexedVariants = new Map<number, number>();\r\n    const variants = Array.from(variantDataMap.values()).sort((a, b) => {\r\n      return a.index - b.index;\r\n    });\r\n    for (const [i, variantData] of variants.entries()) {\r\n      reIndexedVariants.set(variantData.index, i);\r\n    }\r\n\r\n    for (const variantData of variantDataMap.values()) {\r\n      const variantInstance = variantMaterials.get(variantData.index);\r\n      if (!variantInstance || !compatibleMaterial(variantInstance.material)) {\r\n        continue;\r\n      }\r\n\r\n      const materialIndex =\r\n          this.writer.processMaterial(variantInstance.material);\r\n      if (!mappingTable.has(materialIndex)) {\r\n        mappingTable.set(\r\n            materialIndex, {material: materialIndex, variants: []});\r\n      }\r\n      mappingTable.get(materialIndex)!.variants.push(\r\n          reIndexedVariants.get(variantData.index)!);\r\n    }\r\n\r\n    const mappingsDef =\r\n        Array.from(mappingTable.values())\r\n            .map((m => {return m.variants.sort((a, b) => a - b) && m}))\r\n            .sort((a, b) => a.material - b.material);\r\n\r\n    if (mappingsDef.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const originalMaterialIndex =\r\n        compatibleMaterial(userData.originalMaterial) ?\r\n        this.writer.processMaterial(userData.originalMaterial) :\r\n        -1;\r\n\r\n    for (const primitiveDef of meshDef.primitives) {\r\n      // Override primitiveDef.material with original material.\r\n      if (originalMaterialIndex >= 0) {\r\n        primitiveDef.material = originalMaterialIndex;\r\n      }\r\n      primitiveDef.extensions = primitiveDef.extensions || {};\r\n      primitiveDef.extensions[this.name] = {mappings: mappingsDef};\r\n    }\r\n  }\r\n\r\n  afterParse() {\r\n    if (this.variantNames.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const root = this.writer.json;\r\n    root.extensions = root.extensions || {};\r\n\r\n    const variantsDef = this.variantNames.map(n => {\r\n      return {name: n};\r\n    });\r\n    root.extensions[this.name] = {variants: variantsDef};\r\n    this.writer.extensionsUsed[this.name] = true;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}