{"ast":null,"code":"import { $getLoadedMaterial, $variantIndices } from '../material.js';\nimport { $correlatedObjects } from '../three-dom-element.js';\n// Defines the base level node methods and data.\nexport class Node {\n  constructor(name) {\n    this.name = '';\n    this.children = new Array();\n    this.name = name;\n  }\n}\n// Represents a primitive in a glTF mesh.\nexport class PrimitiveNode extends Node {\n  constructor(mesh, mvMaterials, modelVariants, correlatedSceneGraph) {\n    super(mesh.name);\n    // Maps glTF material index number to a material that this primitive supports.\n    this.materials = new Map();\n    // Maps variant index to material.\n    this.variantToMaterialMap = new Map();\n    this.initialMaterialIdx = 0;\n    this.activeMaterialIdx = 0;\n    this.mesh = mesh;\n    const {\n      gltf,\n      threeGLTF,\n      threeObjectMap\n    } = correlatedSceneGraph;\n    this.parser = threeGLTF.parser;\n    this.modelVariants = modelVariants;\n    this.mesh.userData.variantData = modelVariants;\n    // Captures the primitive's initial material.\n    const materialMappings = threeObjectMap.get(mesh.material);\n    if (materialMappings.materials != null) {\n      this.initialMaterialIdx = this.activeMaterialIdx = materialMappings.materials;\n    } else {\n      console.error(`Primitive (${mesh.name}) missing initial material reference.`);\n    }\n    // Gets the mesh index from the node.\n    const associations = mesh.userData.associations || {};\n    if (associations.meshes == null) {\n      console.error('Mesh is missing primitive index association');\n      return;\n    }\n    // The gltf mesh array to sample from.\n    const meshElementArray = gltf['meshes'] || [];\n    // List of primitives under the mesh.\n    const gltfPrimitives = meshElementArray[associations.meshes].primitives || [];\n    const gltfPrimitive = gltfPrimitives[associations.primitives];\n    if (gltfPrimitive == null) {\n      console.error('Mesh primitive definition is missing.');\n      return;\n    }\n    // Maps the gltfPrimitive default to a material.\n    if (gltfPrimitive.material != null) {\n      this.materials.set(gltfPrimitive.material, mvMaterials[gltfPrimitive.material]);\n    } else {\n      const defaultIdx = mvMaterials.findIndex(mat => {\n        return mat.name === 'Default';\n      });\n      if (defaultIdx >= 0) {\n        this.materials.set(defaultIdx, mvMaterials[defaultIdx]);\n      } else {\n        console.warn('gltfPrimitive has no material!');\n      }\n    }\n    if (gltfPrimitive.extensions && gltfPrimitive.extensions['KHR_materials_variants']) {\n      const variantsExtension = gltfPrimitive.extensions['KHR_materials_variants'];\n      const extensions = threeGLTF.parser.json.extensions;\n      const variantNames = extensions['KHR_materials_variants'].variants;\n      // Provides definition now that we know there are variants to\n      // support.\n      for (const mapping of variantsExtension.mappings) {\n        const mvMaterial = mvMaterials[mapping.material];\n        // Maps variant indices to Materials.\n        this.materials.set(mapping.material, mvMaterial);\n        for (const variant of mapping.variants) {\n          const {\n            name\n          } = variantNames[variant];\n          this.variantToMaterialMap.set(variant, mvMaterial);\n          // Provides variant info for material self lookup.\n          mvMaterial[$variantIndices]().add(variant);\n          // Updates the models variant data.\n          if (!modelVariants.has(name)) {\n            modelVariants.set(name, {\n              name,\n              index: variant\n            });\n          }\n        }\n      }\n    }\n  }\n  async setActiveMaterial(material) {\n    const mvMaterial = this.materials.get(material);\n    if (mvMaterial != null && material !== this.activeMaterialIdx) {\n      this.mesh.material = await mvMaterial[$getLoadedMaterial]();\n      const {\n        normalScale\n      } = this.mesh.material;\n      // TODO: remove this hack in favor of properly storing the different\n      // three.js materials that are potentially created for different meshes\n      // that share a glTF material.\n      if (normalScale != null && normalScale.y * normalScale.x < 0 != (this.mesh.geometry.attributes.tangent == null)) {\n        this.parser.assignFinalMaterial(this.mesh);\n      }\n      this.activeMaterialIdx = material;\n    }\n    return this.mesh.material;\n  }\n  getActiveMaterial() {\n    return this.materials.get(this.activeMaterialIdx);\n  }\n  getMaterial(index) {\n    return this.materials.get(index);\n  }\n  async enableVariant(name) {\n    if (name == null) {\n      return this.setActiveMaterial(this.initialMaterialIdx);\n    }\n    if (this.variantToMaterialMap != null && this.modelVariants.has(name)) {\n      const modelVariants = this.modelVariants.get(name);\n      return this.enableVariantHelper(modelVariants.index);\n    }\n    return null;\n  }\n  async enableVariantHelper(index) {\n    if (this.variantToMaterialMap != null && index != null) {\n      const material = this.variantToMaterialMap.get(index);\n      if (material != null) {\n        return this.setActiveMaterial(material.index);\n      }\n    }\n    return null;\n  }\n  async instantiateVariants() {\n    if (this.variantToMaterialMap == null) {\n      return;\n    }\n    for (const index of this.variantToMaterialMap.keys()) {\n      const variantMaterial = this.mesh.userData.variantMaterials.get(index);\n      if (variantMaterial.material != null) {\n        continue;\n      }\n      const threeMaterial = await this.enableVariantHelper(index);\n      if (threeMaterial != null) {\n        variantMaterial.material = threeMaterial;\n      }\n    }\n  }\n  get variantInfo() {\n    return this.variantToMaterialMap;\n  }\n  addVariant(materialVariant, variantName) {\n    if (!this.ensureVariantIsUnused(variantName)) {\n      return false;\n    }\n    // Adds the variant to the model variants if needed.\n    if (!this.modelVariants.has(variantName)) {\n      this.modelVariants.set(variantName, {\n        name: variantName,\n        index: this.modelVariants.size\n      });\n    }\n    const modelVariantData = this.modelVariants.get(variantName);\n    const variantIndex = modelVariantData.index;\n    // Updates materials mapped to the variant.\n    materialVariant[$variantIndices]().add(variantIndex);\n    // Updates internal mappings.\n    this.variantToMaterialMap.set(variantIndex, materialVariant);\n    this.materials.set(materialVariant.index, materialVariant);\n    this.updateVariantUserData(variantIndex, materialVariant);\n    return true;\n  }\n  deleteVariant(variantIndex) {\n    if (this.variantInfo.has(variantIndex)) {\n      this.variantInfo.delete(variantIndex);\n      const userDataMap = this.mesh.userData.variantMaterials;\n      if (userDataMap != null) {\n        userDataMap.delete(variantIndex);\n      }\n    }\n  }\n  updateVariantUserData(variantIndex, materialVariant) {\n    // Adds variants name to material variants set.\n    materialVariant[$variantIndices]().add(variantIndex);\n    this.mesh.userData.variantData = this.modelVariants;\n    // Updates import data (see VariantMaterialLoaderPlugin.ts).\n    this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map();\n    const map = this.mesh.userData.variantMaterials;\n    map.set(variantIndex, {\n      material: materialVariant[$correlatedObjects].values().next().value,\n      gltfMaterialIndex: materialVariant.index\n    });\n  }\n  ensureVariantIsUnused(variantName) {\n    const modelVariants = this.modelVariants.get(variantName);\n    if (modelVariants != null && this.variantInfo.has(modelVariants.index)) {\n      console.warn(`Primitive cannot add variant '${variantName}' for this material, it already exists.`);\n      return false;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["$getLoadedMaterial","$variantIndices","$correlatedObjects","Node","constructor","name","children","Array","PrimitiveNode","mesh","mvMaterials","modelVariants","correlatedSceneGraph","materials","Map","variantToMaterialMap","initialMaterialIdx","activeMaterialIdx","gltf","threeGLTF","threeObjectMap","parser","userData","variantData","materialMappings","get","material","console","error","associations","meshes","meshElementArray","gltfPrimitives","primitives","gltfPrimitive","set","defaultIdx","findIndex","mat","warn","extensions","variantsExtension","json","variantNames","variants","mapping","mappings","mvMaterial","variant","add","has","index","setActiveMaterial","normalScale","y","x","geometry","attributes","tangent","assignFinalMaterial","getActiveMaterial","getMaterial","enableVariant","enableVariantHelper","instantiateVariants","keys","variantMaterial","variantMaterials","threeMaterial","variantInfo","addVariant","materialVariant","variantName","ensureVariantIsUnused","size","modelVariantData","variantIndex","updateVariantUserData","deleteVariant","delete","userDataMap","map","values","next","value","gltfMaterialIndex"],"sources":["../../../../src/features/scene-graph/nodes/primitive-node.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Material as ThreeMaterial, Mesh, MeshPhysicalMaterial} from 'three';\nimport {GLTFParser, GLTFReference} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {CorrelatedSceneGraph} from '../../../three-components/gltf-instance/correlated-scene-graph.js';\nimport {KHRMaterialsVariants, Primitive} from '../../../three-components/gltf-instance/gltf-2.0.js';\nimport {UserDataVariantMapping} from '../../../three-components/gltf-instance/VariantMaterialLoaderPlugin.js';\nimport {$getLoadedMaterial, $variantIndices, Material} from '../material.js';\nimport {VariantData} from '../model.js';\nimport {$correlatedObjects} from '../three-dom-element.js';\n\n// Defines the base level node methods and data.\nexport class Node {\n  name: string = '';\n  children = new Array<Node>();\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n// Represents a primitive in a glTF mesh.\nexport class PrimitiveNode extends Node {\n  public mesh: Mesh;\n  // Maps glTF material index number to a material that this primitive supports.\n  public materials = new Map<number, Material>();\n  // Maps variant index to material.\n  private variantToMaterialMap = new Map<number, Material>();\n  public initialMaterialIdx = 0;\n  private activeMaterialIdx = 0;\n  private modelVariants: Map<string, VariantData>;\n  private parser: GLTFParser;\n\n  constructor(\n      mesh: Mesh, mvMaterials: Material[],\n      modelVariants: Map<string, VariantData>,\n      correlatedSceneGraph: CorrelatedSceneGraph) {\n    super(mesh.name);\n    this.mesh = mesh;\n    const {gltf, threeGLTF, threeObjectMap} = correlatedSceneGraph;\n    this.parser = threeGLTF.parser;\n    this.modelVariants = modelVariants;\n    this.mesh.userData.variantData = modelVariants;\n    // Captures the primitive's initial material.\n    const materialMappings =\n        threeObjectMap.get(mesh.material as ThreeMaterial)!;\n    if (materialMappings.materials != null) {\n      this.initialMaterialIdx = this.activeMaterialIdx =\n          materialMappings.materials;\n    } else {\n      console.error(\n          `Primitive (${mesh.name}) missing initial material reference.`);\n    }\n\n    // Gets the mesh index from the node.\n    const associations =\n        (mesh.userData.associations as GLTFReference & {primitives: number}) ||\n        {};\n\n    if (associations.meshes == null) {\n      console.error('Mesh is missing primitive index association');\n      return;\n    }\n    // The gltf mesh array to sample from.\n    const meshElementArray = gltf['meshes'] || [];\n    // List of primitives under the mesh.\n    const gltfPrimitives =\n        (meshElementArray[associations.meshes].primitives || []) as Primitive[];\n\n    const gltfPrimitive = gltfPrimitives[associations.primitives];\n    if (gltfPrimitive == null) {\n      console.error('Mesh primitive definition is missing.');\n      return;\n    }\n\n    // Maps the gltfPrimitive default to a material.\n    if (gltfPrimitive.material != null) {\n      this.materials.set(\n          gltfPrimitive.material, mvMaterials[gltfPrimitive.material]);\n    } else {\n      const defaultIdx = mvMaterials.findIndex((mat: Material) => {\n        return mat.name === 'Default';\n      });\n      if (defaultIdx >= 0) {\n        this.materials.set(defaultIdx, mvMaterials[defaultIdx]);\n      } else {\n        console.warn('gltfPrimitive has no material!');\n      }\n    }\n\n    if (gltfPrimitive.extensions &&\n        gltfPrimitive.extensions['KHR_materials_variants']) {\n      const variantsExtension =\n          gltfPrimitive.extensions['KHR_materials_variants'] as\n          KHRMaterialsVariants;\n      const extensions = threeGLTF.parser.json.extensions;\n      const variantNames = extensions['KHR_materials_variants'].variants;\n      // Provides definition now that we know there are variants to\n      // support.\n      for (const mapping of variantsExtension.mappings) {\n        const mvMaterial = mvMaterials[mapping.material];\n        // Maps variant indices to Materials.\n        this.materials.set(mapping.material, mvMaterial);\n        for (const variant of mapping.variants) {\n          const {name} = variantNames[variant];\n          this.variantToMaterialMap.set(variant, mvMaterial);\n          // Provides variant info for material self lookup.\n          mvMaterial[$variantIndices]().add(variant);\n          // Updates the models variant data.\n          if (!modelVariants.has(name)) {\n            modelVariants.set(name, {name, index: variant} as VariantData);\n          }\n        }\n      }\n    }\n  }\n\n  async setActiveMaterial(material: number): Promise<ThreeMaterial|null> {\n    const mvMaterial = this.materials.get(material);\n    if (mvMaterial != null && material !== this.activeMaterialIdx) {\n      this.mesh.material = await mvMaterial[$getLoadedMaterial]();\n      const {normalScale} = this.mesh.material as MeshPhysicalMaterial;\n      // TODO: remove this hack in favor of properly storing the different\n      // three.js materials that are potentially created for different meshes\n      // that share a glTF material.\n      if (normalScale != null &&\n          (normalScale.y * normalScale.x < 0) !=\n              (this.mesh.geometry.attributes.tangent == null)) {\n        this.parser.assignFinalMaterial(this.mesh);\n      }\n      this.activeMaterialIdx = material;\n    }\n    return this.mesh.material as ThreeMaterial;\n  }\n\n  getActiveMaterial(): Material {\n    return this.materials.get(this.activeMaterialIdx)!;\n  }\n\n  getMaterial(index: number): Material|undefined {\n    return this.materials.get(index);\n  }\n\n  async enableVariant(name: string|null): Promise<ThreeMaterial|null> {\n    if (name == null) {\n      return this.setActiveMaterial(this.initialMaterialIdx);\n    }\n    if (this.variantToMaterialMap != null && this.modelVariants.has(name)) {\n      const modelVariants = this.modelVariants.get(name)!;\n      return this.enableVariantHelper(modelVariants.index);\n    }\n    return null;\n  }\n\n  private async enableVariantHelper(index: number|\n                                    null): Promise<ThreeMaterial|null> {\n    if (this.variantToMaterialMap != null && index != null) {\n      const material = this.variantToMaterialMap.get(index);\n      if (material != null) {\n        return this.setActiveMaterial(material.index);\n      }\n    }\n    return null;\n  }\n\n  async instantiateVariants() {\n    if (this.variantToMaterialMap == null) {\n      return;\n    }\n    for (const index of this.variantToMaterialMap.keys()) {\n      const variantMaterial = this.mesh.userData.variantMaterials.get(index) as\n          UserDataVariantMapping;\n      if (variantMaterial.material != null) {\n        continue;\n      }\n      const threeMaterial = await this.enableVariantHelper(index);\n      if (threeMaterial != null) {\n        variantMaterial.material = threeMaterial;\n      }\n    }\n  }\n\n  get variantInfo() {\n    return this.variantToMaterialMap;\n  }\n\n  addVariant(materialVariant: Material, variantName: string) {\n    if (!this.ensureVariantIsUnused(variantName)) {\n      return false;\n    }\n\n    // Adds the variant to the model variants if needed.\n    if (!this.modelVariants.has(variantName)) {\n      this.modelVariants.set(\n          variantName, {name: variantName, index: this.modelVariants.size});\n    }\n    const modelVariantData = this.modelVariants.get(variantName)!;\n    const variantIndex = modelVariantData.index;\n\n    // Updates materials mapped to the variant.\n    materialVariant[$variantIndices]().add(variantIndex);\n\n    // Updates internal mappings.\n    this.variantToMaterialMap.set(variantIndex, materialVariant);\n    this.materials.set(materialVariant.index, materialVariant);\n\n    this.updateVariantUserData(variantIndex, materialVariant);\n\n    return true;\n  }\n\n  deleteVariant(variantIndex: number) {\n    if (this.variantInfo.has(variantIndex)) {\n      this.variantInfo.delete(variantIndex);\n\n      const userDataMap = this.mesh.userData.variantMaterials! as\n          Map<number, UserDataVariantMapping>;\n      if (userDataMap != null) {\n        userDataMap.delete(variantIndex);\n      }\n    }\n  }\n\n  private updateVariantUserData(\n      variantIndex: number, materialVariant: Material) {\n    // Adds variants name to material variants set.\n    materialVariant[$variantIndices]().add(variantIndex);\n\n    this.mesh.userData.variantData = this.modelVariants;\n    // Updates import data (see VariantMaterialLoaderPlugin.ts).\n    this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials ||\n        new Map<number, UserDataVariantMapping>();\n    const map = this.mesh.userData.variantMaterials! as\n        Map<number, UserDataVariantMapping>;\n    map.set(variantIndex, {\n      material: materialVariant[$correlatedObjects]!.values().next().value,\n      gltfMaterialIndex: materialVariant.index,\n    });\n  }\n\n  private ensureVariantIsUnused(variantName: string) {\n    const modelVariants = this.modelVariants.get(variantName);\n\n    if (modelVariants != null && this.variantInfo.has(modelVariants!.index)) {\n      console.warn(`Primitive cannot add variant '${\n          variantName}' for this material, it already exists.`);\n      return false;\n    }\n\n    return true;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}