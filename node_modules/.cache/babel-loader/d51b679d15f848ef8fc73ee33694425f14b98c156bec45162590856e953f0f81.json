{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Texture } from 'three';\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils.js';\nexport const $prepared = Symbol('prepared');\nexport const $prepare = Symbol('prepare');\nexport const $preparedGLTF = Symbol('preparedGLTF');\nexport const $clone = Symbol('clone');\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\nexport class GLTFInstance {\n  constructor(preparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n  static prepare(source) {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n    if (source[$prepared]) {\n      return source;\n    }\n    const prepared = this[$prepare](source);\n    // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n    prepared[$prepared] = true;\n    return prepared;\n  }\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n  static [$prepare](source) {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const {\n      scene\n    } = source;\n    const scenes = [scene];\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes\n    });\n  }\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n  /**\n   * Creates and returns a copy of this instance.\n   */\n  clone() {\n    const GLTFInstanceConstructor = this.constructor;\n    const clonedGLTF = this[$clone]();\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n  dispose() {\n    this.scenes.forEach(scene => {\n      scene.traverse(object => {\n        const mesh = object;\n        if (!mesh.material) {\n          return;\n        }\n        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          // Explicitly dispose any textures assigned to this material\n          for (const propertyName in material) {\n            const texture = material[propertyName];\n            if (texture instanceof Texture) {\n              const image = texture.source.data;\n              if (image.close != null) {\n                image.close();\n              }\n              texture.dispose();\n            }\n          }\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n  [$clone]() {\n    const source = this[$preparedGLTF];\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n    const scene = SkeletonUtils.clone(this.scene);\n    cloneVariantMaterials(scene, this.scene);\n    const scenes = [scene];\n    const userData = source.userData ? Object.assign({}, source.userData) : {};\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes,\n      userData\n    });\n  }\n}\n// Variant materials and original material instances are stored under\n// object.userData.variantMaterials/originalMaterial.\n// Three.js Object3D.clone() doesn't clone Three.js objects under\n// .userData so this function is a workaround.\nconst cloneVariantMaterials = (dst, src) => {\n  traversePair(dst, src, (dst, src) => {\n    if (src.userData.variantMaterials !== undefined) {\n      dst.userData.variantMaterials = new Map(src.userData.variantMaterials);\n    }\n    if (src.userData.variantData !== undefined) {\n      dst.userData.variantData = src.userData.variantData;\n    }\n    if (src.userData.originalMaterial !== undefined) {\n      dst.userData.originalMaterial = src.userData.originalMaterial;\n    }\n  });\n};\nconst traversePair = (obj1, obj2, callback) => {\n  callback(obj1, obj2);\n  // Assume obj1 and obj2 have the same tree structure\n  for (let i = 0; i < obj1.children.length; i++) {\n    traversePair(obj1.children[i], obj2.children[i], callback);\n  }\n};","map":{"version":3,"names":["Texture","SkeletonUtils","$prepared","Symbol","$prepare","$preparedGLTF","$clone","GLTFInstance","constructor","preparedGLTF","prepare","source","scene","Error","prepared","scenes","Object","assign","parser","animations","cameras","asset","userData","clone","GLTFInstanceConstructor","clonedGLTF","dispose","forEach","traverse","object","mesh","material","materials","Array","isArray","propertyName","texture","image","data","close","geometry","cloneVariantMaterials","dst","src","traversePair","variantMaterials","undefined","Map","variantData","originalMaterial","obj1","obj2","callback","i","children","length"],"sources":["../../src/three-components/GLTFInstance.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Group, Mesh, Object3D, Texture} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils.js';\n\nimport {Constructor} from '../utilities.js';\n\n\n\nexport const $prepared = Symbol('prepared');\n\nexport interface PreparedGLTF extends GLTF {\n  [$prepared]?: boolean;\n}\n\nexport const $prepare = Symbol('prepare');\nexport const $preparedGLTF = Symbol('preparedGLTF');\nexport const $clone = Symbol('clone');\n\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\nexport class GLTFInstance implements GLTF {\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n  static prepare(source: GLTF): PreparedGLTF {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n\n    if ((source as PreparedGLTF)[$prepared]) {\n      return source;\n    }\n\n    const prepared = this[$prepare](source) as Partial<PreparedGLTF>;\n\n    // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n    prepared[$prepared] = true;\n\n    return prepared as PreparedGLTF;\n  }\n\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n  protected static[$prepare](source: GLTF): GLTF {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const {scene} = source;\n    const scenes = [scene];\n\n    return {...source, scene, scenes};\n  }\n\n  protected[$preparedGLTF]: PreparedGLTF;\n\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n\n  constructor(preparedGLTF: PreparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n\n  /**\n   * Creates and returns a copy of this instance.\n   */\n  clone<T extends GLTFInstance>(): T {\n    const GLTFInstanceConstructor = this.constructor as Constructor<T>;\n    const clonedGLTF = this[$clone]();\n\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n  dispose(): void {\n    this.scenes.forEach((scene: Group) => {\n      scene.traverse((object: Object3D) => {\n        const mesh = object as Mesh;\n        if (!mesh.material) {\n          return;\n        }\n\n        const materials =\n            Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          // Explicitly dispose any textures assigned to this material\n          for (const propertyName in material) {\n            const texture = (material as any)[propertyName];\n            if (texture instanceof Texture) {\n              const image = texture.source.data;\n              if (image.close != null) {\n                image.close();\n              }\n              texture.dispose();\n            }\n          }\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n  protected[$clone](): PreparedGLTF {\n    const source = this[$preparedGLTF];\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n    const scene = SkeletonUtils.clone(this.scene) as Group;\n    cloneVariantMaterials(scene, this.scene);\n    const scenes = [scene];\n    const userData = source.userData ? {...source.userData} : {};\n    return {...source, scene, scenes, userData};\n  }\n}\n\n// Variant materials and original material instances are stored under\n// object.userData.variantMaterials/originalMaterial.\n// Three.js Object3D.clone() doesn't clone Three.js objects under\n// .userData so this function is a workaround.\nconst cloneVariantMaterials = (dst: Object3D, src: Object3D) => {\n  traversePair(dst, src, (dst, src) => {\n    if (src.userData.variantMaterials !== undefined) {\n      dst.userData.variantMaterials = new Map(src.userData.variantMaterials);\n    }\n    if (src.userData.variantData !== undefined) {\n      dst.userData.variantData = src.userData.variantData;\n    }\n    if (src.userData.originalMaterial !== undefined) {\n      dst.userData.originalMaterial = src.userData.originalMaterial;\n    }\n  });\n};\n\nconst traversePair =\n    (obj1: Object3D,\n     obj2: Object3D,\n     callback: (obj1: Object3D, obj2: Object3D) => void) => {\n      callback(obj1, obj2);\n      // Assume obj1 and obj2 have the same tree structure\n      for (let i = 0; i < obj1.children.length; i++) {\n        traversePair(obj1.children[i], obj2.children[i], callback);\n      }\n    };\n\nexport type GLTFInstanceConstructor =\n    Constructor<GLTFInstance, {prepare: typeof GLTFInstance['prepare']}>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}