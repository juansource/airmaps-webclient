{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ACESFilmicToneMapping, CustomToneMapping, EventDispatcher, ShaderChunk, Vector2, WebGLRenderer } from 'three';\nimport { $updateEnvironment } from '../features/environment.js';\nimport { $canvas, $tick, $updateSize } from '../model-viewer-base.js';\nimport { clamp, isDebugMode, resolveDpr } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport TextureUtils from './TextureUtils.js';\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nexport const DEFAULT_POWER_PREFERENCE = 'high-performance';\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.lastTick = performance.now();\n    this.renderedLastFrame = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    this.onWebGLContextLost = event => {\n      this.dispatchEvent({\n        type: 'contextlost',\n        sourceEvent: event\n      });\n    };\n    this.onWebGLContextRestored = () => {\n      var _a;\n      (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n    };\n    this.dpr = resolveDpr();\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n    // Emmett's new 3D Commerce tone mapping function\n    ShaderChunk.tonemapping_pars_fragment = ShaderChunk.tonemapping_pars_fragment.replace('vec3 CustomToneMapping( vec3 color ) { return color; }', `\n      float startCompression = 0.8;\n      float desaturation = 0.5;\n      vec3 CustomToneMapping( vec3 color ) {\n        color *= toneMappingExposure;\n        \n        float d = 1. - startCompression;\n\n        float peak = max(color.r, max(color.g, color.b));\n        if (peak < startCompression) return color;\n\n        float newPeak = 1. - d * d / (peak + d - startCompression);\n        float invPeak = 1. / peak;\n        \n        float extraBrightness = dot(color * (1. - startCompression * invPeak), vec3(1, 1, 1));\n        \n        color *= newPeak * invPeak;\n        float g = 1. - 3. / (desaturation * extraBrightness + 3.);\n        return mix(color, vec3(1, 1, 1), g);\n      }`);\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!options.debug,\n        onShaderError: null\n      };\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    this.updateRendererSize();\n  }\n  static get singleton() {\n    return this._singleton;\n  }\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n    this._singleton = new Renderer({\n      powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n  set minScale(scale) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n  registerScene(scene) {\n    this.scenes.add(scene);\n    scene.forceRescale();\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n    }\n  }\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement.removeChild(this.canvas3D);\n    }\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n  }\n  displayCanvas(scene) {\n    return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D;\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  countVisibleScenes() {\n    const {\n      canvas3D\n    } = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {\n        element\n      } = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n    if (canvas3DScene != null) {\n      const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {\n          width,\n          height\n        } = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  updateRendererSize() {\n    var _a;\n    const dpr = resolveDpr();\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {\n          element\n        } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {\n        canvas\n      } = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n      (_a = scene.effectRenderer) === null || _a === void 0 ? void 0 : _a.setSize(width, height);\n    }\n  }\n  updateRendererScale(delta) {\n    const scaleStep = this.scaleStep;\n    this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n  shouldRender(scene) {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n  rescaleCanvas(scene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n    const {\n      style\n    } = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1 ? 'GPU throttling' : this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' : '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n  sceneSize(scene) {\n    const {\n      dpr\n    } = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {\n      width,\n      height\n    };\n  }\n  copyPixels(scene, width, height) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  orderedScenes() {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene, t, delta) {\n    const {\n      element,\n      exposure\n    } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n  }\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n    const {\n      canvas3D\n    } = this;\n    for (const scene of this.orderedScenes()) {\n      const {\n        element\n      } = scene;\n      if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n      this.preRender(scene, t, delta);\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {\n          matrix,\n          projectionMatrix\n        } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n      const {\n        width,\n        height\n      } = this.sceneSize(scene);\n      scene.renderShadow(this.threeRenderer);\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);\n      if (scene.effectRenderer != null) {\n        scene.effectRenderer.render(delta);\n      } else {\n        this.threeRenderer.autoClear = true; // this might get reset by the effectRenderer\n        this.threeRenderer.toneMapping = scene.toneMapping === 'commerce' ? CustomToneMapping : ACESFilmicToneMapping;\n        this.threeRenderer.render(scene, scene.camera);\n      }\n      if (this.multipleScenesVisible || !scene.element.modelIsVisible && scene.renderCount === 0) {\n        this.copyPixels(scene, width, height);\n      } else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n        scene.canvas.parentElement.appendChild(canvas3D);\n        scene.canvas.classList.remove('show');\n      }\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n    this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    return elements;\n  }\n}\nRenderer._singleton = new Renderer({\n  powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n  debug: isDebugMode()\n});","map":{"version":3,"names":["ACESFilmicToneMapping","CustomToneMapping","EventDispatcher","ShaderChunk","Vector2","WebGLRenderer","$updateEnvironment","$canvas","$tick","$updateSize","clamp","isDebugMode","resolveDpr","ARRenderer","CachingGLTFLoader","ModelViewerGLTFInstance","TextureUtils","DURATION_DECAY","LOW_FRAME_DURATION_MS","HIGH_FRAME_DURATION_MS","MAX_AVG_CHANGE_MS","SCALE_STEPS","DEFAULT_LAST_STEP","DEFAULT_POWER_PREFERENCE","Renderer","constructor","options","loader","width","height","dpr","scenes","Set","multipleScenesVisible","lastTick","performance","now","renderedLastFrame","scaleStep","lastStep","avgFrameDuration","onWebGLContextLost","event","dispatchEvent","type","sourceEvent","onWebGLContextRestored","_a","textureUtils","dispose","threeRenderer","scene","element","canvas3D","document","createElement","id","classList","add","tonemapping_pars_fragment","replace","canvas","alpha","antialias","powerPreference","preserveDrawingBuffer","autoClear","setPixelRatio","debug","checkShaderErrors","onShaderError","toneMapping","error","console","warn","arRenderer","canRender","initializeKTX2Loader","addEventListener","updateRendererSize","singleton","_singleton","resetSingleton","elements","disconnectedCallback","self","ModelViewerElement","connectedCallback","scaleFactor","minScale","scale","i","length","registerScene","forceRescale","size","getSize","x","y","setAnimationLoop","time","frame","render","unregisterScene","delete","parentElement","removeChild","displayCanvas","countVisibleScenes","visibleScenes","canvas3DScene","modelIsVisible","externalRenderer","newlyMultiple","disappearing","sceneSize","copyPixels","getBoundingClientRect","Math","max","ceil","setSize","effectRenderer","updateRendererScale","delta","min","shouldRender","rescaleCanvas","style","renderedDpr","reason","window","devicePixelRatio","CustomEvent","detail","reportedDpr","minimumDpr","pixelWidth","pixelHeight","context2D","context","log","clearRect","drawImage","orderedScenes","visible","push","isPresenting","preRender","t","exposure","exposureIsNumber","Number","isNaN","toneMappingExposure","onWebXRFrame","loaded","renderCount","camera","getCamera","updateMatrix","matrix","projectionMatrix","viewMatrix","slice","target","getTarget","z","visibleScene","queueRender","renderShadow","setRenderTarget","setViewport","appendChild","remove","hasRendered","removeEventListener"],"sources":["../../src/three-components/Renderer.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ACESFilmicToneMapping, CustomToneMapping, Event, EventDispatcher, ShaderChunk, Vector2, WebGLRenderer} from 'three';\n\nimport {$updateEnvironment} from '../features/environment.js';\nimport {ModelViewerGlobalConfig} from '../features/loading.js';\nimport ModelViewerElementBase, {$canvas, $tick, $updateSize} from '../model-viewer-base.js';\nimport {clamp, isDebugMode, resolveDpr} from '../utilities.js';\n\nimport {ARRenderer} from './ARRenderer.js';\nimport {CachingGLTFLoader} from './CachingGLTFLoader.js';\nimport {ModelViewerGLTFInstance} from './gltf-instance/ModelViewerGLTFInstance.js';\nimport {ModelScene} from './ModelScene.js';\nimport TextureUtils from './TextureUtils.js';\n\nexport interface RendererOptions {\n  powerPreference: string;\n  debug?: boolean;\n}\n\nexport interface ContextLostEvent extends Event {\n  type: 'contextlost';\n  sourceEvent: WebGLContextEvent;\n}\n\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\n\nexport const DEFAULT_POWER_PREFERENCE: string = 'high-performance';\n\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends\n    EventDispatcher<{contextlost: {sourceEvent: WebGLContextEvent}}> {\n  private static _singleton = new Renderer({\n    powerPreference:\n        (((self as any).ModelViewerElement || {}) as ModelViewerGlobalConfig)\n            .powerPreference ||\n        DEFAULT_POWER_PREFERENCE,\n    debug: isDebugMode()\n  });\n\n  static get singleton() {\n    return this._singleton;\n  }\n\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n\n    this._singleton = new Renderer({\n      powerPreference:\n          (((self as any).ModelViewerElement || {}) as ModelViewerGlobalConfig)\n              .powerPreference ||\n          DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n\n  public threeRenderer!: WebGLRenderer;\n  public canvas3D: HTMLCanvasElement;\n  public textureUtils: TextureUtils|null;\n  public arRenderer: ARRenderer;\n  public loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n  public width = 0;\n  public height = 0;\n  public dpr = 1;\n\n  private scenes: Set<ModelScene> = new Set();\n  private multipleScenesVisible = false;\n  private lastTick = performance.now();\n  private renderedLastFrame = false;\n  private scaleStep = 0;\n  private lastStep = DEFAULT_LAST_STEP;\n  private avgFrameDuration =\n      (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n\n  set minScale(scale: number) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n\n  constructor(options: RendererOptions) {\n    super();\n\n    this.dpr = resolveDpr();\n\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n\n    // Emmett's new 3D Commerce tone mapping function\n    ShaderChunk.tonemapping_pars_fragment =\n        ShaderChunk.tonemapping_pars_fragment.replace(\n            'vec3 CustomToneMapping( vec3 color ) { return color; }', `\n      float startCompression = 0.8;\n      float desaturation = 0.5;\n      vec3 CustomToneMapping( vec3 color ) {\n        color *= toneMappingExposure;\n        \n        float d = 1. - startCompression;\n\n        float peak = max(color.r, max(color.g, color.b));\n        if (peak < startCompression) return color;\n\n        float newPeak = 1. - d * d / (peak + d - startCompression);\n        float invPeak = 1. / peak;\n        \n        float extraBrightness = dot(color * (1. - startCompression * invPeak), vec3(1, 1, 1));\n        \n        color *= newPeak * invPeak;\n        float g = 1. - 3. / (desaturation * extraBrightness + 3.);\n        return mix(color, vec3(1, 1, 1), g);\n      }`);\n\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference as WebGLPowerPreference,\n        preserveDrawingBuffer: true,\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.setPixelRatio(1);  // handle pixel ratio externally\n\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!options.debug,\n        onShaderError: null\n      };\n\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils =\n        this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    this.updateRendererSize();\n  }\n\n  registerScene(scene: ModelScene) {\n    this.scenes.add(scene);\n\n    scene.forceRescale();\n\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop(\n          (time: number, frame?: any) => this.render(time, frame));\n    }\n  }\n\n  unregisterScene(scene: ModelScene) {\n    this.scenes.delete(scene);\n\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement!.removeChild(this.canvas3D);\n    }\n\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n  }\n\n  displayCanvas(scene: ModelScene): HTMLCanvasElement {\n    return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D;\n  }\n\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  private countVisibleScenes() {\n    const {canvas3D} = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {element} = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n\n    if (canvas3DScene != null) {\n      const newlyMultiple =\n          multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {width, height} = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement!.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  private updateRendererSize() {\n    const dpr = resolveDpr();\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {element} = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {canvas} = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n      scene.effectRenderer?.setSize(width, height);\n    }\n  }\n\n  private updateRendererScale(delta: number) {\n    const scaleStep = this.scaleStep;\n\n    this.avgFrameDuration += clamp(\n        DURATION_DECAY * (delta - this.avgFrameDuration),\n        -MAX_AVG_CHANGE_MS,\n        MAX_AVG_CHANGE_MS);\n\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (\n        this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration =\n          (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n\n  private shouldRender(scene: ModelScene): boolean {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n\n  private rescaleCanvas(scene: ModelScene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n\n    const {style} = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1                 ? 'GPU throttling' :\n        this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' :\n                                               '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n\n  private sceneSize(scene: ModelScene) {\n    const {dpr} = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(\n        Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(\n        Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {width, height};\n  }\n\n  private copyPixels(scene: ModelScene, width: number, height: number) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(\n        this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  private orderedScenes(): Array<ModelScene> {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n\n  get isPresenting(): boolean {\n    return this.arRenderer.isPresenting;\n  }\n\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene: ModelScene, t: number, delta: number) {\n    const {element, exposure} = scene;\n\n    element[$tick](t, delta);\n\n    const exposureIsNumber =\n        typeof exposure === 'number' && !Number.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n  }\n\n  render(t: number, frame?: XRFrame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n\n    const {canvas3D} = this;\n\n    for (const scene of this.orderedScenes()) {\n      const {element} = scene;\n      if (!element.loaded ||\n          (!element.modelIsVisible && scene.renderCount > 0)) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {matrix, projectionMatrix} = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n\n      const {width, height} = this.sceneSize(scene);\n\n      scene.renderShadow(this.threeRenderer);\n\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(\n          0, Math.ceil(this.height * this.dpr) - height, width, height);\n      if (scene.effectRenderer != null) {\n        scene.effectRenderer.render(delta);\n      } else {\n        this.threeRenderer.autoClear =\n            true;  // this might get reset by the effectRenderer\n        this.threeRenderer.toneMapping = scene.toneMapping === 'commerce' ?\n            CustomToneMapping :\n            ACESFilmicToneMapping;\n        this.threeRenderer.render(scene, scene.camera);\n      }\n      if (this.multipleScenesVisible ||\n          (!scene.element.modelIsVisible && scene.renderCount === 0)) {\n        this.copyPixels(scene, width, height);\n      } else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n        scene.canvas.parentElement!.appendChild(canvas3D);\n        scene.canvas.classList.remove('show');\n      }\n\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n\n  dispose(): Array<ModelViewerElementBase> {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    (this as any).threeRenderer = null;\n\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n\n    this.canvas3D.removeEventListener(\n        'webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    return elements;\n  }\n\n  onWebGLContextLost = (event: Event) => {\n    this.dispatchEvent(\n        {type: 'contextlost', sourceEvent: event} as ContextLostEvent);\n  };\n\n  onWebGLContextRestored = () => {\n    this.textureUtils?.dispose();\n    this.textureUtils = new TextureUtils(this.threeRenderer);\n    for (const scene of this.scenes) {\n      (scene.element as any)[$updateEnvironment]();\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}