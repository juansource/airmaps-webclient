{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * KHR_materials_variants specification allows duplicated variant names\n * but it makes handling the extension complex.\n * We ensure tha names and make it easier.\n * If you want to export the extension with the original names\n * you are recommended to write GLTFExporter plugin to restore the names.\n *\n * @param variantNames {Array<string>}\n * @return {Array<string>}\n */\nconst ensureUniqueNames = variantNames => {\n  const uniqueNames = [];\n  const knownNames = new Set();\n  for (const name of variantNames) {\n    let uniqueName = name;\n    let suffix = 0;\n    // @TODO: An easy solution.\n    //        O(N^2) in the worst scenario where N is variantNames.length.\n    //        Fix me if needed.\n    while (knownNames.has(uniqueName)) {\n      uniqueName = name + '.' + ++suffix;\n    }\n    knownNames.add(uniqueName);\n    uniqueNames.push(uniqueName);\n  }\n  return uniqueNames;\n};\n/**\n * Convert mappings array to table object to make handling the extension easier.\n *\n * @param\n *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\n * @param variantNames {Array<string>} Required to be unique names\n * @return {Map}\n */\nconst mappingsArrayToTable = extensionDef => {\n  const table = new Map();\n  for (const mapping of extensionDef.mappings) {\n    for (const variant of mapping.variants) {\n      table.set(variant, {\n        material: null,\n        gltfMaterialIndex: mapping.material\n      });\n    }\n  }\n  return table;\n};\nexport default class GLTFMaterialsVariantsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = 'KHR_materials_variants';\n  }\n  // Note that the following properties will be overridden even if they are\n  // pre-defined\n  // - gltf.userData.variants\n  // - mesh.userData.variantMaterials\n  afterRoot(gltf) {\n    const parser = this.parser;\n    const json = parser.json;\n    if (json.extensions === undefined || json.extensions[this.name] === undefined) {\n      return null;\n    }\n    const extensionDef = json.extensions[this.name];\n    const variantsDef = extensionDef.variants || [];\n    const variants = ensureUniqueNames(variantsDef.map(v => v.name));\n    for (const scene of gltf.scenes) {\n      // Save the variants data under associated mesh.userData\n      scene.traverse(object => {\n        const mesh = object;\n        if (!mesh.material) {\n          return;\n        }\n        const association = parser.associations.get(mesh);\n        if (association == null || association.meshes == null || association.primitives == null) {\n          return;\n        }\n        const meshDef = json.meshes[association.meshes];\n        const primitivesDef = meshDef.primitives;\n        const primitiveDef = primitivesDef[association.primitives];\n        const extensionsDef = primitiveDef.extensions;\n        if (!extensionsDef || !extensionsDef[this.name]) {\n          return;\n        }\n        mesh.userData.variantMaterials = mappingsArrayToTable(extensionsDef[this.name]);\n      });\n    }\n    gltf.userData.variants = variants;\n    return Promise.resolve();\n  }\n}","map":{"version":3,"names":["ensureUniqueNames","variantNames","uniqueNames","knownNames","Set","name","uniqueName","suffix","has","add","push","mappingsArrayToTable","extensionDef","table","Map","mapping","mappings","variant","variants","set","material","gltfMaterialIndex","GLTFMaterialsVariantsExtension","constructor","parser","afterRoot","gltf","json","extensions","undefined","variantsDef","map","v","scene","scenes","traverse","object","mesh","association","associations","get","meshes","primitives","meshDef","primitivesDef","primitiveDef","extensionsDef","userData","variantMaterials","Promise","resolve"],"sources":["../../../src/three-components/gltf-instance/VariantMaterialLoaderPlugin.ts"],"sourcesContent":["/* @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the 'License');\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an 'AS IS' BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * Materials variants extension\r\n *\r\n * Specification:\r\n * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\r\n */\r\n\r\n/**\r\n * The code in this file is based on\r\n * https://github.com/takahirox/three-gltf-extensions/tree/main/loaders/KHR_materials_variants\r\n */\r\n\r\nimport {Material as ThreeMaterial, Mesh} from 'three';\r\nimport {GLTFReference} from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport {GLTF, GLTFLoaderPlugin, GLTFParser} from 'three/examples/jsm/loaders/GLTFLoader.js';\r\n\r\n\r\nexport interface UserDataVariantMapping {\r\n  material: ThreeMaterial|null;\r\n  gltfMaterialIndex: number;\r\n}\r\n\r\n/**\r\n * KHR_materials_variants specification allows duplicated variant names\r\n * but it makes handling the extension complex.\r\n * We ensure tha names and make it easier.\r\n * If you want to export the extension with the original names\r\n * you are recommended to write GLTFExporter plugin to restore the names.\r\n *\r\n * @param variantNames {Array<string>}\r\n * @return {Array<string>}\r\n */\r\nconst ensureUniqueNames = (variantNames: string[]) => {\r\n  const uniqueNames = [];\r\n  const knownNames = new Set<string>();\r\n\r\n  for (const name of variantNames) {\r\n    let uniqueName = name;\r\n    let suffix = 0;\r\n    // @TODO: An easy solution.\r\n    //        O(N^2) in the worst scenario where N is variantNames.length.\r\n    //        Fix me if needed.\r\n    while (knownNames.has(uniqueName)) {\r\n      uniqueName = name + '.' + (++suffix);\r\n    }\r\n    knownNames.add(uniqueName);\r\n    uniqueNames.push(uniqueName);\r\n  }\r\n\r\n  return uniqueNames;\r\n};\r\n\r\n/**\r\n * Convert mappings array to table object to make handling the extension easier.\r\n *\r\n * @param\r\n *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\r\n * @param variantNames {Array<string>} Required to be unique names\r\n * @return {Map}\r\n */\r\nconst mappingsArrayToTable = (extensionDef:\r\n                                  any): Map<number, UserDataVariantMapping> => {\r\n  const table = new Map<number, UserDataVariantMapping>();\r\n  for (const mapping of extensionDef.mappings) {\r\n    for (const variant of mapping.variants) {\r\n      table.set(variant, {material: null, gltfMaterialIndex: mapping.material});\r\n    }\r\n  }\r\n  return table;\r\n};\r\n\r\nexport default class GLTFMaterialsVariantsExtension implements\r\n    GLTFLoaderPlugin {\r\n  parser: GLTFParser;\r\n  name: string;\r\n\r\n  constructor(parser: GLTFParser) {\r\n    this.parser = parser;\r\n    this.name = 'KHR_materials_variants';\r\n  }\r\n\r\n  // Note that the following properties will be overridden even if they are\r\n  // pre-defined\r\n  // - gltf.userData.variants\r\n  // - mesh.userData.variantMaterials\r\n  afterRoot(gltf: GLTF) {\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n\r\n    if (json.extensions === undefined ||\r\n        json.extensions[this.name] === undefined) {\r\n      return null;\r\n    }\r\n\r\n    const extensionDef = json.extensions[this.name];\r\n    const variantsDef = extensionDef.variants || [];\r\n    const variants =\r\n        ensureUniqueNames(variantsDef.map((v: {name: string}) => v.name));\r\n\r\n    for (const scene of gltf.scenes) {\r\n      // Save the variants data under associated mesh.userData\r\n      scene.traverse(object => {\r\n        const mesh = object as Mesh;\r\n\r\n        if (!mesh.material) {\r\n          return;\r\n        }\r\n\r\n        const association = parser.associations.get(mesh) as GLTFReference &\r\n            {primitives: number};\r\n\r\n        if (association == null || association.meshes == null ||\r\n            association.primitives == null) {\r\n          return;\r\n        }\r\n\r\n        const meshDef = json.meshes[association.meshes];\r\n        const primitivesDef = meshDef.primitives;\r\n        const primitiveDef = primitivesDef[association.primitives];\r\n        const extensionsDef = primitiveDef.extensions;\r\n\r\n        if (!extensionsDef || !extensionsDef[this.name]) {\r\n          return;\r\n        }\r\n\r\n        mesh.userData.variantMaterials =\r\n            mappingsArrayToTable(extensionsDef[this.name]);\r\n      });\r\n    }\r\n\r\n    gltf.userData.variants = variants;\r\n\r\n    return Promise.resolve();\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}