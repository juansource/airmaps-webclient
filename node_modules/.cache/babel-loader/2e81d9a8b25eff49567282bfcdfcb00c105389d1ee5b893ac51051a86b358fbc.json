{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Matrix4, Vector3 } from 'three';\nimport { $needsRender, $scene, $tick, toVector2D, toVector3D } from '../model-viewer-base.js';\nimport { Hotspot } from '../three-components/Hotspot.js';\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\nconst worldToModel = new Matrix4();\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nexport const AnnotationMixin = ModelViewerElement => {\n  var _a, _b, _c;\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Map();\n      this[_b] = mutations => {\n        mutations.forEach(mutation => {\n          // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n          // only has addedNodes and removedNodes (and no other details).\n          if (!(mutation instanceof MutationRecord) || mutation.type === 'childList') {\n            mutation.addedNodes.forEach(node => {\n              this[$addHotspot](node);\n            });\n            mutation.removedNodes.forEach(node => {\n              this[$removeHotspot](node);\n            });\n            this[$needsRender]();\n          }\n        });\n      };\n      this[_c] = new MutationObserver(this[$mutationCallback]);\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n      const {\n        ShadyDOM\n      } = self;\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {\n          childList: true\n        });\n      } else {\n        this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      const {\n        ShadyDOM\n      } = self;\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n    [(_a = $hotspotMap, _b = $mutationCallback, _c = $observer, $tick)](time, delta) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const {\n        annotationRenderer\n      } = scene;\n      const camera = scene.getCamera();\n      if (scene.shouldRender()) {\n        scene.updateSurfaceHotspots();\n        scene.updateHotspotsVisibility(camera.position);\n        annotationRenderer.domElement.style.display = '';\n        annotationRenderer.render(scene, camera);\n      }\n    }\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config) {\n      const hotspot = this[$hotspotMap].get(config.name);\n      if (hotspot == null) {\n        return;\n      }\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n      hotspot.surface = config.surface;\n      this[$needsRender]();\n    }\n    /**\n     * This method returns in-scene data about a requested hotspot including\n     * its position in screen (canvas) space and its current visibility.\n     */\n    queryHotspot(name) {\n      const hotspot = this[$hotspotMap].get(name);\n      if (hotspot == null) {\n        return null;\n      }\n      const position = toVector3D(hotspot.position);\n      const normal = toVector3D(hotspot.normal);\n      const facingCamera = hotspot.facingCamera;\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n      const vector = new Vector3();\n      vector.setFromMatrixPosition(hotspot.matrixWorld);\n      vector.project(camera);\n      const widthHalf = scene.width / 2;\n      const heightHalf = scene.height / 2;\n      vector.x = vector.x * widthHalf + widthHalf;\n      vector.y = -(vector.y * heightHalf) + heightHalf;\n      const canvasPosition = toVector3D(new Vector3(vector.x, vector.y, vector.z));\n      if (!Number.isFinite(canvasPosition.x) || !Number.isFinite(canvasPosition.y)) {\n        return null;\n      }\n      return {\n        position,\n        normal,\n        canvasPosition,\n        facingCamera\n      };\n    }\n    /**\n     * This method returns the model position, normal and texture coordinate\n     * of the point on the mesh corresponding to the input pixel coordinates\n     * given relative to the model-viewer element. The position and normal\n     * are returned as strings in the format suitable for putting in a\n     * hotspot's data-position and data-normal attributes. If the mesh is\n     * not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n      const hit = scene.positionAndNormalFromPoint(ndcPosition);\n      if (hit == null) {\n        return null;\n      }\n      worldToModel.copy(scene.target.matrixWorld).invert();\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal.transformDirection(worldToModel));\n      let uv = null;\n      if (hit.uv != null) {\n        uv = toVector2D(hit.uv);\n      }\n      return {\n        position: position,\n        normal: normal,\n        uv: uv\n      };\n    }\n    /**\n     * This method returns a dynamic hotspot ID string of the point on the mesh\n     * corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The ID string can be used in the data-surface\n     * attribute of the hotspot to make it follow this point on the surface even\n     * as the model animates. If the mesh is not hit, the result is null.\n     */\n    surfaceFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n      return scene.surfaceFromPoint(ndcPosition);\n    }\n    [$addHotspot](node) {\n      if (!(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n      let hotspot = this[$hotspotMap].get(node.slot);\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n          surface: node.dataset.surface\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].addHotspot(hotspot);\n      }\n      this[$scene].queueRender();\n    }\n    [$removeHotspot](node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n      const hotspot = this[$hotspotMap].get(node.slot);\n      if (!hotspot) {\n        return;\n      }\n      if (hotspot.decrement()) {\n        this[$scene].removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n      }\n      this[$scene].queueRender();\n    }\n  }\n  return AnnotationModelViewerElement;\n};","map":{"version":3,"names":["Matrix4","Vector3","$needsRender","$scene","$tick","toVector2D","toVector3D","Hotspot","$hotspotMap","Symbol","$mutationCallback","$observer","$addHotspot","$removeHotspot","worldToModel","AnnotationMixin","ModelViewerElement","AnnotationModelViewerElement","constructor","_a","Map","_b","mutations","forEach","mutation","MutationRecord","type","addedNodes","node","removedNodes","_c","MutationObserver","connectedCallback","i","children","length","ShadyDOM","self","observe","childList","observeChildren","disconnectedCallback","disconnect","unobserveChildren","time","delta","scene","annotationRenderer","camera","getCamera","shouldRender","updateSurfaceHotspots","updateHotspotsVisibility","position","domElement","style","display","render","updateHotspot","config","hotspot","get","name","updatePosition","updateNormal","normal","surface","queryHotspot","facingCamera","vector","setFromMatrixPosition","matrixWorld","project","widthHalf","width","heightHalf","height","x","y","canvasPosition","z","Number","isFinite","positionAndNormalFromPoint","pixelX","pixelY","ndcPosition","getNDC","hit","copy","target","invert","applyMatrix4","transformDirection","uv","surfaceFromPoint","HTMLElement","slot","indexOf","increment","dataset","set","addHotspot","queueRender","decrement","removeHotspot","delete"],"sources":["../../src/features/annotation.ts"],"sourcesContent":["\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Matrix4, Vector3} from 'three';\n\nimport ModelViewerElementBase, {$needsRender, $scene, $tick, toVector2D, toVector3D, Vector2D, Vector3D} from '../model-viewer-base.js';\nimport {Hotspot, HotspotConfiguration} from '../three-components/Hotspot.js';\nimport {Constructor} from '../utilities.js';\n\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\n\nconst worldToModel = new Matrix4();\n\nexport declare type HotspotData = {\n  position: Vector3D,\n  normal: Vector3D,\n  canvasPosition: Vector3D,\n  facingCamera: boolean,\n}\n\nexport declare interface AnnotationInterface {\n  updateHotspot(config: HotspotConfiguration): void;\n  queryHotspot(name: string): HotspotData|null;\n  positionAndNormalFromPoint(pixelX: number, pixelY: number):\n      {position: Vector3D, normal: Vector3D, uv: Vector2D|null}|null;\n  surfaceFromPoint(pixelX: number, pixelY: number): string|null;\n}\n\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nexport const AnnotationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnnotationInterface>&T => {\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    private[$hotspotMap] = new Map<string, Hotspot>();\n    private[$mutationCallback] = (mutations: Array<unknown>) => {\n      mutations.forEach((mutation) => {\n        // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n        // only has addedNodes and removedNodes (and no other details).\n        if (!(mutation instanceof MutationRecord) ||\n            mutation.type === 'childList') {\n          (mutation as MutationRecord).addedNodes.forEach((node) => {\n            this[$addHotspot](node);\n          });\n          (mutation as MutationRecord).removedNodes.forEach((node) => {\n            this[$removeHotspot](node);\n          });\n          this[$needsRender]();\n        }\n      });\n    };\n    private[$observer] = new MutationObserver(this[$mutationCallback]);\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {childList: true});\n      } else {\n        this[$observer] =\n            ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const {annotationRenderer} = scene;\n      const camera = scene.getCamera();\n\n      if (scene.shouldRender()) {\n        scene.updateSurfaceHotspots();\n        scene.updateHotspotsVisibility(camera.position);\n        annotationRenderer.domElement.style.display = '';\n        annotationRenderer.render(scene, camera);\n      }\n    }\n\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config: HotspotConfiguration) {\n      const hotspot = this[$hotspotMap].get(config.name);\n\n      if (hotspot == null) {\n        return;\n      }\n\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n      hotspot.surface = config.surface;\n      this[$needsRender]();\n    }\n\n    /**\n     * This method returns in-scene data about a requested hotspot including\n     * its position in screen (canvas) space and its current visibility.\n     */\n    queryHotspot(name: string): HotspotData|null {\n      const hotspot = this[$hotspotMap].get(name);\n      if (hotspot == null) {\n        return null;\n      }\n\n      const position = toVector3D(hotspot.position);\n      const normal = toVector3D(hotspot.normal);\n      const facingCamera = hotspot.facingCamera;\n\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n      const vector = new Vector3();\n\n      vector.setFromMatrixPosition(hotspot.matrixWorld);\n      vector.project(camera);\n\n      const widthHalf = scene.width / 2;\n      const heightHalf = scene.height / 2;\n\n      vector.x = (vector.x * widthHalf) + widthHalf;\n      vector.y = -(vector.y * heightHalf) + heightHalf;\n\n      const canvasPosition =\n          toVector3D(new Vector3(vector.x, vector.y, vector.z));\n\n      if (!Number.isFinite(canvasPosition.x) ||\n          !Number.isFinite(canvasPosition.y)) {\n        return null;\n      }\n\n      return {position, normal, canvasPosition, facingCamera};\n    }\n\n    /**\n     * This method returns the model position, normal and texture coordinate\n     * of the point on the mesh corresponding to the input pixel coordinates\n     * given relative to the model-viewer element. The position and normal\n     * are returned as strings in the format suitable for putting in a\n     * hotspot's data-position and data-normal attributes. If the mesh is\n     * not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX: number, pixelY: number):\n        {position: Vector3D, normal: Vector3D, uv: Vector2D|null}|null {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n\n      const hit = scene.positionAndNormalFromPoint(ndcPosition);\n      if (hit == null) {\n        return null;\n      }\n\n      worldToModel.copy(scene.target.matrixWorld).invert();\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal.transformDirection(worldToModel));\n\n      let uv = null;\n      if (hit.uv != null) {\n        uv = toVector2D(hit.uv);\n      }\n\n      return {position: position, normal: normal, uv: uv};\n    }\n\n    /**\n     * This method returns a dynamic hotspot ID string of the point on the mesh\n     * corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The ID string can be used in the data-surface\n     * attribute of the hotspot to make it follow this point on the surface even\n     * as the model animates. If the mesh is not hit, the result is null.\n     */\n    surfaceFromPoint(pixelX: number, pixelY: number): string|null {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n\n      return scene.surfaceFromPoint(ndcPosition);\n    }\n\n    private[$addHotspot](node: Node) {\n      if (!(node instanceof HTMLElement &&\n            node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n\n      let hotspot = this[$hotspotMap].get(node.slot);\n\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n          surface: node.dataset.surface,\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].addHotspot(hotspot);\n      }\n      this[$scene].queueRender();\n    }\n\n    private[$removeHotspot](node: Node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n\n      const hotspot = this[$hotspotMap].get(node.slot);\n\n      if (!hotspot) {\n        return;\n      }\n\n      if (hotspot.decrement()) {\n        this[$scene].removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n      }\n      this[$scene].queueRender();\n    }\n  }\n\n  return AnnotationModelViewerElement;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}