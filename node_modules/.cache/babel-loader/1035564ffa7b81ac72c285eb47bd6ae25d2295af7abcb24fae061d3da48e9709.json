{"ast":null,"code":"/* @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BackSide, Box3, Mesh, MeshBasicMaterial, MeshDepthMaterial, Object3D, OrthographicCamera, PlaneGeometry, RGBAFormat, ShaderMaterial, Vector3, WebGLRenderTarget } from 'three';\nimport { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader.js';\nimport { lerp } from 'three/src/math/MathUtils.js';\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimension multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n// Since hard shadows are not lightened by blurring and depth, set a lower\n// default intensity to make them more perceptually similar to the intensity of\n// the soft shadows.\nconst DEFAULT_HARD_INTENSITY = 0.3;\n/**\n * The Shadow class creates a shadow that fits a given scene and follows a\n * target. This shadow will follow the scene without any updates needed so long\n * as the shadow and scene are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the scene's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nexport class Shadow extends Object3D {\n  constructor(scene, softness, side) {\n    super();\n    this.camera = new OrthographicCamera();\n    // private cameraHelper = new CameraHelper(this.camera);\n    this.renderTarget = null;\n    this.renderTargetBlur = null;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);\n    this.verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);\n    this.intensity = 0;\n    this.softness = 1;\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.maxDimension = 0;\n    this.isAnimated = false;\n    this.needsUpdate = false;\n    const {\n      camera\n    } = this;\n    camera.rotation.x = Math.PI / 2;\n    camera.left = -0.5;\n    camera.right = 0.5;\n    camera.bottom = -0.5;\n    camera.top = 0.5;\n    this.add(camera);\n    // this.add(this.cameraHelper);\n    // this.cameraHelper.updateMatrixWorld = function() {\n    //   this.matrixWorld = this.camera.matrixWorld;\n    // };\n    const plane = new PlaneGeometry();\n    const shadowMaterial = new MeshBasicMaterial({\n      // color: new Color(1, 0, 0),\n      opacity: 1,\n      transparent: true,\n      side: BackSide\n    });\n    this.floor = new Mesh(plane, shadowMaterial);\n    this.floor.userData.shadow = true;\n    camera.add(this.floor);\n    // the plane onto which to blur the texture\n    this.blurPlane = new Mesh(plane);\n    this.blurPlane.visible = false;\n    camera.add(this.blurPlane);\n    scene.target.add(this);\n    // like MeshDepthMaterial, but goes from black to transparent\n    this.depthMaterial.onBeforeCompile = function (shader) {\n      shader.fragmentShader = shader.fragmentShader.replace('gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );', 'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );');\n    };\n    this.horizontalBlurMaterial.depthTest = false;\n    this.verticalBlurMaterial.depthTest = false;\n    this.setScene(scene, softness, side);\n  }\n  /**\n   * Update the shadow's size and position for a new scene. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n  setScene(scene, softness, side) {\n    const {\n      boundingBox,\n      size,\n      rotation,\n      position\n    } = this;\n    this.isAnimated = scene.animationNames.length > 0;\n    this.boundingBox.copy(scene.boundingBox);\n    this.size.copy(scene.size);\n    this.maxDimension = Math.max(size.x, size.y, size.z) * (this.isAnimated ? ANIMATION_SCALING : 1);\n    this.boundingBox.getCenter(position);\n    if (side === 'back') {\n      const {\n        min,\n        max\n      } = boundingBox;\n      [min.y, min.z] = [min.z, min.y];\n      [max.y, max.z] = [max.z, max.y];\n      [size.y, size.z] = [size.z, size.y];\n      rotation.x = Math.PI / 2;\n      rotation.y = Math.PI;\n    } else {\n      rotation.x = 0;\n      rotation.y = 0;\n    }\n    if (this.isAnimated) {\n      const minY = boundingBox.min.y;\n      const maxY = boundingBox.max.y;\n      size.y = this.maxDimension;\n      boundingBox.expandByVector(size.subScalar(this.maxDimension).multiplyScalar(-0.5));\n      boundingBox.min.y = minY;\n      boundingBox.max.y = maxY;\n      size.set(this.maxDimension, maxY - minY, this.maxDimension);\n    }\n    if (side === 'bottom') {\n      position.y = boundingBox.min.y;\n    } else {\n      position.z = boundingBox.min.y;\n    }\n    this.setSoftness(softness);\n  }\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n  setSoftness(softness) {\n    this.softness = softness;\n    const {\n      size,\n      camera\n    } = this;\n    const scaleY = this.isAnimated ? ANIMATION_SCALING : 1;\n    const resolution = scaleY * Math.pow(2, LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n    const softFar = size.y / 2;\n    const hardFar = size.y * scaleY;\n    camera.near = 0;\n    camera.far = lerp(hardFar, softFar, softness);\n    // we have co-opted opacity to scale the depth to clip\n    this.depthMaterial.opacity = 1.0 / softness;\n    camera.updateProjectionMatrix();\n    // this.cameraHelper.update();\n    this.setIntensity(this.intensity);\n    this.setOffset(0);\n  }\n  /**\n   * Lower-level version of the above function.\n   */\n  setMapSize(maxMapSize) {\n    const {\n      size\n    } = this;\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n    const baseWidth = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const baseHeight = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n    // width of blur filter in pixels (not adjustable)\n    const TAP_WIDTH = 10;\n    const width = TAP_WIDTH + baseWidth;\n    const height = TAP_WIDTH + baseHeight;\n    if (this.renderTarget != null && (this.renderTarget.width !== width || this.renderTarget.height !== height)) {\n      this.renderTarget.dispose();\n      this.renderTarget = null;\n      this.renderTargetBlur.dispose();\n      this.renderTargetBlur = null;\n    }\n    if (this.renderTarget == null) {\n      const params = {\n        format: RGBAFormat\n      };\n      this.renderTarget = new WebGLRenderTarget(width, height, params);\n      this.renderTargetBlur = new WebGLRenderTarget(width, height, params);\n      this.floor.material.map = this.renderTarget.texture;\n    }\n    // These pads account for the softening radius around the shadow.\n    this.camera.scale.set(size.x * (1 + TAP_WIDTH / baseWidth), size.z * (1 + TAP_WIDTH / baseHeight), 1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n  setIntensity(intensity) {\n    this.intensity = intensity;\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n      this.floor.material.opacity = intensity * lerp(DEFAULT_HARD_INTENSITY, 1, this.softness * this.softness);\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n  getIntensity() {\n    return this.intensity;\n  }\n  /**\n   * An offset can be specified to move the\n   * shadow vertically relative to the bottom of the scene. Positive is up, so\n   * values are generally negative. A small offset keeps our shadow from\n   * z-fighting with any baked-in shadow plane.\n   */\n  setOffset(offset) {\n    this.floor.position.z = -offset + 0.001 * this.maxDimension;\n  }\n  render(renderer, scene) {\n    // this.cameraHelper.visible = false;\n    // force the depthMaterial to everything\n    scene.overrideMaterial = this.depthMaterial;\n    // set renderer clear alpha\n    const initialClearAlpha = renderer.getClearAlpha();\n    renderer.setClearAlpha(0);\n    this.floor.visible = false;\n    // disable XR for offscreen rendering\n    const xrEnabled = renderer.xr.enabled;\n    renderer.xr.enabled = false;\n    // render to the render target to get the depths\n    const oldRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(scene, this.camera);\n    // and reset the override material\n    scene.overrideMaterial = null;\n    this.floor.visible = true;\n    this.blurShadow(renderer);\n    // reset and render the normal scene\n    renderer.xr.enabled = xrEnabled;\n    renderer.setRenderTarget(oldRenderTarget);\n    renderer.setClearAlpha(initialClearAlpha);\n    // this.cameraHelper.visible = true;\n  }\n  blurShadow(renderer) {\n    const {\n      camera,\n      horizontalBlurMaterial,\n      verticalBlurMaterial,\n      renderTarget,\n      renderTargetBlur,\n      blurPlane\n    } = this;\n    blurPlane.visible = true;\n    // blur horizontally and draw in the renderTargetBlur\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget.width;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget.texture;\n    renderer.setRenderTarget(renderTargetBlur);\n    renderer.render(blurPlane, camera);\n    // blur vertically and draw in the main renderTarget\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget.height;\n    verticalBlurMaterial.uniforms.tDiffuse.value = this.renderTargetBlur.texture;\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(blurPlane, camera);\n    blurPlane.visible = false;\n  }\n  dispose() {\n    if (this.renderTarget != null) {\n      this.renderTarget.dispose();\n    }\n    if (this.renderTargetBlur != null) {\n      this.renderTargetBlur.dispose();\n    }\n    this.depthMaterial.dispose();\n    this.horizontalBlurMaterial.dispose();\n    this.verticalBlurMaterial.dispose();\n    this.floor.material.dispose();\n    this.floor.geometry.dispose();\n    this.blurPlane.geometry.dispose();\n    this.removeFromParent();\n  }\n}","map":{"version":3,"names":["BackSide","Box3","Mesh","MeshBasicMaterial","MeshDepthMaterial","Object3D","OrthographicCamera","PlaneGeometry","RGBAFormat","ShaderMaterial","Vector3","WebGLRenderTarget","HorizontalBlurShader","VerticalBlurShader","lerp","LOG_MAX_RESOLUTION","LOG_MIN_RESOLUTION","ANIMATION_SCALING","DEFAULT_HARD_INTENSITY","Shadow","constructor","scene","softness","side","camera","renderTarget","renderTargetBlur","depthMaterial","horizontalBlurMaterial","verticalBlurMaterial","intensity","boundingBox","size","maxDimension","isAnimated","needsUpdate","rotation","x","Math","PI","left","right","bottom","top","add","plane","shadowMaterial","opacity","transparent","floor","userData","shadow","blurPlane","visible","target","onBeforeCompile","shader","fragmentShader","replace","depthTest","setScene","position","animationNames","length","copy","max","y","z","getCenter","min","minY","maxY","expandByVector","subScalar","multiplyScalar","set","setSoftness","scaleY","resolution","pow","setMapSize","softFar","hardFar","near","far","updateProjectionMatrix","setIntensity","setOffset","maxMapSize","baseWidth","baseHeight","TAP_WIDTH","width","height","dispose","params","format","material","map","texture","scale","getIntensity","offset","render","renderer","overrideMaterial","initialClearAlpha","getClearAlpha","setClearAlpha","xrEnabled","xr","enabled","oldRenderTarget","getRenderTarget","setRenderTarget","blurShadow","uniforms","h","value","tDiffuse","v","geometry","removeFromParent"],"sources":["../../src/three-components/Shadow.ts"],"sourcesContent":["/* @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BackSide, Box3, Material, Mesh, MeshBasicMaterial, MeshDepthMaterial, Object3D, OrthographicCamera, PlaneGeometry, RGBAFormat, Scene, ShaderMaterial, Vector3, WebGLRenderer, WebGLRenderTarget, WebGLRenderTargetOptions} from 'three';\nimport {HorizontalBlurShader} from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport {VerticalBlurShader} from 'three/examples/jsm/shaders/VerticalBlurShader.js';\nimport {lerp} from 'three/src/math/MathUtils.js';\n\nimport {ModelScene} from './ModelScene';\n\nexport type Side = 'back'|'bottom';\n\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimension multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n// Since hard shadows are not lightened by blurring and depth, set a lower\n// default intensity to make them more perceptually similar to the intensity of\n// the soft shadows.\nconst DEFAULT_HARD_INTENSITY = 0.3;\n\n/**\n * The Shadow class creates a shadow that fits a given scene and follows a\n * target. This shadow will follow the scene without any updates needed so long\n * as the shadow and scene are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the scene's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nexport class Shadow extends Object3D {\n  private camera = new OrthographicCamera();\n  // private cameraHelper = new CameraHelper(this.camera);\n  private renderTarget: WebGLRenderTarget|null = null;\n  private renderTargetBlur: WebGLRenderTarget|null = null;\n  private depthMaterial = new MeshDepthMaterial();\n  private horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);\n  private verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);\n  private intensity = 0;\n  private softness = 1;\n  private floor: Mesh;\n  private blurPlane: Mesh;\n  private boundingBox = new Box3;\n  private size = new Vector3;\n  private maxDimension = 0;\n  private isAnimated = false;\n  public needsUpdate = false;\n\n  constructor(scene: ModelScene, softness: number, side: Side) {\n    super();\n\n    const {camera} = this;\n    camera.rotation.x = Math.PI / 2;\n    camera.left = -0.5;\n    camera.right = 0.5;\n    camera.bottom = -0.5;\n    camera.top = 0.5;\n    this.add(camera);\n\n    // this.add(this.cameraHelper);\n    // this.cameraHelper.updateMatrixWorld = function() {\n    //   this.matrixWorld = this.camera.matrixWorld;\n    // };\n\n    const plane = new PlaneGeometry();\n    const shadowMaterial = new MeshBasicMaterial({\n      // color: new Color(1, 0, 0),\n      opacity: 1,\n      transparent: true,\n      side: BackSide,\n    });\n    this.floor = new Mesh(plane, shadowMaterial);\n    this.floor.userData.shadow = true;\n    camera.add(this.floor);\n\n    // the plane onto which to blur the texture\n    this.blurPlane = new Mesh(plane);\n    this.blurPlane.visible = false;\n    camera.add(this.blurPlane);\n\n    scene.target.add(this);\n\n    // like MeshDepthMaterial, but goes from black to transparent\n    this.depthMaterial.onBeforeCompile = function(shader) {\n      shader.fragmentShader = shader.fragmentShader.replace(\n          'gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n          'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );');\n    };\n\n    this.horizontalBlurMaterial.depthTest = false;\n    this.verticalBlurMaterial.depthTest = false;\n\n    this.setScene(scene, softness, side);\n  }\n\n  /**\n   * Update the shadow's size and position for a new scene. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n  setScene(scene: ModelScene, softness: number, side: Side) {\n    const {boundingBox, size, rotation, position} = this;\n\n    this.isAnimated = scene.animationNames.length > 0;\n    this.boundingBox.copy(scene.boundingBox);\n    this.size.copy(scene.size);\n    this.maxDimension = Math.max(size.x, size.y, size.z) *\n        (this.isAnimated ? ANIMATION_SCALING : 1);\n\n    this.boundingBox.getCenter(position);\n\n    if (side === 'back') {\n      const {min, max} = boundingBox;\n      [min.y, min.z] = [min.z, min.y];\n      [max.y, max.z] = [max.z, max.y];\n      [size.y, size.z] = [size.z, size.y];\n      rotation.x = Math.PI / 2;\n      rotation.y = Math.PI;\n    } else {\n      rotation.x = 0;\n      rotation.y = 0;\n    }\n\n    if (this.isAnimated) {\n      const minY = boundingBox.min.y;\n      const maxY = boundingBox.max.y;\n      size.y = this.maxDimension;\n      boundingBox.expandByVector(\n          size.subScalar(this.maxDimension).multiplyScalar(-0.5));\n      boundingBox.min.y = minY;\n      boundingBox.max.y = maxY;\n      size.set(this.maxDimension, maxY - minY, this.maxDimension);\n    }\n\n    if (side === 'bottom') {\n      position.y = boundingBox.min.y;\n    } else {\n      position.z = boundingBox.min.y;\n    }\n\n    this.setSoftness(softness);\n  }\n\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n  setSoftness(softness: number) {\n    this.softness = softness;\n    const {size, camera} = this;\n    const scaleY = (this.isAnimated ? ANIMATION_SCALING : 1);\n\n    const resolution = scaleY *\n        Math.pow(\n            2,\n            LOG_MAX_RESOLUTION -\n                softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n\n    const softFar = size.y / 2;\n    const hardFar = size.y * scaleY;\n\n    camera.near = 0;\n    camera.far = lerp(hardFar, softFar, softness);\n    // we have co-opted opacity to scale the depth to clip\n    this.depthMaterial.opacity = 1.0 / softness;\n    camera.updateProjectionMatrix();\n    // this.cameraHelper.update();\n\n    this.setIntensity(this.intensity);\n    this.setOffset(0);\n  }\n\n  /**\n   * Lower-level version of the above function.\n   */\n  setMapSize(maxMapSize: number) {\n    const {size} = this;\n\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n\n    const baseWidth =\n        Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const baseHeight =\n        Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n    // width of blur filter in pixels (not adjustable)\n    const TAP_WIDTH = 10;\n    const width = TAP_WIDTH + baseWidth;\n    const height = TAP_WIDTH + baseHeight;\n\n    if (this.renderTarget != null &&\n        (this.renderTarget.width !== width ||\n         this.renderTarget.height !== height)) {\n      this.renderTarget.dispose();\n      this.renderTarget = null;\n      this.renderTargetBlur!.dispose();\n      this.renderTargetBlur = null;\n    }\n\n    if (this.renderTarget == null) {\n      const params: WebGLRenderTargetOptions = {format: RGBAFormat};\n      this.renderTarget = new WebGLRenderTarget(width, height, params);\n      this.renderTargetBlur = new WebGLRenderTarget(width, height, params);\n\n      (this.floor.material as MeshBasicMaterial).map =\n          this.renderTarget.texture;\n    }\n\n    // These pads account for the softening radius around the shadow.\n    this.camera.scale.set(\n        size.x * (1 + TAP_WIDTH / baseWidth),\n        size.z * (1 + TAP_WIDTH / baseHeight),\n        1);\n    this.needsUpdate = true;\n  }\n\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n  setIntensity(intensity: number) {\n    this.intensity = intensity;\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n      (this.floor.material as MeshBasicMaterial).opacity = intensity *\n          lerp(DEFAULT_HARD_INTENSITY, 1, this.softness * this.softness);\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n\n  getIntensity(): number {\n    return this.intensity;\n  }\n\n  /**\n   * An offset can be specified to move the\n   * shadow vertically relative to the bottom of the scene. Positive is up, so\n   * values are generally negative. A small offset keeps our shadow from\n   * z-fighting with any baked-in shadow plane.\n   */\n  setOffset(offset: number) {\n    this.floor.position.z = -offset + 0.001 * this.maxDimension;\n  }\n\n  render(renderer: WebGLRenderer, scene: Scene) {\n    // this.cameraHelper.visible = false;\n\n    // force the depthMaterial to everything\n    scene.overrideMaterial = this.depthMaterial;\n\n    // set renderer clear alpha\n    const initialClearAlpha = renderer.getClearAlpha();\n    renderer.setClearAlpha(0);\n    this.floor.visible = false;\n\n    // disable XR for offscreen rendering\n    const xrEnabled = renderer.xr.enabled;\n    renderer.xr.enabled = false;\n\n    // render to the render target to get the depths\n    const oldRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(scene, this.camera);\n\n    // and reset the override material\n    scene.overrideMaterial = null;\n    this.floor.visible = true;\n\n    this.blurShadow(renderer);\n\n    // reset and render the normal scene\n    renderer.xr.enabled = xrEnabled;\n    renderer.setRenderTarget(oldRenderTarget);\n    renderer.setClearAlpha(initialClearAlpha);\n    // this.cameraHelper.visible = true;\n  }\n\n  blurShadow(renderer: WebGLRenderer) {\n    const {\n      camera,\n      horizontalBlurMaterial,\n      verticalBlurMaterial,\n      renderTarget,\n      renderTargetBlur,\n      blurPlane\n    } = this;\n    blurPlane.visible = true;\n\n    // blur horizontally and draw in the renderTargetBlur\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget!.width;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget!.texture;\n\n    renderer.setRenderTarget(renderTargetBlur);\n    renderer.render(blurPlane, camera);\n\n    // blur vertically and draw in the main renderTarget\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget!.height;\n    verticalBlurMaterial.uniforms.tDiffuse.value =\n        this.renderTargetBlur!.texture;\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(blurPlane, camera);\n\n    blurPlane.visible = false;\n  }\n\n  dispose() {\n    if (this.renderTarget != null) {\n      this.renderTarget.dispose();\n    }\n    if (this.renderTargetBlur != null) {\n      this.renderTargetBlur.dispose();\n    }\n    this.depthMaterial.dispose();\n    this.horizontalBlurMaterial.dispose();\n    this.verticalBlurMaterial.dispose();\n    (this.floor.material as Material).dispose();\n    this.floor.geometry.dispose();\n    this.blurPlane.geometry.dispose();\n    this.removeFromParent();\n  }\n}"],"mappings":"AAAA;;;;;;;;;;;;;;AAeA,SAAQA,QAAQ,EAAEC,IAAI,EAAYC,IAAI,EAAEC,iBAAiB,EAAEC,iBAAiB,EAAEC,QAAQ,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,UAAU,EAASC,cAAc,EAAEC,OAAO,EAAiBC,iBAAiB,QAAiC,OAAO;AAC/O,SAAQC,oBAAoB,QAAO,oDAAoD;AACvF,SAAQC,kBAAkB,QAAO,kDAAkD;AACnF,SAAQC,IAAI,QAAO,6BAA6B;AAMhD;AACA;AACA,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,kBAAkB,GAAG,CAAC;AAC5B;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,GAAG,CAAC;AAC3B;AACA;AACA;AACA,MAAMC,sBAAsB,GAAG,GAAG;AAElC;;;;;;;;;;;;;AAaA,OAAM,MAAOC,MAAO,SAAQd,QAAQ;EAkBlCe,YAAYC,KAAiB,EAAEC,QAAgB,EAAEC,IAAU;IACzD,KAAK,EAAE;IAlBD,KAAAC,MAAM,GAAG,IAAIlB,kBAAkB,EAAE;IACzC;IACQ,KAAAmB,YAAY,GAA2B,IAAI;IAC3C,KAAAC,gBAAgB,GAA2B,IAAI;IAC/C,KAAAC,aAAa,GAAG,IAAIvB,iBAAiB,EAAE;IACvC,KAAAwB,sBAAsB,GAAG,IAAInB,cAAc,CAACG,oBAAoB,CAAC;IACjE,KAAAiB,oBAAoB,GAAG,IAAIpB,cAAc,CAACI,kBAAkB,CAAC;IAC7D,KAAAiB,SAAS,GAAG,CAAC;IACb,KAAAR,QAAQ,GAAG,CAAC;IAGZ,KAAAS,WAAW,GAAG,IAAI9B,IAAI,CAAJ,CAAI;IACtB,KAAA+B,IAAI,GAAG,IAAItB,OAAO,CAAP,CAAO;IAClB,KAAAuB,YAAY,GAAG,CAAC;IAChB,KAAAC,UAAU,GAAG,KAAK;IACnB,KAAAC,WAAW,GAAG,KAAK;IAKxB,MAAM;MAACX;IAAM,CAAC,GAAG,IAAI;IACrBA,MAAM,CAACY,QAAQ,CAACC,CAAC,GAAGC,IAAI,CAACC,EAAE,GAAG,CAAC;IAC/Bf,MAAM,CAACgB,IAAI,GAAG,CAAC,GAAG;IAClBhB,MAAM,CAACiB,KAAK,GAAG,GAAG;IAClBjB,MAAM,CAACkB,MAAM,GAAG,CAAC,GAAG;IACpBlB,MAAM,CAACmB,GAAG,GAAG,GAAG;IAChB,IAAI,CAACC,GAAG,CAACpB,MAAM,CAAC;IAEhB;IACA;IACA;IACA;IAEA,MAAMqB,KAAK,GAAG,IAAItC,aAAa,EAAE;IACjC,MAAMuC,cAAc,GAAG,IAAI3C,iBAAiB,CAAC;MAC3C;MACA4C,OAAO,EAAE,CAAC;MACVC,WAAW,EAAE,IAAI;MACjBzB,IAAI,EAAEvB;KACP,CAAC;IACF,IAAI,CAACiD,KAAK,GAAG,IAAI/C,IAAI,CAAC2C,KAAK,EAAEC,cAAc,CAAC;IAC5C,IAAI,CAACG,KAAK,CAACC,QAAQ,CAACC,MAAM,GAAG,IAAI;IACjC3B,MAAM,CAACoB,GAAG,CAAC,IAAI,CAACK,KAAK,CAAC;IAEtB;IACA,IAAI,CAACG,SAAS,GAAG,IAAIlD,IAAI,CAAC2C,KAAK,CAAC;IAChC,IAAI,CAACO,SAAS,CAACC,OAAO,GAAG,KAAK;IAC9B7B,MAAM,CAACoB,GAAG,CAAC,IAAI,CAACQ,SAAS,CAAC;IAE1B/B,KAAK,CAACiC,MAAM,CAACV,GAAG,CAAC,IAAI,CAAC;IAEtB;IACA,IAAI,CAACjB,aAAa,CAAC4B,eAAe,GAAG,UAASC,MAAM;MAClDA,MAAM,CAACC,cAAc,GAAGD,MAAM,CAACC,cAAc,CAACC,OAAO,CACjD,2DAA2D,EAC3D,qEAAqE,CAAC;IAC5E,CAAC;IAED,IAAI,CAAC9B,sBAAsB,CAAC+B,SAAS,GAAG,KAAK;IAC7C,IAAI,CAAC9B,oBAAoB,CAAC8B,SAAS,GAAG,KAAK;IAE3C,IAAI,CAACC,QAAQ,CAACvC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,CAAC;EACtC;EAEA;;;;EAIAqC,QAAQA,CAACvC,KAAiB,EAAEC,QAAgB,EAAEC,IAAU;IACtD,MAAM;MAACQ,WAAW;MAAEC,IAAI;MAAEI,QAAQ;MAAEyB;IAAQ,CAAC,GAAG,IAAI;IAEpD,IAAI,CAAC3B,UAAU,GAAGb,KAAK,CAACyC,cAAc,CAACC,MAAM,GAAG,CAAC;IACjD,IAAI,CAAChC,WAAW,CAACiC,IAAI,CAAC3C,KAAK,CAACU,WAAW,CAAC;IACxC,IAAI,CAACC,IAAI,CAACgC,IAAI,CAAC3C,KAAK,CAACW,IAAI,CAAC;IAC1B,IAAI,CAACC,YAAY,GAAGK,IAAI,CAAC2B,GAAG,CAACjC,IAAI,CAACK,CAAC,EAAEL,IAAI,CAACkC,CAAC,EAAElC,IAAI,CAACmC,CAAC,CAAC,IAC/C,IAAI,CAACjC,UAAU,GAAGjB,iBAAiB,GAAG,CAAC,CAAC;IAE7C,IAAI,CAACc,WAAW,CAACqC,SAAS,CAACP,QAAQ,CAAC;IAEpC,IAAItC,IAAI,KAAK,MAAM,EAAE;MACnB,MAAM;QAAC8C,GAAG;QAAEJ;MAAG,CAAC,GAAGlC,WAAW;MAC9B,CAACsC,GAAG,CAACH,CAAC,EAAEG,GAAG,CAACF,CAAC,CAAC,GAAG,CAACE,GAAG,CAACF,CAAC,EAAEE,GAAG,CAACH,CAAC,CAAC;MAC/B,CAACD,GAAG,CAACC,CAAC,EAAED,GAAG,CAACE,CAAC,CAAC,GAAG,CAACF,GAAG,CAACE,CAAC,EAAEF,GAAG,CAACC,CAAC,CAAC;MAC/B,CAAClC,IAAI,CAACkC,CAAC,EAAElC,IAAI,CAACmC,CAAC,CAAC,GAAG,CAACnC,IAAI,CAACmC,CAAC,EAAEnC,IAAI,CAACkC,CAAC,CAAC;MACnC9B,QAAQ,CAACC,CAAC,GAAGC,IAAI,CAACC,EAAE,GAAG,CAAC;MACxBH,QAAQ,CAAC8B,CAAC,GAAG5B,IAAI,CAACC,EAAE;KACrB,MAAM;MACLH,QAAQ,CAACC,CAAC,GAAG,CAAC;MACdD,QAAQ,CAAC8B,CAAC,GAAG,CAAC;;IAGhB,IAAI,IAAI,CAAChC,UAAU,EAAE;MACnB,MAAMoC,IAAI,GAAGvC,WAAW,CAACsC,GAAG,CAACH,CAAC;MAC9B,MAAMK,IAAI,GAAGxC,WAAW,CAACkC,GAAG,CAACC,CAAC;MAC9BlC,IAAI,CAACkC,CAAC,GAAG,IAAI,CAACjC,YAAY;MAC1BF,WAAW,CAACyC,cAAc,CACtBxC,IAAI,CAACyC,SAAS,CAAC,IAAI,CAACxC,YAAY,CAAC,CAACyC,cAAc,CAAC,CAAC,GAAG,CAAC,CAAC;MAC3D3C,WAAW,CAACsC,GAAG,CAACH,CAAC,GAAGI,IAAI;MACxBvC,WAAW,CAACkC,GAAG,CAACC,CAAC,GAAGK,IAAI;MACxBvC,IAAI,CAAC2C,GAAG,CAAC,IAAI,CAAC1C,YAAY,EAAEsC,IAAI,GAAGD,IAAI,EAAE,IAAI,CAACrC,YAAY,CAAC;;IAG7D,IAAIV,IAAI,KAAK,QAAQ,EAAE;MACrBsC,QAAQ,CAACK,CAAC,GAAGnC,WAAW,CAACsC,GAAG,CAACH,CAAC;KAC/B,MAAM;MACLL,QAAQ,CAACM,CAAC,GAAGpC,WAAW,CAACsC,GAAG,CAACH,CAAC;;IAGhC,IAAI,CAACU,WAAW,CAACtD,QAAQ,CAAC;EAC5B;EAEA;;;;EAIAsD,WAAWA,CAACtD,QAAgB;IAC1B,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IACxB,MAAM;MAACU,IAAI;MAAER;IAAM,CAAC,GAAG,IAAI;IAC3B,MAAMqD,MAAM,GAAI,IAAI,CAAC3C,UAAU,GAAGjB,iBAAiB,GAAG,CAAE;IAExD,MAAM6D,UAAU,GAAGD,MAAM,GACrBvC,IAAI,CAACyC,GAAG,CACJ,CAAC,EACDhE,kBAAkB,GACdO,QAAQ,IAAIP,kBAAkB,GAAGC,kBAAkB,CAAC,CAAC;IACjE,IAAI,CAACgE,UAAU,CAACF,UAAU,CAAC;IAE3B,MAAMG,OAAO,GAAGjD,IAAI,CAACkC,CAAC,GAAG,CAAC;IAC1B,MAAMgB,OAAO,GAAGlD,IAAI,CAACkC,CAAC,GAAGW,MAAM;IAE/BrD,MAAM,CAAC2D,IAAI,GAAG,CAAC;IACf3D,MAAM,CAAC4D,GAAG,GAAGtE,IAAI,CAACoE,OAAO,EAAED,OAAO,EAAE3D,QAAQ,CAAC;IAC7C;IACA,IAAI,CAACK,aAAa,CAACoB,OAAO,GAAG,GAAG,GAAGzB,QAAQ;IAC3CE,MAAM,CAAC6D,sBAAsB,EAAE;IAC/B;IAEA,IAAI,CAACC,YAAY,CAAC,IAAI,CAACxD,SAAS,CAAC;IACjC,IAAI,CAACyD,SAAS,CAAC,CAAC,CAAC;EACnB;EAEA;;;EAGAP,UAAUA,CAACQ,UAAkB;IAC3B,MAAM;MAACxD;IAAI,CAAC,GAAG,IAAI;IAEnB,IAAI,IAAI,CAACE,UAAU,EAAE;MACnBsD,UAAU,IAAIvE,iBAAiB;;IAGjC,MAAMwE,SAAS,GACXnD,IAAI,CAACW,KAAK,CAACjB,IAAI,CAACK,CAAC,GAAGL,IAAI,CAACmC,CAAC,GAAGqB,UAAU,GAAGA,UAAU,GAAGxD,IAAI,CAACK,CAAC,GAAGL,IAAI,CAACmC,CAAC,CAAC;IAC3E,MAAMuB,UAAU,GACZpD,IAAI,CAACW,KAAK,CAACjB,IAAI,CAACK,CAAC,GAAGL,IAAI,CAACmC,CAAC,GAAGqB,UAAU,GAAGxD,IAAI,CAACmC,CAAC,GAAGnC,IAAI,CAACK,CAAC,GAAGmD,UAAU,CAAC;IAC3E;IACA,MAAMG,SAAS,GAAG,EAAE;IACpB,MAAMC,KAAK,GAAGD,SAAS,GAAGF,SAAS;IACnC,MAAMI,MAAM,GAAGF,SAAS,GAAGD,UAAU;IAErC,IAAI,IAAI,CAACjE,YAAY,IAAI,IAAI,KACxB,IAAI,CAACA,YAAY,CAACmE,KAAK,KAAKA,KAAK,IACjC,IAAI,CAACnE,YAAY,CAACoE,MAAM,KAAKA,MAAM,CAAC,EAAE;MACzC,IAAI,CAACpE,YAAY,CAACqE,OAAO,EAAE;MAC3B,IAAI,CAACrE,YAAY,GAAG,IAAI;MACxB,IAAI,CAACC,gBAAiB,CAACoE,OAAO,EAAE;MAChC,IAAI,CAACpE,gBAAgB,GAAG,IAAI;;IAG9B,IAAI,IAAI,CAACD,YAAY,IAAI,IAAI,EAAE;MAC7B,MAAMsE,MAAM,GAA6B;QAACC,MAAM,EAAExF;MAAU,CAAC;MAC7D,IAAI,CAACiB,YAAY,GAAG,IAAId,iBAAiB,CAACiF,KAAK,EAAEC,MAAM,EAAEE,MAAM,CAAC;MAChE,IAAI,CAACrE,gBAAgB,GAAG,IAAIf,iBAAiB,CAACiF,KAAK,EAAEC,MAAM,EAAEE,MAAM,CAAC;MAEnE,IAAI,CAAC9C,KAAK,CAACgD,QAA8B,CAACC,GAAG,GAC1C,IAAI,CAACzE,YAAY,CAAC0E,OAAO;;IAG/B;IACA,IAAI,CAAC3E,MAAM,CAAC4E,KAAK,CAACzB,GAAG,CACjB3C,IAAI,CAACK,CAAC,IAAI,CAAC,GAAGsD,SAAS,GAAGF,SAAS,CAAC,EACpCzD,IAAI,CAACmC,CAAC,IAAI,CAAC,GAAGwB,SAAS,GAAGD,UAAU,CAAC,EACrC,CAAC,CAAC;IACN,IAAI,CAACvD,WAAW,GAAG,IAAI;EACzB;EAEA;;;;EAIAmD,YAAYA,CAACxD,SAAiB;IAC5B,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC1B,IAAIA,SAAS,GAAG,CAAC,EAAE;MACjB,IAAI,CAACuB,OAAO,GAAG,IAAI;MACnB,IAAI,CAACJ,KAAK,CAACI,OAAO,GAAG,IAAI;MACxB,IAAI,CAACJ,KAAK,CAACgD,QAA8B,CAAClD,OAAO,GAAGjB,SAAS,GAC1DhB,IAAI,CAACI,sBAAsB,EAAE,CAAC,EAAE,IAAI,CAACI,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC;KACnE,MAAM;MACL,IAAI,CAAC+B,OAAO,GAAG,KAAK;MACpB,IAAI,CAACJ,KAAK,CAACI,OAAO,GAAG,KAAK;;EAE9B;EAEAgD,YAAYA,CAAA;IACV,OAAO,IAAI,CAACvE,SAAS;EACvB;EAEA;;;;;;EAMAyD,SAASA,CAACe,MAAc;IACtB,IAAI,CAACrD,KAAK,CAACY,QAAQ,CAACM,CAAC,GAAG,CAACmC,MAAM,GAAG,KAAK,GAAG,IAAI,CAACrE,YAAY;EAC7D;EAEAsE,MAAMA,CAACC,QAAuB,EAAEnF,KAAY;IAC1C;IAEA;IACAA,KAAK,CAACoF,gBAAgB,GAAG,IAAI,CAAC9E,aAAa;IAE3C;IACA,MAAM+E,iBAAiB,GAAGF,QAAQ,CAACG,aAAa,EAAE;IAClDH,QAAQ,CAACI,aAAa,CAAC,CAAC,CAAC;IACzB,IAAI,CAAC3D,KAAK,CAACI,OAAO,GAAG,KAAK;IAE1B;IACA,MAAMwD,SAAS,GAAGL,QAAQ,CAACM,EAAE,CAACC,OAAO;IACrCP,QAAQ,CAACM,EAAE,CAACC,OAAO,GAAG,KAAK;IAE3B;IACA,MAAMC,eAAe,GAAGR,QAAQ,CAACS,eAAe,EAAE;IAClDT,QAAQ,CAACU,eAAe,CAAC,IAAI,CAACzF,YAAY,CAAC;IAC3C+E,QAAQ,CAACD,MAAM,CAAClF,KAAK,EAAE,IAAI,CAACG,MAAM,CAAC;IAEnC;IACAH,KAAK,CAACoF,gBAAgB,GAAG,IAAI;IAC7B,IAAI,CAACxD,KAAK,CAACI,OAAO,GAAG,IAAI;IAEzB,IAAI,CAAC8D,UAAU,CAACX,QAAQ,CAAC;IAEzB;IACAA,QAAQ,CAACM,EAAE,CAACC,OAAO,GAAGF,SAAS;IAC/BL,QAAQ,CAACU,eAAe,CAACF,eAAe,CAAC;IACzCR,QAAQ,CAACI,aAAa,CAACF,iBAAiB,CAAC;IACzC;EACF;EAEAS,UAAUA,CAACX,QAAuB;IAChC,MAAM;MACJhF,MAAM;MACNI,sBAAsB;MACtBC,oBAAoB;MACpBJ,YAAY;MACZC,gBAAgB;MAChB0B;IAAS,CACV,GAAG,IAAI;IACRA,SAAS,CAACC,OAAO,GAAG,IAAI;IAExB;IACAD,SAAS,CAAC6C,QAAQ,GAAGrE,sBAAsB;IAC3CA,sBAAsB,CAACwF,QAAQ,CAACC,CAAC,CAACC,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC7F,YAAa,CAACmE,KAAK;IACtEhE,sBAAsB,CAACwF,QAAQ,CAACG,QAAQ,CAACD,KAAK,GAAG,IAAI,CAAC7F,YAAa,CAAC0E,OAAO;IAE3EK,QAAQ,CAACU,eAAe,CAACxF,gBAAgB,CAAC;IAC1C8E,QAAQ,CAACD,MAAM,CAACnD,SAAS,EAAE5B,MAAM,CAAC;IAElC;IACA4B,SAAS,CAAC6C,QAAQ,GAAGpE,oBAAoB;IACzCA,oBAAoB,CAACuF,QAAQ,CAACI,CAAC,CAACF,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC7F,YAAa,CAACoE,MAAM;IACrEhE,oBAAoB,CAACuF,QAAQ,CAACG,QAAQ,CAACD,KAAK,GACxC,IAAI,CAAC5F,gBAAiB,CAACyE,OAAO;IAElCK,QAAQ,CAACU,eAAe,CAACzF,YAAY,CAAC;IACtC+E,QAAQ,CAACD,MAAM,CAACnD,SAAS,EAAE5B,MAAM,CAAC;IAElC4B,SAAS,CAACC,OAAO,GAAG,KAAK;EAC3B;EAEAyC,OAAOA,CAAA;IACL,IAAI,IAAI,CAACrE,YAAY,IAAI,IAAI,EAAE;MAC7B,IAAI,CAACA,YAAY,CAACqE,OAAO,EAAE;;IAE7B,IAAI,IAAI,CAACpE,gBAAgB,IAAI,IAAI,EAAE;MACjC,IAAI,CAACA,gBAAgB,CAACoE,OAAO,EAAE;;IAEjC,IAAI,CAACnE,aAAa,CAACmE,OAAO,EAAE;IAC5B,IAAI,CAAClE,sBAAsB,CAACkE,OAAO,EAAE;IACrC,IAAI,CAACjE,oBAAoB,CAACiE,OAAO,EAAE;IAClC,IAAI,CAAC7C,KAAK,CAACgD,QAAqB,CAACH,OAAO,EAAE;IAC3C,IAAI,CAAC7C,KAAK,CAACwE,QAAQ,CAAC3B,OAAO,EAAE;IAC7B,IAAI,CAAC1C,SAAS,CAACqE,QAAQ,CAAC3B,OAAO,EAAE;IACjC,IAAI,CAAC4B,gBAAgB,EAAE;EACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}