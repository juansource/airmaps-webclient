{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\nimport { Color, DoubleSide, FrontSide, Vector2 } from 'three';\nimport { PBRMetallicRoughness } from './pbr-metallic-roughness.js';\nimport { TextureInfo, TextureUsage } from './texture-info.js';\nimport { $correlatedObjects, $onUpdate, ThreeDOMElement } from './three-dom-element.js';\nconst $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');\nconst $normalTexture = Symbol('normalTexture');\nconst $occlusionTexture = Symbol('occlusionTexture');\nconst $emissiveTexture = Symbol('emissiveTexture');\nconst $backingThreeMaterial = Symbol('backingThreeMaterial');\nconst $applyAlphaCutoff = Symbol('applyAlphaCutoff');\nconst $getAlphaMode = Symbol('getAlphaMode');\nexport const $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');\nconst $initialize = Symbol('initialize');\nexport const $getLoadedMaterial = Symbol('getLoadedMaterial');\nexport const $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');\nexport const $gltfIndex = Symbol('gltfIndex');\nexport const $setActive = Symbol('setActive');\nexport const $variantIndices = Symbol('variantIndices');\nconst $isActive = Symbol('isActive');\nexport const $variantSet = Symbol('variantSet');\nconst $modelVariants = Symbol('modelVariants');\nconst $name = Symbol('name');\nconst $pbrTextures = Symbol('pbrTextures');\n/**\n * Material facade implementation for Three.js materials\n */\nexport class Material extends ThreeDOMElement {\n  constructor(onUpdate, gltfIndex, isActive, modelVariants, correlatedMaterials, name, lazyLoadInfo = undefined) {\n    super(onUpdate, correlatedMaterials);\n    this[_a] = new Set();\n    this[_b] = new Map();\n    this[$gltfIndex] = gltfIndex;\n    this[$isActive] = isActive;\n    this[$modelVariants] = modelVariants;\n    this[$name] = name;\n    if (lazyLoadInfo == null) {\n      this[$initialize]();\n    } else {\n      this[$lazyLoadGLTFInfo] = lazyLoadInfo;\n    }\n  }\n  get [(_a = $variantSet, _b = $pbrTextures, $backingThreeMaterial)]() {\n    return this[$correlatedObjects].values().next().value;\n  }\n  [$initialize]() {\n    const onUpdate = this[$onUpdate];\n    const correlatedMaterials = this[$correlatedObjects];\n    this[$pbrMetallicRoughness] = new PBRMetallicRoughness(onUpdate, correlatedMaterials);\n    const {\n      normalMap,\n      aoMap,\n      emissiveMap\n    } = correlatedMaterials.values().next().value;\n    this[$normalTexture] = new TextureInfo(onUpdate, TextureUsage.Normal, normalMap, correlatedMaterials);\n    this[$occlusionTexture] = new TextureInfo(onUpdate, TextureUsage.Occlusion, aoMap, correlatedMaterials);\n    this[$emissiveTexture] = new TextureInfo(onUpdate, TextureUsage.Emissive, emissiveMap, correlatedMaterials);\n    const createTextureInfo = usage => {\n      this[$pbrTextures].set(usage, new TextureInfo(onUpdate, usage, null, correlatedMaterials));\n    };\n    createTextureInfo(TextureUsage.Clearcoat);\n    createTextureInfo(TextureUsage.ClearcoatRoughness);\n    createTextureInfo(TextureUsage.ClearcoatNormal);\n    createTextureInfo(TextureUsage.SheenColor);\n    createTextureInfo(TextureUsage.SheenRoughness);\n    createTextureInfo(TextureUsage.Transmission);\n    createTextureInfo(TextureUsage.Thickness);\n    createTextureInfo(TextureUsage.Specular);\n    createTextureInfo(TextureUsage.SpecularColor);\n    createTextureInfo(TextureUsage.Iridescence);\n    createTextureInfo(TextureUsage.IridescenceThickness);\n    createTextureInfo(TextureUsage.Anisotropy);\n  }\n  async [$getLoadedMaterial]() {\n    if (this[$lazyLoadGLTFInfo] != null) {\n      const {\n        set,\n        material\n      } = await this[$lazyLoadGLTFInfo].doLazyLoad();\n      // Fills in the missing data.\n      this[$correlatedObjects] = set;\n      this[$initialize]();\n      // Releases lazy load info.\n      this[$lazyLoadGLTFInfo] = undefined;\n      // Redefines the method as a noop method.\n      this.ensureLoaded = async () => {};\n      return material;\n    }\n    return this[$correlatedObjects].values().next().value;\n  }\n  colorFromRgb(rgb) {\n    const color = new Color();\n    if (rgb instanceof Array) {\n      color.fromArray(rgb);\n    } else {\n      color.set(rgb);\n    }\n    return color;\n  }\n  [$ensureMaterialIsLoaded]() {\n    if (this[$lazyLoadGLTFInfo] == null) {\n      return;\n    }\n    throw new Error(`Material \"${this.name}\" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`);\n  }\n  async ensureLoaded() {\n    await this[$getLoadedMaterial]();\n  }\n  get isLoaded() {\n    return this[$lazyLoadGLTFInfo] == null;\n  }\n  get isActive() {\n    return this[$isActive];\n  }\n  [$setActive](isActive) {\n    this[$isActive] = isActive;\n  }\n  get name() {\n    return this[$name] || '';\n  }\n  set name(name) {\n    this[$name] = name;\n    if (this[$correlatedObjects] != null) {\n      for (const threeMaterial of this[$correlatedObjects]) {\n        threeMaterial.name = name;\n      }\n    }\n  }\n  get pbrMetallicRoughness() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrMetallicRoughness];\n  }\n  get normalTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$normalTexture];\n  }\n  get occlusionTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$occlusionTexture];\n  }\n  get emissiveTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$emissiveTexture];\n  }\n  get emissiveFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].emissive.toArray();\n  }\n  get index() {\n    return this[$gltfIndex];\n  }\n  [$variantIndices]() {\n    return this[$variantSet];\n  }\n  hasVariant(name) {\n    const variantData = this[$modelVariants].get(name);\n    return variantData != null && this[$variantSet].has(variantData.index);\n  }\n  setEmissiveFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.emissive.set(color);\n    }\n    this[$onUpdate]();\n  }\n  [$getAlphaMode]() {\n    // Follows implementation of GLTFExporter from three.js\n    if (this[$backingThreeMaterial].transparent) {\n      return 'BLEND';\n    } else {\n      if (this[$backingThreeMaterial].alphaTest > 0.0) {\n        return 'MASK';\n      }\n    }\n    return 'OPAQUE';\n  }\n  [$applyAlphaCutoff]() {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      if (this[$getAlphaMode]() === 'MASK') {\n        if (material.alphaTest == undefined) {\n          material.alphaTest = 0.5;\n        }\n      } else {\n        material.alphaTest = undefined;\n      }\n      material.needsUpdate = true;\n    }\n  }\n  setAlphaCutoff(cutoff) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.alphaTest = cutoff;\n      material.needsUpdate = true;\n    }\n    // Set AlphaCutoff to undefined if AlphaMode is not MASK.\n    this[$applyAlphaCutoff]();\n    this[$onUpdate]();\n  }\n  getAlphaCutoff() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].alphaTest;\n  }\n  setDoubleSided(doubleSided) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      // When double-sided is disabled gltf spec dictates that Back-Face culling\n      // must be disabled, in three.js parlance that would mean FrontSide\n      // rendering only.\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided\n      material.side = doubleSided ? DoubleSide : FrontSide;\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n  getDoubleSided() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].side == DoubleSide;\n  }\n  setAlphaMode(alphaMode) {\n    this[$ensureMaterialIsLoaded]();\n    const enableTransparency = (material, enabled) => {\n      material.transparent = enabled;\n      material.depthWrite = !enabled;\n    };\n    for (const material of this[$correlatedObjects]) {\n      enableTransparency(material, alphaMode === 'BLEND');\n      if (alphaMode === 'MASK') {\n        material.alphaTest = 0.5;\n      } else {\n        material.alphaTest = undefined;\n      }\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n  getAlphaMode() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$getAlphaMode]();\n  }\n  /**\n   * PBR Next properties.\n   */\n  // KHR_materials_emissive_strength\n  get emissiveStrength() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].emissiveIntensity;\n  }\n  setEmissiveStrength(emissiveStrength) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.emissiveIntensity = emissiveStrength;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_clearcoat\n  get clearcoatFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoat;\n  }\n  get clearcoatRoughnessFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoatRoughness;\n  }\n  get clearcoatTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Clearcoat);\n  }\n  get clearcoatRoughnessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.ClearcoatRoughness);\n  }\n  get clearcoatNormalTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.ClearcoatNormal);\n  }\n  get clearcoatNormalScale() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoatNormalScale.x;\n  }\n  setClearcoatFactor(clearcoatFactor) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.clearcoat = clearcoatFactor;\n    }\n    this[$onUpdate]();\n  }\n  setClearcoatRoughnessFactor(clearcoatRoughnessFactor) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.clearcoatRoughness = clearcoatRoughnessFactor;\n    }\n    this[$onUpdate]();\n  }\n  setClearcoatNormalScale(clearcoatNormalScale) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.clearcoatNormalScale = new Vector2(clearcoatNormalScale, clearcoatNormalScale);\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_ior\n  get ior() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].ior;\n  }\n  setIor(ior) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.ior = ior;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_sheen\n  get sheenColorFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].sheenColor.toArray();\n  }\n  get sheenColorTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenColor);\n  }\n  get sheenRoughnessFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].sheenRoughness;\n  }\n  get sheenRoughnessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenRoughness);\n  }\n  setSheenColorFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.sheenColor.set(color);\n      // Three.js GLTFExporter checks for internal sheen value.\n      material.sheen = 1;\n    }\n    this[$onUpdate]();\n  }\n  setSheenRoughnessFactor(roughness) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.sheenRoughness = roughness;\n      // Three.js GLTFExporter checks for internal sheen value.\n      material.sheen = 1;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_transmission\n  get transmissionFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].transmission;\n  }\n  get transmissionTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Transmission);\n  }\n  setTransmissionFactor(transmission) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.transmission = transmission;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_volume\n  get thicknessFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].thickness;\n  }\n  get thicknessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Thickness);\n  }\n  get attenuationDistance() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].attenuationDistance;\n  }\n  get attenuationColor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].attenuationColor.toArray();\n  }\n  setThicknessFactor(thickness) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.thickness = thickness;\n    }\n    this[$onUpdate]();\n  }\n  setAttenuationDistance(attenuationDistance) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.attenuationDistance = attenuationDistance;\n    }\n    this[$onUpdate]();\n  }\n  setAttenuationColor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.attenuationColor.set(color);\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_specular\n  get specularFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].specularIntensity;\n  }\n  get specularTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Specular);\n  }\n  get specularColorFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].specularColor.toArray();\n  }\n  get specularColorTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenColor);\n  }\n  setSpecularFactor(specularFactor) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.specularIntensity = specularFactor;\n    }\n    this[$onUpdate]();\n  }\n  setSpecularColorFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.specularColor.set(color);\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_iridescence\n  get iridescenceFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescence;\n  }\n  get iridescenceTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Iridescence);\n  }\n  get iridescenceIor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceIOR;\n  }\n  get iridescenceThicknessMinimum() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceThicknessRange[0];\n  }\n  get iridescenceThicknessMaximum() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceThicknessRange[1];\n  }\n  get iridescenceThicknessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.IridescenceThickness);\n  }\n  setIridescenceFactor(iridescence) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescence = iridescence;\n    }\n    this[$onUpdate]();\n  }\n  setIridescenceIor(ior) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescenceIOR = ior;\n    }\n    this[$onUpdate]();\n  }\n  setIridescenceThicknessMinimum(thicknessMin) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescenceThicknessRange[0] = thicknessMin;\n    }\n    this[$onUpdate]();\n  }\n  setIridescenceThicknessMaximum(thicknessMax) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescenceThicknessRange[1] = thicknessMax;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_anisotropy\n  get anisotropyStrength() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].anisotropy;\n  }\n  get anisotropyRotation() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].anisotropyRotation;\n  }\n  get anisotropyTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Anisotropy);\n  }\n  setAnisotropyStrength(strength) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.anisotropy = strength;\n    }\n    this[$onUpdate]();\n  }\n  setAnisotropyRotation(rotation) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.anisotropyRotation = rotation;\n    }\n    this[$onUpdate]();\n  }\n}","map":{"version":3,"names":["Color","DoubleSide","FrontSide","Vector2","PBRMetallicRoughness","TextureInfo","TextureUsage","$correlatedObjects","$onUpdate","ThreeDOMElement","$pbrMetallicRoughness","Symbol","$normalTexture","$occlusionTexture","$emissiveTexture","$backingThreeMaterial","$applyAlphaCutoff","$getAlphaMode","$lazyLoadGLTFInfo","$initialize","$getLoadedMaterial","$ensureMaterialIsLoaded","$gltfIndex","$setActive","$variantIndices","$isActive","$variantSet","$modelVariants","$name","$pbrTextures","Material","constructor","onUpdate","gltfIndex","isActive","modelVariants","correlatedMaterials","name","lazyLoadInfo","undefined","_a","Set","_b","Map","values","next","value","normalMap","aoMap","emissiveMap","Normal","Occlusion","Emissive","createTextureInfo","usage","set","Clearcoat","ClearcoatRoughness","ClearcoatNormal","SheenColor","SheenRoughness","Transmission","Thickness","Specular","SpecularColor","Iridescence","IridescenceThickness","Anisotropy","material","doLazyLoad","ensureLoaded","colorFromRgb","rgb","color","Array","fromArray","Error","isLoaded","threeMaterial","pbrMetallicRoughness","normalTexture","occlusionTexture","emissiveTexture","emissiveFactor","emissive","toArray","index","hasVariant","variantData","get","has","setEmissiveFactor","transparent","alphaTest","needsUpdate","setAlphaCutoff","cutoff","getAlphaCutoff","setDoubleSided","doubleSided","side","getDoubleSided","setAlphaMode","alphaMode","enableTransparency","enabled","depthWrite","getAlphaMode","emissiveStrength","emissiveIntensity","setEmissiveStrength","clearcoatFactor","clearcoat","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatTexture","clearcoatRoughnessTexture","clearcoatNormalTexture","clearcoatNormalScale","x","setClearcoatFactor","setClearcoatRoughnessFactor","setClearcoatNormalScale","ior","setIor","sheenColorFactor","sheenColor","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenRoughnessTexture","setSheenColorFactor","sheen","setSheenRoughnessFactor","roughness","transmissionFactor","transmission","transmissionTexture","setTransmissionFactor","thicknessFactor","thickness","thicknessTexture","attenuationDistance","attenuationColor","setThicknessFactor","setAttenuationDistance","setAttenuationColor","specularFactor","specularIntensity","specularTexture","specularColorFactor","specularColor","specularColorTexture","setSpecularFactor","setSpecularColorFactor","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessTexture","setIridescenceFactor","setIridescenceIor","setIridescenceThicknessMinimum","thicknessMin","setIridescenceThicknessMaximum","thicknessMax","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","setAnisotropyStrength","strength","setAnisotropyRotation","rotation"],"sources":["../../../src/features/scene-graph/material.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Color, ColorRepresentation, DoubleSide, FrontSide, MeshPhysicalMaterial, Vector2} from 'three';\n\nimport {AlphaMode, RGB} from '../../three-components/gltf-instance/gltf-2.0.js';\n\nimport {Material as MaterialInterface} from './api.js';\nimport {LazyLoader, VariantData} from './model.js';\nimport {PBRMetallicRoughness} from './pbr-metallic-roughness.js';\nimport {TextureInfo, TextureUsage} from './texture-info.js';\nimport {$correlatedObjects, $onUpdate, ThreeDOMElement} from './three-dom-element.js';\n\n\n\nconst $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');\nconst $normalTexture = Symbol('normalTexture');\nconst $occlusionTexture = Symbol('occlusionTexture');\nconst $emissiveTexture = Symbol('emissiveTexture');\nconst $backingThreeMaterial = Symbol('backingThreeMaterial');\nconst $applyAlphaCutoff = Symbol('applyAlphaCutoff');\nconst $getAlphaMode = Symbol('getAlphaMode');\nexport const $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');\nconst $initialize = Symbol('initialize');\nexport const $getLoadedMaterial = Symbol('getLoadedMaterial');\nexport const $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');\nexport const $gltfIndex = Symbol('gltfIndex');\nexport const $setActive = Symbol('setActive');\nexport const $variantIndices = Symbol('variantIndices');\nconst $isActive = Symbol('isActive');\nexport const $variantSet = Symbol('variantSet');\nconst $modelVariants = Symbol('modelVariants');\nconst $name = Symbol('name');\nconst $pbrTextures = Symbol('pbrTextures');\n\n/**\n * Material facade implementation for Three.js materials\n */\nexport class Material extends ThreeDOMElement implements MaterialInterface {\n  private[$pbrMetallicRoughness]!: PBRMetallicRoughness;\n  private[$normalTexture]!: TextureInfo;\n  private[$occlusionTexture]!: TextureInfo;\n  private[$emissiveTexture]!: TextureInfo;\n  private[$lazyLoadGLTFInfo]?: LazyLoader;\n  private[$gltfIndex]: number;\n  private[$isActive]: boolean;\n  private[$variantSet] = new Set<number>();\n  private[$name]?: string;\n  readonly[$modelVariants]: Map<string, VariantData>;\n  private[$pbrTextures] = new Map<TextureUsage, TextureInfo>();\n\n  get[$backingThreeMaterial](): MeshPhysicalMaterial {\n    return (this[$correlatedObjects] as Set<MeshPhysicalMaterial>)\n        .values()\n        .next()\n        .value;\n  }\n\n  constructor(\n      onUpdate: () => void,\n      gltfIndex: number,\n      isActive: boolean,\n      modelVariants: Map<string, VariantData>,\n      correlatedMaterials: Set<MeshPhysicalMaterial>,\n      name: string|undefined,\n      lazyLoadInfo: LazyLoader|undefined = undefined,\n  ) {\n    super(onUpdate, correlatedMaterials);\n    this[$gltfIndex] = gltfIndex;\n    this[$isActive] = isActive;\n    this[$modelVariants] = modelVariants;\n    this[$name] = name;\n\n    if (lazyLoadInfo == null) {\n      this[$initialize]();\n    } else {\n      this[$lazyLoadGLTFInfo] = lazyLoadInfo;\n    }\n  }\n\n  private[$initialize](): void {\n    const onUpdate = this[$onUpdate] as () => void;\n    const correlatedMaterials =\n        this[$correlatedObjects] as Set<MeshPhysicalMaterial>;\n\n    this[$pbrMetallicRoughness] =\n        new PBRMetallicRoughness(onUpdate, correlatedMaterials);\n\n    const {normalMap, aoMap, emissiveMap} =\n        correlatedMaterials.values().next().value;\n\n    this[$normalTexture] = new TextureInfo(\n        onUpdate,\n        TextureUsage.Normal,\n        normalMap,\n        correlatedMaterials,\n    );\n\n    this[$occlusionTexture] = new TextureInfo(\n        onUpdate,\n        TextureUsage.Occlusion,\n        aoMap,\n        correlatedMaterials,\n    );\n\n    this[$emissiveTexture] = new TextureInfo(\n        onUpdate,\n        TextureUsage.Emissive,\n        emissiveMap,\n        correlatedMaterials,\n    );\n\n    const createTextureInfo = (usage: TextureUsage) => {\n      this[$pbrTextures].set(\n          usage,\n          new TextureInfo(\n              onUpdate,\n              usage,\n              null,\n              correlatedMaterials,\n              ));\n    };\n\n    createTextureInfo(TextureUsage.Clearcoat);\n    createTextureInfo(TextureUsage.ClearcoatRoughness);\n    createTextureInfo(TextureUsage.ClearcoatNormal);\n    createTextureInfo(TextureUsage.SheenColor);\n    createTextureInfo(TextureUsage.SheenRoughness);\n    createTextureInfo(TextureUsage.Transmission);\n    createTextureInfo(TextureUsage.Thickness);\n    createTextureInfo(TextureUsage.Specular);\n    createTextureInfo(TextureUsage.SpecularColor);\n    createTextureInfo(TextureUsage.Iridescence);\n    createTextureInfo(TextureUsage.IridescenceThickness);\n    createTextureInfo(TextureUsage.Anisotropy);\n  }\n\n  async[$getLoadedMaterial](): Promise<MeshPhysicalMaterial> {\n    if (this[$lazyLoadGLTFInfo] != null) {\n      const {set, material} = await this[$lazyLoadGLTFInfo]!.doLazyLoad();\n\n      // Fills in the missing data.\n      this[$correlatedObjects] = set as Set<MeshPhysicalMaterial>;\n\n      this[$initialize]();\n      // Releases lazy load info.\n      this[$lazyLoadGLTFInfo] = undefined;\n      // Redefines the method as a noop method.\n      this.ensureLoaded = async () => {};\n      return material as MeshPhysicalMaterial;\n    }\n    return this[$correlatedObjects]!.values().next().value;\n  }\n\n  private colorFromRgb(rgb: RGB|string): Color {\n    const color = new Color();\n    if (rgb instanceof Array) {\n      color.fromArray(rgb);\n    } else {\n      color.set(rgb as ColorRepresentation);\n    }\n    return color;\n  }\n\n  [$ensureMaterialIsLoaded]() {\n    if (this[$lazyLoadGLTFInfo] == null) {\n      return;\n    }\n    throw new Error(`Material \"${this.name}\" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`);\n  }\n\n  async ensureLoaded() {\n    await this[$getLoadedMaterial]();\n  }\n\n  get isLoaded() {\n    return this[$lazyLoadGLTFInfo] == null;\n  }\n\n  get isActive(): boolean {\n    return this[$isActive];\n  }\n\n  [$setActive](isActive: boolean) {\n    this[$isActive] = isActive;\n  }\n\n  get name(): string {\n    return this[$name] || '';\n  }\n\n  set name(name: string) {\n    this[$name] = name;\n    if (this[$correlatedObjects] != null) {\n      for (const threeMaterial of this[$correlatedObjects]!) {\n        threeMaterial.name = name;\n      }\n    }\n  }\n\n  get pbrMetallicRoughness(): PBRMetallicRoughness {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrMetallicRoughness];\n  }\n\n  get normalTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$normalTexture];\n  }\n\n  get occlusionTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$occlusionTexture];\n  }\n\n  get emissiveTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$emissiveTexture];\n  }\n\n  get emissiveFactor(): RGB {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$backingThreeMaterial].emissive.toArray() as RGB);\n  }\n\n  get index(): number {\n    return this[$gltfIndex];\n  }\n\n  [$variantIndices]() {\n    return this[$variantSet];\n  }\n\n  hasVariant(name: string): boolean {\n    const variantData = this[$modelVariants].get(name);\n    return variantData != null && this[$variantSet].has(variantData.index);\n  }\n\n  setEmissiveFactor(rgb: RGB|string) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.emissive.set(color);\n    }\n    this[$onUpdate]();\n  }\n\n  [$getAlphaMode](): string {\n    // Follows implementation of GLTFExporter from three.js\n    if (this[$backingThreeMaterial].transparent) {\n      return 'BLEND';\n    } else {\n      if (this[$backingThreeMaterial].alphaTest > 0.0) {\n        return 'MASK';\n      }\n    }\n    return 'OPAQUE';\n  }\n\n  [$applyAlphaCutoff]() {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      if (this[$getAlphaMode]() === 'MASK') {\n        if (material.alphaTest == undefined) {\n          material.alphaTest = 0.5;\n        }\n      } else {\n        (material.alphaTest as number | undefined) = undefined;\n      }\n\n      material.needsUpdate = true;\n    }\n  }\n\n  setAlphaCutoff(cutoff: number): void {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.alphaTest = cutoff;\n      material.needsUpdate = true;\n    }\n    // Set AlphaCutoff to undefined if AlphaMode is not MASK.\n    this[$applyAlphaCutoff]();\n    this[$onUpdate]();\n  }\n\n  getAlphaCutoff(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].alphaTest;\n  }\n\n  setDoubleSided(doubleSided: boolean): void {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      // When double-sided is disabled gltf spec dictates that Back-Face culling\n      // must be disabled, in three.js parlance that would mean FrontSide\n      // rendering only.\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided\n      material.side = doubleSided ? DoubleSide : FrontSide;\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n\n  getDoubleSided(): boolean {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].side == DoubleSide;\n  }\n\n  setAlphaMode(alphaMode: AlphaMode): void {\n    this[$ensureMaterialIsLoaded]();\n    const enableTransparency =\n        (material: MeshPhysicalMaterial, enabled: boolean): void => {\n          material.transparent = enabled;\n          material.depthWrite = !enabled;\n        };\n\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      enableTransparency(material, alphaMode === 'BLEND');\n      if (alphaMode === 'MASK') {\n        material.alphaTest = 0.5;\n      } else {\n        (material.alphaTest as number | undefined) = undefined;\n      }\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n\n  getAlphaMode(): AlphaMode {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$getAlphaMode]() as AlphaMode);\n  }\n\n  /**\n   * PBR Next properties.\n   */\n\n  // KHR_materials_emissive_strength\n  get emissiveStrength(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].emissiveIntensity;\n  }\n\n  setEmissiveStrength(emissiveStrength: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.emissiveIntensity = emissiveStrength;\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_clearcoat\n  get clearcoatFactor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoat;\n  }\n\n  get clearcoatRoughnessFactor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoatRoughness;\n  }\n\n  get clearcoatTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Clearcoat)!;\n  }\n\n  get clearcoatRoughnessTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.ClearcoatRoughness)!;\n  }\n\n  get clearcoatNormalTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.ClearcoatNormal)!;\n  }\n\n  get clearcoatNormalScale(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoatNormalScale.x;\n  }\n\n  setClearcoatFactor(clearcoatFactor: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.clearcoat = clearcoatFactor;\n    }\n    this[$onUpdate]();\n  }\n\n  setClearcoatRoughnessFactor(clearcoatRoughnessFactor: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.clearcoatRoughness = clearcoatRoughnessFactor;\n    }\n    this[$onUpdate]();\n  }\n\n  setClearcoatNormalScale(clearcoatNormalScale: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.clearcoatNormalScale =\n          new Vector2(clearcoatNormalScale, clearcoatNormalScale);\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_ior\n  get ior(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].ior;\n  }\n\n  setIor(ior: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.ior = ior;\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_sheen\n  get sheenColorFactor(): RGB {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$backingThreeMaterial].sheenColor.toArray() as RGB);\n  }\n  get sheenColorTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenColor)!;\n  }\n\n  get sheenRoughnessFactor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].sheenRoughness;\n  }\n\n  get sheenRoughnessTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenRoughness)!;\n  }\n\n  setSheenColorFactor(rgb: RGB|string) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.sheenColor.set(color);\n      // Three.js GLTFExporter checks for internal sheen value.\n      material.sheen = 1;\n    }\n    this[$onUpdate]();\n  }\n\n  setSheenRoughnessFactor(roughness: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.sheenRoughness = roughness;\n      // Three.js GLTFExporter checks for internal sheen value.\n      material.sheen = 1;\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_transmission\n  get transmissionFactor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].transmission;\n  }\n\n  get transmissionTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Transmission)!;\n  }\n\n  setTransmissionFactor(transmission: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.transmission = transmission;\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_volume\n  get thicknessFactor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].thickness;\n  }\n\n  get thicknessTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Thickness)!;\n  }\n\n  get attenuationDistance(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].attenuationDistance;\n  }\n\n  get attenuationColor(): RGB {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$backingThreeMaterial].attenuationColor.toArray() as RGB);\n  }\n\n  setThicknessFactor(thickness: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.thickness = thickness;\n    }\n    this[$onUpdate]();\n  }\n\n  setAttenuationDistance(attenuationDistance: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.attenuationDistance = attenuationDistance;\n    }\n    this[$onUpdate]();\n  }\n\n  setAttenuationColor(rgb: RGB|string) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.attenuationColor.set(color);\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_specular\n  get specularFactor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].specularIntensity;\n  }\n\n  get specularTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Specular)!;\n  }\n\n  get specularColorFactor(): RGB {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$backingThreeMaterial].specularColor.toArray() as RGB);\n  }\n\n  get specularColorTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenColor)!;\n  }\n\n  setSpecularFactor(specularFactor: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.specularIntensity = specularFactor;\n    }\n    this[$onUpdate]();\n  }\n\n  setSpecularColorFactor(rgb: RGB|string) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.specularColor.set(color);\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_iridescence\n  get iridescenceFactor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescence;\n  }\n\n  get iridescenceTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Iridescence)!;\n  }\n\n  get iridescenceIor(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceIOR;\n  }\n\n  get iridescenceThicknessMinimum(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceThicknessRange[0];\n  }\n\n  get iridescenceThicknessMaximum(): number {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceThicknessRange[1];\n  }\n\n  get iridescenceThicknessTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.IridescenceThickness)!;\n  }\n\n  setIridescenceFactor(iridescence: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.iridescence = iridescence;\n    }\n    this[$onUpdate]();\n  }\n\n  setIridescenceIor(ior: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.iridescenceIOR = ior;\n    }\n    this[$onUpdate]();\n  }\n\n  setIridescenceThicknessMinimum(thicknessMin: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.iridescenceThicknessRange[0] = thicknessMin;\n    }\n    this[$onUpdate]();\n  }\n\n  setIridescenceThicknessMaximum(thicknessMax: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      material.iridescenceThicknessRange[1] = thicknessMax;\n    }\n    this[$onUpdate]();\n  }\n\n  // KHR_materials_anisotropy\n  get anisotropyStrength(): number {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$backingThreeMaterial] as any).anisotropy;\n  }\n\n  get anisotropyRotation(): number {\n    this[$ensureMaterialIsLoaded]();\n    return (this[$backingThreeMaterial] as any).anisotropyRotation;\n  }\n\n  get anisotropyTexture(): TextureInfo {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Anisotropy)!;\n  }\n\n  setAnisotropyStrength(strength: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      (material as any).anisotropy = strength;\n    }\n    this[$onUpdate]();\n  }\n\n  setAnisotropyRotation(rotation: number) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects] as\n         Set<MeshPhysicalMaterial>) {\n      (material as any).anisotropyRotation = rotation;\n    }\n    this[$onUpdate]();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}