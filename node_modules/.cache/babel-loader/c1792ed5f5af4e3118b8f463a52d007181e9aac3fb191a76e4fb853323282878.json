{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { AnimationClip, AnimationMixer, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector3, VectorKeyframeTrack } from 'three';\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== undefined ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone: bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = new Map();\n  const cloneLookup = new Map();\n  const clone = source.clone();\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone;\n}\n\n// internal helper\n\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nexport { retarget, retargetClip, clone };","map":{"version":3,"names":["AnimationClip","AnimationMixer","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector3","VectorKeyframeTrack","retarget","target","source","options","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","pose","i","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","update","time","j","times","Float32Array","values","sub","toArray","uncacheAction","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","Array","isArray","a","b","callback"],"sources":["/Users/juangonzalez/Documents/GitHub/vue-project-kiwi/Clinet/node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = 1 / options.fps,\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.update( delta );\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}