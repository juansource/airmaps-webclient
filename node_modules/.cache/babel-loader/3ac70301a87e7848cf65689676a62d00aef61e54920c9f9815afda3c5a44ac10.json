{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d;\nimport { ASTWalker } from './parsers';\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance analyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n  constructor(callback) {\n    this[$scrollCallback] = callback;\n  }\n  static [$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n  static [(_a = $instances, $activateListener)]() {\n    window.addEventListener('scroll', this[$notifyInstances], {\n      passive: true\n    });\n  }\n  static [$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n    ScrollObserver[$instances].add(this);\n  }\n  /**\n   * Stop listening for scroll events.\n   */\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n  [$notify]() {\n    this[$scrollCallback]();\n  }\n}\nScrollObserver[_a] = new Set();\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\nconst $onScroll = Symbol('onScroll');\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nexport class StyleEffector {\n  constructor(callback) {\n    this[_b] = {};\n    this[_c] = new ASTWalker(['function']);\n    this[_d] = () => {\n      this[$computeStyleCallback]({\n        relatedState: 'window-scroll'\n      });\n    };\n    this[$computeStyleCallback] = callback;\n  }\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n  observeEffectsFor(ast) {\n    const newDependencies = {};\n    const oldDependencies = this[$dependencies];\n    this[$astWalker].walk(ast, functionNode => {\n      const {\n        name\n      } = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n      if (name.value !== 'env' || firstTerm == null || firstTerm.type !== 'ident') {\n        return;\n      }\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ? oldDependencies['window-scroll'] : new ScrollObserver(this[$onScroll]);\n            observer.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n          break;\n      }\n    });\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState];\n      observer.disconnect();\n    }\n    this[$dependencies] = newDependencies;\n  }\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer = this[$dependencies][environmentState];\n      observer.disconnect();\n    }\n  }\n}\n_b = $dependencies, _c = $astWalker, _d = $onScroll;","map":{"version":3,"names":["ASTWalker","$instances","Symbol","$activateListener","$deactivateListener","$notifyInstances","$notify","$scrollCallback","ScrollObserver","constructor","callback","instance","_a","window","addEventListener","passive","removeEventListener","observe","size","add","disconnect","delete","Set","$computeStyleCallback","$astWalker","$dependencies","$onScroll","StyleEffector","_b","_c","_d","relatedState","observeEffectsFor","ast","newDependencies","oldDependencies","walk","functionNode","name","firstArgument","arguments","firstTerm","terms","value","type","observer","environmentState","dispose"],"sources":["../../src/styles/style-effector.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ASTWalker, ExpressionNode, FunctionNode} from './parsers';\n\ninterface AnyObserver {\n  observe(): void;\n  disconnect(): void;\n}\n\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n\ntype ScrollObserverCallback = () => void;\n\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance analyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n  private static[$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n  private static[$instances]: Set<ScrollObserver> = new Set();\n  private static[$activateListener]() {\n    window.addEventListener('scroll', this[$notifyInstances], {passive: true});\n  }\n  private static[$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n\n  private[$scrollCallback]: ScrollObserverCallback;\n\n  constructor(callback: ScrollObserverCallback) {\n    this[$scrollCallback] = callback;\n  }\n\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n    ScrollObserver[$instances].add(this);\n  }\n\n  /**\n   * Stop listening for scroll events.\n   */\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n\n  private[$notify]() {\n    this[$scrollCallback]();\n  };\n}\n\n\nexport type EnvironmentState = 'window-scroll';\n\nexport type StyleEffectorCallback = (record: EnvironmentChangeRecord) => void;\nexport interface EnvironmentChangeRecord {\n  relatedState: EnvironmentState;\n}\n\ntype EnvironmentDependencies = {\n  [key in EnvironmentState]?: AnyObserver\n};\n\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\n\nconst $onScroll = Symbol('onScroll');\n\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nexport class StyleEffector {\n  protected[$dependencies]: EnvironmentDependencies = {};\n\n  protected[$computeStyleCallback]: StyleEffectorCallback;\n  protected[$astWalker] = new ASTWalker<FunctionNode>(['function']);\n\n  constructor(callback: StyleEffectorCallback) {\n    this[$computeStyleCallback] = callback;\n  }\n\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n  observeEffectsFor(ast: Array<ExpressionNode>) {\n    const newDependencies: EnvironmentDependencies = {};\n    const oldDependencies = this[$dependencies];\n\n    this[$astWalker].walk(ast, functionNode => {\n      const {name} = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n\n      if (name.value !== 'env' || firstTerm == null ||\n          firstTerm.type !== 'ident') {\n        return;\n      }\n\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ?\n                oldDependencies['window-scroll'] :\n                new ScrollObserver(this[$onScroll]);\n            observer!.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n          break;\n      }\n    });\n\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n\n    this[$dependencies] = newDependencies;\n  }\n\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer =\n          this[$dependencies][environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n  }\n\n  protected[$onScroll] = () => {\n    this[$computeStyleCallback]({relatedState: 'window-scroll'});\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}