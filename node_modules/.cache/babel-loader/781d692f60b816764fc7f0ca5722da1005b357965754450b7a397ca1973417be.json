{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { clamp } from '../utilities';\n// Adapted from https://gist.github.com/gre/1650294\nexport const easeInOutQuad = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n/**\n * Creates a TimingFunction that uses a given ease to interpolate between\n * two configured number values.\n */\nexport const interpolate = (start, end, ease = easeInOutQuad) => time => start + (end - start) * ease(time);\n/**\n * Creates a TimingFunction that interpolates through a weighted list\n * of other TimingFunctions (\"tracks\"). Tracks are interpolated in order, and\n * allocated a percentage of the total time based on their relative weight.\n */\nexport const sequence = (tracks, weights) => {\n  const cumulativeSum = sum => value => sum += value;\n  const times = weights.map(cumulativeSum(0));\n  return time => {\n    time = clamp(time, 0, 1);\n    time *= times[times.length - 1];\n    const i = times.findIndex(val => val >= time);\n    const start = i < 1 ? 0 : times[i - 1];\n    const end = times[i];\n    return tracks[i]((time - start) / (end - start));\n  };\n};\n/**\n * Creates a \"timeline\" TimingFunction out of an initial value and a series of\n * Keyframes. The timeline function accepts value from 0-1 and returns the\n * current value based on keyframe interpolation across the total number of\n * frames. Frames are only used to indicate the relative length of each keyframe\n * transition, so interpolated values will be computed for fractional frames.\n */\nexport const timeline = path => {\n  const tracks = [];\n  const weights = [];\n  let lastValue = path.initialValue;\n  for (let i = 0; i < path.keyframes.length; ++i) {\n    const keyframe = path.keyframes[i];\n    const {\n      value,\n      frames\n    } = keyframe;\n    const ease = keyframe.ease || easeInOutQuad;\n    const track = interpolate(lastValue, value, ease);\n    tracks.push(track);\n    weights.push(frames);\n    lastValue = value;\n  }\n  return sequence(tracks, weights);\n};","map":{"version":3,"names":["clamp","easeInOutQuad","t","interpolate","start","end","ease","time","sequence","tracks","weights","cumulativeSum","sum","value","times","map","length","i","findIndex","val","timeline","path","lastValue","initialValue","keyframes","keyframe","frames","track","push"],"sources":["../../src/utilities/animation.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {clamp} from '../utilities';\n\n// Adapted from https://gist.github.com/gre/1650294\nexport const easeInOutQuad: TimingFunction = (t: number) =>\n    t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\n/**\n * A TimingFunction accepts a value from 0-1 and returns a corresponding\n * interpolated value\n */\nexport type TimingFunction = (time: number) => number;\n\n/**\n * Creates a TimingFunction that uses a given ease to interpolate between\n * two configured number values.\n */\nexport const interpolate =\n    (start: number, end: number, ease: TimingFunction = easeInOutQuad):\n        TimingFunction => (time: number) => start + (end - start) * ease(time);\n\n/**\n * Creates a TimingFunction that interpolates through a weighted list\n * of other TimingFunctions (\"tracks\"). Tracks are interpolated in order, and\n * allocated a percentage of the total time based on their relative weight.\n */\nexport const sequence =\n    (tracks: Array<TimingFunction>, weights: Array<number>): TimingFunction => {\n      const cumulativeSum = ((sum: number) => (value: number) => sum += value);\n      const times = weights.map(cumulativeSum(0));\n\n      return (time: number) => {\n        time = clamp(time, 0, 1);\n        time *= times[times.length - 1];\n        const i = times.findIndex((val) => val >= time);\n\n        const start = i < 1 ? 0 : times[i - 1];\n        const end = times[i];\n\n        return tracks[i]((time - start) / (end - start));\n      }\n    };\n\n/**\n * A Frame groups a target value, the number of frames to interpolate towards\n * that value and an optional easing function to use for interpolation.\n */\nexport interface Frame {\n  value: number;\n  frames: number;\n  ease?: TimingFunction;\n}\n\nexport interface Path {\n  initialValue: number;\n  keyframes: Frame[];\n}\n\n/**\n * Creates a \"timeline\" TimingFunction out of an initial value and a series of\n * Keyframes. The timeline function accepts value from 0-1 and returns the\n * current value based on keyframe interpolation across the total number of\n * frames. Frames are only used to indicate the relative length of each keyframe\n * transition, so interpolated values will be computed for fractional frames.\n */\nexport const timeline = (path: Path): TimingFunction => {\n  const tracks: Array<TimingFunction> = [];\n  const weights: Array<number> = [];\n\n  let lastValue = path.initialValue;\n\n  for (let i = 0; i < path.keyframes.length; ++i) {\n    const keyframe = path.keyframes[i];\n    const {value, frames} = keyframe;\n    const ease = keyframe.ease || easeInOutQuad;\n    const track = interpolate(lastValue, value, ease);\n\n    tracks.push(track);\n    weights.push(frames);\n    lastValue = value;\n  }\n\n  return sequence(tracks, weights);\n};\n"],"mappings":";AAAA;;;;;;;;;;;;;;AAeA,SAAQA,KAAK,QAAO,cAAc;AAElC;AACA,OAAO,MAAMC,aAAa,GAAoBC,CAAS,IACnDA,CAAC,GAAG,EAAE,GAAG,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAGA,CAAC,IAAIA,CAAC;AAQ7C;;;;AAIA,OAAO,MAAMC,WAAW,GACpBA,CAACC,KAAa,EAAEC,GAAW,EAAEC,IAAA,GAAuBL,aAAa,KAC1CM,IAAY,IAAKH,KAAK,GAAG,CAACC,GAAG,GAAGD,KAAK,IAAIE,IAAI,CAACC,IAAI,CAAC;AAE9E;;;;;AAKA,OAAO,MAAMC,QAAQ,GACjBA,CAACC,MAA6B,EAAEC,OAAsB,KAAoB;EACxE,MAAMC,aAAa,GAAKC,GAAW,IAAMC,KAAa,IAAKD,GAAG,IAAIC,KAAM;EACxE,MAAMC,KAAK,GAAGJ,OAAO,CAACK,GAAG,CAACJ,aAAa,CAAC,CAAC,CAAC,CAAC;EAE3C,OAAQJ,IAAY,IAAI;IACtBA,IAAI,GAAGP,KAAK,CAACO,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;IACxBA,IAAI,IAAIO,KAAK,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;IAC/B,MAAMC,CAAC,GAAGH,KAAK,CAACI,SAAS,CAAEC,GAAG,IAAKA,GAAG,IAAIZ,IAAI,CAAC;IAE/C,MAAMH,KAAK,GAAGa,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGH,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC;IACtC,MAAMZ,GAAG,GAAGS,KAAK,CAACG,CAAC,CAAC;IAEpB,OAAOR,MAAM,CAACQ,CAAC,CAAC,CAAC,CAACV,IAAI,GAAGH,KAAK,KAAKC,GAAG,GAAGD,KAAK,CAAC,CAAC;EAClD,CAAC;AACH,CAAC;AAiBL;;;;;;;AAOA,OAAO,MAAMgB,QAAQ,GAAIC,IAAU,IAAoB;EACrD,MAAMZ,MAAM,GAA0B,EAAE;EACxC,MAAMC,OAAO,GAAkB,EAAE;EAEjC,IAAIY,SAAS,GAAGD,IAAI,CAACE,YAAY;EAEjC,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,IAAI,CAACG,SAAS,CAACR,MAAM,EAAE,EAAEC,CAAC,EAAE;IAC9C,MAAMQ,QAAQ,GAAGJ,IAAI,CAACG,SAAS,CAACP,CAAC,CAAC;IAClC,MAAM;MAACJ,KAAK;MAAEa;IAAM,CAAC,GAAGD,QAAQ;IAChC,MAAMnB,IAAI,GAAGmB,QAAQ,CAACnB,IAAI,IAAIL,aAAa;IAC3C,MAAM0B,KAAK,GAAGxB,WAAW,CAACmB,SAAS,EAAET,KAAK,EAAEP,IAAI,CAAC;IAEjDG,MAAM,CAACmB,IAAI,CAACD,KAAK,CAAC;IAClBjB,OAAO,CAACkB,IAAI,CAACF,MAAM,CAAC;IACpBJ,SAAS,GAAGT,KAAK;;EAGnB,OAAOL,QAAQ,CAACC,MAAM,EAAEC,OAAO,CAAC;AAClC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}