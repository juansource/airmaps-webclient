{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { CanvasTexture, RepeatWrapping, SRGBColorSpace, VideoTexture } from 'three';\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\nimport { $needsRender, $onModelLoad, $progressTracker, $renderer, $scene } from '../model-viewer-base.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin';\nimport { $availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model } from './scene-graph/model.js';\nimport { Texture as ModelViewerTexture } from './scene-graph/texture';\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $buildTexture = Symbol('buildTexture');\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = ModelViewerElement => {\n  var _a, _b, _c;\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = undefined;\n      this[_b] = null;\n      this[_c] = null;\n      this.variantName = null;\n      this.orientation = '0 0 0';\n      this.scale = '1 1 1';\n    }\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n    get availableVariants() {\n      return this.model ? this.model[$availableVariants]() : [];\n    }\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n    [(_a = $model, _b = $currentGLTF, _c = $originalGltfJson, $getOnUpdateMethod)]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n    [$buildTexture](texture) {\n      // Applies glTF default settings.\n      texture.colorSpace = SRGBColorSpace;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n    }\n    async createTexture(uri, type = 'image/png') {\n      const {\n        textureUtils\n      } = this[$renderer];\n      const texture = await textureUtils.loadImage(uri);\n      texture.userData.mimeType = type;\n      return this[$buildTexture](texture);\n    }\n    async createLottieTexture(uri, quality = 1) {\n      const {\n        textureUtils\n      } = this[$renderer];\n      const texture = await textureUtils.loadLottie(uri, quality);\n      return this[$buildTexture](texture);\n    }\n    createVideoTexture(uri) {\n      const video = document.createElement('video');\n      video.src = uri;\n      video.muted = true;\n      video.playsInline = true;\n      video.loop = true;\n      video.play();\n      const texture = new VideoTexture(video);\n      return this[$buildTexture](texture);\n    }\n    createCanvasTexture() {\n      const canvas = document.createElement('canvas');\n      const texture = new CanvasTexture(canvas);\n      return this[$buildTexture](texture);\n    }\n    async updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('variantName')) {\n        const updateVariantProgress = this[$progressTracker].beginActivity();\n        updateVariantProgress(0.1);\n        const model = this[$model];\n        const {\n          variantName\n        } = this;\n        if (model != null) {\n          await model[$switchVariant](variantName);\n          this[$needsRender]();\n          this.dispatchEvent(new CustomEvent('variant-applied'));\n        }\n        updateVariantProgress(1.0);\n      }\n      if (changedProperties.has('orientation') || changedProperties.has('scale')) {\n        if (!this.loaded) {\n          return;\n        }\n        const scene = this[$scene];\n        scene.applyTransform();\n        scene.updateBoundingBox();\n        scene.updateShadow();\n        this[$renderer].arRenderer.onUpdateScene();\n        this[$needsRender]();\n      }\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      const {\n        currentGLTF\n      } = this[$scene];\n      if (currentGLTF != null) {\n        const {\n          correlatedSceneGraph\n        } = currentGLTF;\n        if (correlatedSceneGraph != null && currentGLTF !== this[$currentGLTF]) {\n          this[$model] = new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] = JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        }\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n        if ('variants' in currentGLTF.userData) {\n          this.requestUpdate('variantName');\n        }\n      }\n      this[$currentGLTF] = currentGLTF;\n    }\n    /** @export */\n    async exportScene(options) {\n      const scene = this[$scene];\n      return new Promise(async (resolve, reject) => {\n        // Defaults\n        const opts = {\n          binary: true,\n          onlyVisible: true,\n          maxTextureSize: Infinity,\n          includeCustomExtensions: false,\n          forceIndices: false\n        };\n        Object.assign(opts, options);\n        // Not configurable\n        opts.animations = scene.animations;\n        opts.truncateDrawRange = true;\n        const shadow = scene.shadow;\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n        await this[$model][$prepareVariantsForExport]();\n        const exporter = new GLTFExporter().register(writer => new GLTFExporterMaterialsVariantsExtension(writer));\n        exporter.parse(scene.model, gltf => {\n          return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {\n            type: opts.binary ? 'application/octet-stream' : 'application/json'\n          }));\n        }, () => {\n          return reject('glTF export failed');\n        }, opts);\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n      });\n    }\n    materialFromPoint(pixelX, pixelY) {\n      const model = this[$model];\n      if (model == null) {\n        return null;\n      }\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      const hit = scene.hitFromPoint(ndcCoords);\n      if (hit == null || hit.face == null) {\n        return null;\n      }\n      return model[$materialFromPoint](hit);\n    }\n  }\n  __decorate([property({\n    type: String,\n    attribute: 'variant-name'\n  })], SceneGraphModelViewerElement.prototype, \"variantName\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'orientation'\n  })], SceneGraphModelViewerElement.prototype, \"orientation\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'scale'\n  })], SceneGraphModelViewerElement.prototype, \"scale\", void 0);\n  return SceneGraphModelViewerElement;\n};","map":{"version":3,"names":["property","CanvasTexture","RepeatWrapping","SRGBColorSpace","VideoTexture","GLTFExporter","$needsRender","$onModelLoad","$progressTracker","$renderer","$scene","GLTFExporterMaterialsVariantsExtension","$availableVariants","$materialFromPoint","$prepareVariantsForExport","$switchVariant","Model","Texture","ModelViewerTexture","$currentGLTF","Symbol","$originalGltfJson","$model","$getOnUpdateMethod","$buildTexture","SceneGraphMixin","ModelViewerElement","SceneGraphModelViewerElement","constructor","_a","undefined","_b","_c","variantName","orientation","scale","model","availableVariants","originalGltfJson","texture","colorSpace","wrapS","wrapT","createTexture","uri","type","textureUtils","loadImage","userData","mimeType","createLottieTexture","quality","loadLottie","createVideoTexture","video","document","createElement","src","muted","playsInline","loop","play","createCanvasTexture","canvas","updated","changedProperties","has","updateVariantProgress","beginActivity","dispatchEvent","CustomEvent","loaded","scene","applyTransform","updateBoundingBox","updateShadow","arRenderer","onUpdateScene","currentGLTF","correlatedSceneGraph","JSON","parse","stringify","gltf","requestUpdate","exportScene","options","Promise","resolve","reject","opts","binary","onlyVisible","maxTextureSize","Infinity","includeCustomExtensions","forceIndices","Object","assign","animations","truncateDrawRange","shadow","visible","exporter","register","writer","Blob","materialFromPoint","pixelX","pixelY","ndcCoords","getNDC","hit","hitFromPoint","face","__decorate","String","attribute"],"sources":["../../src/features/scene-graph.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit/decorators.js';\nimport {CanvasTexture, RepeatWrapping, SRGBColorSpace, Texture, VideoTexture} from 'three';\nimport {GLTFExporter, GLTFExporterOptions} from 'three/examples/jsm/exporters/GLTFExporter.js';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $progressTracker, $renderer, $scene} from '../model-viewer-base.js';\nimport {GLTF} from '../three-components/gltf-instance/gltf-defaulted.js';\nimport {ModelViewerGLTFInstance} from '../three-components/gltf-instance/ModelViewerGLTFInstance.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin';\nimport {Constructor} from '../utilities.js';\n\nimport {Image, PBRMetallicRoughness, Sampler, TextureInfo} from './scene-graph/api.js';\nimport {Material} from './scene-graph/material.js';\nimport {$availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model} from './scene-graph/model.js';\nimport {Texture as ModelViewerTexture} from './scene-graph/texture';\n\n\n\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $buildTexture = Symbol('buildTexture');\n\ninterface SceneExportOptions {\n  binary?: boolean, trs?: boolean, onlyVisible?: boolean,\n      maxTextureSize?: number, includeCustomExtensions?: boolean,\n      forceIndices?: boolean\n}\n\nexport interface SceneGraphInterface {\n  readonly model?: Model;\n  variantName: string|null;\n  readonly availableVariants: string[];\n  orientation: string;\n  scale: string;\n  readonly originalGltfJson: GLTF|null;\n  exportScene(options?: SceneExportOptions): Promise<Blob>;\n  createTexture(uri: string, type?: string): Promise<ModelViewerTexture|null>;\n  createLottieTexture(uri: string, quality?: number):\n      Promise<ModelViewerTexture|null>;\n  createVideoTexture(uri: string): ModelViewerTexture;\n  createCanvasTexture(): ModelViewerTexture;\n  /**\n   * Intersects a ray with the scene and returns a list of materials who's\n   * objects were intersected.\n   * @param pixelX X coordinate of the mouse.\n   * @param pixelY Y coordinate of the mouse.\n   * @returns a material, if no intersection is made then null is returned.\n   */\n  materialFromPoint(pixelX: number, pixelY: number): Material|null;\n}\n\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<SceneGraphInterface>&T => {\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    protected[$model]: Model|undefined = undefined;\n    protected[$currentGLTF]: ModelViewerGLTFInstance|null = null;\n    private[$originalGltfJson]: GLTF|null = null;\n\n    @property({type: String, attribute: 'variant-name'})\n    variantName: string|null = null;\n\n    @property({type: String, attribute: 'orientation'})\n    orientation: string = '0 0 0';\n\n    @property({type: String, attribute: 'scale'}) scale: string = '1 1 1';\n\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n\n    get availableVariants() {\n      return this.model ? this.model[$availableVariants]() : [] as string[];\n    }\n\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n\n    /**\n     * References to each element constructor. Supports instanceof checks; these\n     * classes are not directly constructable.\n     */\n    static Model: Constructor<Model>;\n    static Material: Constructor<Material>;\n    static PBRMetallicRoughness: Constructor<PBRMetallicRoughness>;\n    static Sampler: Constructor<Sampler>;\n    static TextureInfo: Constructor<TextureInfo>;\n    static Texture: Constructor<Texture>;\n    static Image: Constructor<Image>;\n\n    private[$getOnUpdateMethod]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n\n    private[$buildTexture](texture: Texture): ModelViewerTexture {\n      // Applies glTF default settings.\n      texture.colorSpace = SRGBColorSpace;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n    }\n\n    async createTexture(uri: string, type: string = 'image/png'):\n        Promise<ModelViewerTexture> {\n      const {textureUtils} = this[$renderer];\n      const texture = await textureUtils!.loadImage(uri);\n\n      texture.userData.mimeType = type;\n\n      return this[$buildTexture](texture);\n    }\n\n    async createLottieTexture(uri: string, quality = 1):\n        Promise<ModelViewerTexture> {\n      const {textureUtils} = this[$renderer];\n      const texture = await textureUtils!.loadLottie(uri, quality);\n\n      return this[$buildTexture](texture);\n    }\n\n    createVideoTexture(uri: string): ModelViewerTexture {\n      const video = document.createElement('video');\n      video.src = uri;\n      video.muted = true;\n      video.playsInline = true;\n      video.loop = true;\n      video.play();\n      const texture = new VideoTexture(video);\n\n      return this[$buildTexture](texture);\n    }\n\n    createCanvasTexture(): ModelViewerTexture {\n      const canvas = document.createElement('canvas');\n      const texture = new CanvasTexture(canvas);\n\n      return this[$buildTexture](texture);\n    }\n\n    async updated(changedProperties: Map<string, any>) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('variantName')) {\n        const updateVariantProgress = this[$progressTracker].beginActivity();\n        updateVariantProgress(0.1);\n        const model = this[$model];\n        const {variantName} = this;\n\n        if (model != null) {\n          await model[$switchVariant](variantName!);\n          this[$needsRender]();\n          this.dispatchEvent(new CustomEvent('variant-applied'));\n        }\n        updateVariantProgress(1.0);\n      }\n\n      if (changedProperties.has('orientation') ||\n          changedProperties.has('scale')) {\n        if (!this.loaded) {\n          return;\n        }\n        const scene = this[$scene];\n        scene.applyTransform();\n        scene.updateBoundingBox();\n        scene.updateShadow();\n        this[$renderer].arRenderer.onUpdateScene();\n        this[$needsRender]();\n      }\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      const {currentGLTF} = this[$scene];\n\n      if (currentGLTF != null) {\n        const {correlatedSceneGraph} = currentGLTF;\n\n        if (correlatedSceneGraph != null &&\n            currentGLTF !== this[$currentGLTF]) {\n          this[$model] =\n              new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] =\n              JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        }\n\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n\n        if ('variants' in currentGLTF.userData) {\n          this.requestUpdate('variantName');\n        }\n      }\n\n      this[$currentGLTF] = currentGLTF;\n    }\n\n    /** @export */\n    async exportScene(options?: SceneExportOptions): Promise<Blob> {\n      const scene = this[$scene];\n      return new Promise<Blob>(async (resolve, reject) => {\n        // Defaults\n        const opts = {\n          binary: true,\n          onlyVisible: true,\n          maxTextureSize: Infinity,\n          includeCustomExtensions: false,\n          forceIndices: false\n        } as GLTFExporterOptions;\n\n        Object.assign(opts, options);\n        // Not configurable\n        opts.animations = scene.animations;\n        opts.truncateDrawRange = true;\n\n        const shadow = scene.shadow;\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n\n        await this[$model]![$prepareVariantsForExport]();\n\n        const exporter =\n            (new GLTFExporter() as any)\n                .register(\n                    (writer: any) =>\n                        new GLTFExporterMaterialsVariantsExtension(writer));\n        exporter.parse(\n            scene.model,\n            (gltf: object) => {\n              return resolve(new Blob(\n                  [opts.binary ? gltf as Blob : JSON.stringify(gltf)], {\n                    type: opts.binary ? 'application/octet-stream' :\n                                        'application/json'\n                  }));\n            },\n            () => {\n              return reject('glTF export failed');\n            },\n            opts);\n\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n      });\n    }\n\n    materialFromPoint(pixelX: number, pixelY: number): Material|null {\n      const model = this[$model];\n      if (model == null) {\n        return null;\n      }\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      const hit = scene.hitFromPoint(ndcCoords);\n      if (hit == null || hit.face == null) {\n        return null;\n      }\n\n      return model[$materialFromPoint](hit);\n    }\n  }\n\n  return SceneGraphModelViewerElement;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}