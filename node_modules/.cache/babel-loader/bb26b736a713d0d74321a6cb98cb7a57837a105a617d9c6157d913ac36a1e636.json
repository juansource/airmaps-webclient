{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\nimport { EventDispatcher, Texture } from 'three';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { KTX2Loader } from 'three/examples/jsm/loaders/KTX2Loader.js';\nimport { CacheEvictionPolicy } from '../utilities/cache-eviction-policy.js';\nimport GLTFMaterialsVariantsExtension from './gltf-instance/VariantMaterialLoaderPlugin';\nTexture.DEFAULT_ANISOTROPY = 4;\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\nexport const loadWithLoader = (url, loader, progressCallback = () => {}) => {\n  const onProgress = event => {\n    const fraction = event.loaded / event.total;\n    progressCallback(Math.max(0, Math.min(1, isFinite(fraction) ? fraction : 1)));\n  };\n  return new Promise((resolve, reject) => {\n    loader.load(url, resolve, onProgress, reject);\n  });\n};\n/** Helper to load a script tag. */\nconst fetchScript = src => {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    document.body.appendChild(script);\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = src;\n  });\n};\nconst cache = new Map();\nconst preloaded = new Map();\nlet dracoDecoderLocation;\nconst dracoLoader = new DRACOLoader();\nlet ktx2TranscoderLocation;\nconst ktx2Loader = new KTX2Loader();\nlet meshoptDecoderLocation;\nlet meshoptDecoder;\nexport const $loader = Symbol('loader');\nexport const $evictionPolicy = Symbol('evictionPolicy');\nconst $GLTFInstance = Symbol('GLTFInstance');\nexport class CachingGLTFLoader extends EventDispatcher {\n  constructor(GLTFInstance) {\n    super();\n    this[_b] = new GLTFLoader().register(parser => new GLTFMaterialsVariantsExtension(parser));\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n    this[$loader].setKTX2Loader(ktx2Loader);\n  }\n  static setDRACODecoderLocation(url) {\n    dracoDecoderLocation = url;\n    dracoLoader.setDecoderPath(url);\n  }\n  static getDRACODecoderLocation() {\n    return dracoDecoderLocation;\n  }\n  static setKTX2TranscoderLocation(url) {\n    ktx2TranscoderLocation = url;\n    ktx2Loader.setTranscoderPath(url);\n  }\n  static getKTX2TranscoderLocation() {\n    return ktx2TranscoderLocation;\n  }\n  static setMeshoptDecoderLocation(url) {\n    if (meshoptDecoderLocation !== url) {\n      meshoptDecoderLocation = url;\n      meshoptDecoder = fetchScript(url).then(() => MeshoptDecoder.ready).then(() => MeshoptDecoder);\n    }\n  }\n  static getMeshoptDecoderLocation() {\n    return meshoptDecoderLocation;\n  }\n  static initializeKTX2Loader(renderer) {\n    ktx2Loader.detectSupport(renderer);\n  }\n  static get cache() {\n    return cache;\n  }\n  /** @nocollapse */\n  static clearCache() {\n    cache.forEach((_value, url) => {\n      this.delete(url);\n    });\n    this[$evictionPolicy].reset();\n  }\n  static has(url) {\n    return cache.has(url);\n  }\n  /** @nocollapse */\n  static async delete(url) {\n    if (!this.has(url)) {\n      return;\n    }\n    const gltfLoads = cache.get(url);\n    preloaded.delete(url);\n    cache.delete(url);\n    const gltf = await gltfLoads;\n    // Dispose of the cached glTF's materials and geometries:\n    gltf.dispose();\n  }\n  /**\n   * Returns true if the model that corresponds to the specified url is\n   * available in our local cache.\n   */\n  static hasFinishedLoading(url) {\n    return !!preloaded.get(url);\n  }\n  get [(_a = $evictionPolicy, _b = $loader, $evictionPolicy)]() {\n    return this.constructor[$evictionPolicy];\n  }\n  /**\n   * Preloads a glTF, populating the cache. Returns a promise that resolves\n   * when the cache is populated.\n   */\n  async preload(url, element, progressCallback = () => {}) {\n    this[$loader].setWithCredentials(CachingGLTFLoader.withCredentials);\n    this.dispatchEvent({\n      type: 'preload',\n      element: element,\n      src: url\n    });\n    if (!cache.has(url)) {\n      if (meshoptDecoder != null) {\n        this[$loader].setMeshoptDecoder(await meshoptDecoder);\n      }\n      const rawGLTFLoads = loadWithLoader(url, this[$loader], progress => {\n        progressCallback(progress * 0.8);\n      });\n      const GLTFInstance = this[$GLTFInstance];\n      const gltfInstanceLoads = rawGLTFLoads.then(rawGLTF => {\n        return GLTFInstance.prepare(rawGLTF);\n      }).then(preparedGLTF => {\n        progressCallback(0.9);\n        return new GLTFInstance(preparedGLTF);\n      }).catch(reason => {\n        console.error(reason);\n        return new GLTFInstance();\n      });\n      cache.set(url, gltfInstanceLoads);\n    }\n    await cache.get(url);\n    preloaded.set(url, true);\n    if (progressCallback) {\n      progressCallback(1.0);\n    }\n  }\n  /**\n   * Loads a glTF from the specified url and resolves a unique clone of the\n   * glTF. If the glTF has already been loaded, makes a clone of the cached\n   * copy.\n   */\n  async load(url, element, progressCallback = () => {}) {\n    await this.preload(url, element, progressCallback);\n    const gltf = await cache.get(url);\n    const clone = await gltf.clone();\n    this[$evictionPolicy].retain(url);\n    // Patch dispose so that we can properly account for instance use\n    // in the caching layer:\n    clone.dispose = () => {\n      this[$evictionPolicy].release(url);\n    };\n    return clone;\n  }\n}\nCachingGLTFLoader[_a] = new CacheEvictionPolicy(CachingGLTFLoader);","map":{"version":3,"names":["EventDispatcher","Texture","DRACOLoader","GLTFLoader","KTX2Loader","CacheEvictionPolicy","GLTFMaterialsVariantsExtension","DEFAULT_ANISOTROPY","loadWithLoader","url","loader","progressCallback","onProgress","event","fraction","loaded","total","Math","max","min","isFinite","Promise","resolve","reject","load","fetchScript","src","script","document","createElement","body","appendChild","onload","onerror","async","cache","Map","preloaded","dracoDecoderLocation","dracoLoader","ktx2TranscoderLocation","ktx2Loader","meshoptDecoderLocation","meshoptDecoder","$loader","Symbol","$evictionPolicy","$GLTFInstance","CachingGLTFLoader","constructor","GLTFInstance","_b","register","parser","setDRACOLoader","setKTX2Loader","setDRACODecoderLocation","setDecoderPath","getDRACODecoderLocation","setKTX2TranscoderLocation","setTranscoderPath","getKTX2TranscoderLocation","setMeshoptDecoderLocation","then","MeshoptDecoder","ready","getMeshoptDecoderLocation","initializeKTX2Loader","renderer","detectSupport","clearCache","forEach","_value","delete","reset","has","gltfLoads","get","gltf","dispose","hasFinishedLoading","_a","preload","element","setWithCredentials","withCredentials","dispatchEvent","type","setMeshoptDecoder","rawGLTFLoads","progress","gltfInstanceLoads","rawGLTF","prepare","preparedGLTF","catch","reason","console","error","set","clone","retain","release"],"sources":["../../src/three-components/CachingGLTFLoader.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {EventDispatcher, Texture, WebGLRenderer} from 'three';\nimport {DRACOLoader} from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport {GLTF, GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport {KTX2Loader} from 'three/examples/jsm/loaders/KTX2Loader.js';\n\nimport ModelViewerElementBase from '../model-viewer-base.js';\nimport {CacheEvictionPolicy} from '../utilities/cache-eviction-policy.js';\n\nimport GLTFMaterialsVariantsExtension from './gltf-instance/VariantMaterialLoaderPlugin';\nimport {GLTFInstance, GLTFInstanceConstructor} from './GLTFInstance.js';\n\nexport type ProgressCallback = (progress: number) => void;\n\n(Texture as any).DEFAULT_ANISOTROPY = 4;\n\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\nexport const loadWithLoader =\n    (url: string,\n     loader: GLTFLoader,\n     progressCallback: ProgressCallback = () => {}) => {\n      const onProgress = (event: ProgressEvent) => {\n        const fraction = event.loaded / event.total;\n        progressCallback!\n            (Math.max(0, Math.min(1, isFinite(fraction) ? fraction : 1)));\n      };\n      return new Promise<GLTF>((resolve, reject) => {\n        loader.load(url, resolve, onProgress, reject);\n      });\n    };\n\n/** Helper to load a script tag. */\nconst fetchScript = (src: string): Promise<Event> => {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    document.body.appendChild(script);\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = src;\n  });\n};\n\nconst cache = new Map<string, Promise<GLTFInstance>>();\nconst preloaded = new Map<string, boolean>();\n\nlet dracoDecoderLocation: string;\nconst dracoLoader = new DRACOLoader();\n\nlet ktx2TranscoderLocation: string;\nconst ktx2Loader = new KTX2Loader();\n\nlet meshoptDecoderLocation: string;\nlet meshoptDecoder: Promise<typeof MeshoptDecoder>|undefined;\n\ninterface MeshoptDecoder {\n  ready: Promise<void>;\n  supported: boolean;\n}\n\ndeclare global {\n  const MeshoptDecoder: MeshoptDecoder;\n}\n\nexport const $loader = Symbol('loader');\nexport const $evictionPolicy = Symbol('evictionPolicy');\nconst $GLTFInstance = Symbol('GLTFInstance');\n\nexport class CachingGLTFLoader<T extends GLTFInstanceConstructor =\n                                             GLTFInstanceConstructor> extends\n    EventDispatcher<\n        {'preload': {element: ModelViewerElementBase, src: String}}> {\n  static withCredentials: boolean;\n\n  static setDRACODecoderLocation(url: string) {\n    dracoDecoderLocation = url;\n    dracoLoader.setDecoderPath(url);\n  }\n\n  static getDRACODecoderLocation() {\n    return dracoDecoderLocation;\n  }\n\n  static setKTX2TranscoderLocation(url: string) {\n    ktx2TranscoderLocation = url;\n    ktx2Loader.setTranscoderPath(url);\n  }\n\n  static getKTX2TranscoderLocation() {\n    return ktx2TranscoderLocation;\n  }\n\n  static setMeshoptDecoderLocation(url: string) {\n    if (meshoptDecoderLocation !== url) {\n      meshoptDecoderLocation = url;\n      meshoptDecoder = fetchScript(url)\n                           .then(() => MeshoptDecoder.ready)\n                           .then(() => MeshoptDecoder);\n    }\n  }\n\n  static getMeshoptDecoderLocation() {\n    return meshoptDecoderLocation;\n  }\n\n  static initializeKTX2Loader(renderer: WebGLRenderer) {\n    ktx2Loader.detectSupport(renderer);\n  }\n\n  static[$evictionPolicy]: CacheEvictionPolicy =\n      new CacheEvictionPolicy(CachingGLTFLoader);\n\n  static get cache() {\n    return cache;\n  }\n\n  /** @nocollapse */\n  static clearCache() {\n    cache.forEach((_value, url) => {\n      this.delete(url);\n    });\n    this[$evictionPolicy].reset();\n  }\n\n  static has(url: string) {\n    return cache.has(url);\n  }\n\n  /** @nocollapse */\n  static async delete(url: string) {\n    if (!this.has(url)) {\n      return;\n    }\n\n    const gltfLoads = cache.get(url);\n    preloaded.delete(url);\n    cache.delete(url);\n\n    const gltf = await gltfLoads;\n    // Dispose of the cached glTF's materials and geometries:\n\n    gltf!.dispose();\n  }\n\n  /**\n   * Returns true if the model that corresponds to the specified url is\n   * available in our local cache.\n   */\n  static hasFinishedLoading(url: string) {\n    return !!preloaded.get(url);\n  }\n\n  constructor(GLTFInstance: T) {\n    super();\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n    this[$loader].setKTX2Loader(ktx2Loader);\n  }\n\n  protected[$loader]: GLTFLoader = new GLTFLoader().register(\n      parser => new GLTFMaterialsVariantsExtension(parser));\n  protected[$GLTFInstance]: T;\n\n  protected get[$evictionPolicy](): CacheEvictionPolicy {\n    return (this.constructor as typeof CachingGLTFLoader)[$evictionPolicy];\n  }\n\n  /**\n   * Preloads a glTF, populating the cache. Returns a promise that resolves\n   * when the cache is populated.\n   */\n  async preload(\n      url: string, element: ModelViewerElementBase,\n      progressCallback: ProgressCallback = () => {}) {\n    this[$loader].setWithCredentials(CachingGLTFLoader.withCredentials);\n    this.dispatchEvent({type: 'preload', element: element, src: url});\n    if (!cache.has(url)) {\n      if (meshoptDecoder != null) {\n        this[$loader].setMeshoptDecoder(await meshoptDecoder);\n      }\n\n      const rawGLTFLoads =\n          loadWithLoader(url, this[$loader], (progress: number) => {\n            progressCallback(progress * 0.8);\n          });\n\n      const GLTFInstance = this[$GLTFInstance];\n      const gltfInstanceLoads = rawGLTFLoads\n                                    .then((rawGLTF) => {\n                                      return GLTFInstance.prepare(rawGLTF);\n                                    })\n                                    .then((preparedGLTF) => {\n                                      progressCallback(0.9);\n                                      return new GLTFInstance(preparedGLTF);\n                                    })\n                                    .catch((reason => {\n                                      console.error(reason);\n                                      return new GLTFInstance();\n                                    }));\n      cache.set(url, gltfInstanceLoads);\n    }\n\n    await cache.get(url);\n\n    preloaded.set(url, true);\n\n    if (progressCallback) {\n      progressCallback(1.0);\n    }\n  }\n\n  /**\n   * Loads a glTF from the specified url and resolves a unique clone of the\n   * glTF. If the glTF has already been loaded, makes a clone of the cached\n   * copy.\n   */\n  async load(\n      url: string, element: ModelViewerElementBase,\n      progressCallback: ProgressCallback = () => {}): Promise<InstanceType<T>> {\n    await this.preload(url, element, progressCallback);\n\n    const gltf = await cache.get(url)!;\n    const clone = await gltf.clone() as InstanceType<T>;\n\n    this[$evictionPolicy].retain(url);\n\n    // Patch dispose so that we can properly account for instance use\n    // in the caching layer:\n    clone.dispose = () => {\n      this[$evictionPolicy].release(url);\n    };\n\n    return clone;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}