{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { Spherical, Vector3 } from 'three';\nimport { style } from '../decorators.js';\nimport { $ariaLabel, $container, $getModelIsVisible, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $updateStatus, $userInputElement, toVector3D } from '../model-viewer-base.js';\nimport { degreesToRadians, normalizeUnit } from '../styles/conversions.js';\nimport { StyleEvaluator } from '../styles/evaluators.js';\nimport { numberNode, parseExpressions } from '../styles/parsers.js';\nimport { DECAY_MILLISECONDS } from '../three-components/Damper.js';\nimport { ChangeSource, SmoothControls } from '../three-components/SmoothControls.js';\nimport { timeline } from '../utilities/animation.js';\n// NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/google/model-viewer/issues/839\nconst PROMPT_ANIMATION_TIME = 5000;\n// For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the Frame.\nconst wiggle = timeline({\n  initialValue: 0,\n  keyframes: [{\n    frames: 5,\n    value: -1\n  }, {\n    frames: 1,\n    value: -1\n  }, {\n    frames: 8,\n    value: 1\n  }, {\n    frames: 1,\n    value: 1\n  }, {\n    frames: 5,\n    value: 0\n  }, {\n    frames: 18,\n    value: 0\n  }]\n});\nconst fade = timeline({\n  initialValue: 0,\n  keyframes: [{\n    frames: 1,\n    value: 1\n  }, {\n    frames: 5,\n    value: 1\n  }, {\n    frames: 1,\n    value: 0\n  }, {\n    frames: 6,\n    value: 0\n  }]\n});\nexport const DEFAULT_FOV_DEG = 30;\nexport const DEFAULT_MIN_FOV_DEG = 12;\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\nconst MINIMUM_RADIUS_RATIO = 2.2;\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT = '. Use mouse, touch or arrow keys to move.';\nexport const InteractionPromptStrategy = {\n  AUTO: 'auto',\n  NONE: 'none'\n};\nexport const InteractionPromptStyle = {\n  BASIC: 'basic',\n  WIGGLE: 'wiggle'\n};\nexport const TouchAction = {\n  PAN_Y: 'pan-y',\n  PAN_X: 'pan-x',\n  NONE: 'none'\n};\nexport const fieldOfViewIntrinsics = () => {\n  return {\n    basis: [degreesToRadians(numberNode(DEFAULT_FOV_DEG, 'deg'))],\n    keywords: {\n      auto: [null]\n    }\n  };\n};\nconst minFieldOfViewIntrinsics = () => {\n  return {\n    basis: [degreesToRadians(numberNode(DEFAULT_MIN_FOV_DEG, 'deg'))],\n    keywords: {\n      auto: [null]\n    }\n  };\n};\nexport const cameraOrbitIntrinsics = (() => {\n  const defaultTerms = parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms;\n  const theta = normalizeUnit(defaultTerms[0]);\n  const phi = normalizeUnit(defaultTerms[1]);\n  return element => {\n    const radius = element[$scene].idealCameraDistance();\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {\n        auto: [null, null, numberNode(105, '%')]\n      }\n    };\n  };\n})();\nconst minCameraOrbitIntrinsics = element => {\n  const radius = MINIMUM_RADIUS_RATIO * element[$scene].boundingSphere.radius;\n  return {\n    basis: [numberNode(-Infinity, 'rad'), numberNode(Math.PI / 8, 'rad'), numberNode(radius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nconst maxCameraOrbitIntrinsics = element => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n  return {\n    basis: [numberNode(Infinity, 'rad'), numberNode(Math.PI - Math.PI / 8, 'rad'), numberNode(defaultRadius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nexport const cameraTargetIntrinsics = element => {\n  const center = element[$scene].boundingBox.getCenter(new Vector3());\n  return {\n    basis: [numberNode(center.x, 'm'), numberNode(center.y, 'm'), numberNode(center.z, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\nexport const $controls = Symbol('controls');\nexport const $panElement = Symbol('panElement');\nexport const $promptElement = Symbol('promptElement');\nexport const $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport const $fingerAnimatedContainers = Symbol('fingerAnimatedContainers');\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\nconst $cancelPrompts = Symbol('cancelPrompts');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $cancellationSource = Symbol('cancellationSource');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nconst $initialized = Symbol('initialized');\nconst $maintainThetaPhi = Symbol('maintainThetaPhi');\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\nexport const ControlsMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;\n  class ControlsModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.cameraControls = false;\n      this.cameraOrbit = DEFAULT_CAMERA_ORBIT;\n      this.cameraTarget = DEFAULT_CAMERA_TARGET;\n      this.fieldOfView = DEFAULT_FIELD_OF_VIEW;\n      this.minCameraOrbit = 'auto';\n      this.maxCameraOrbit = 'auto';\n      this.minFieldOfView = 'auto';\n      this.maxFieldOfView = 'auto';\n      this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n      this.interactionPrompt = InteractionPromptStrategy.AUTO;\n      this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;\n      this.orbitSensitivity = 1;\n      this.zoomSensitivity = 1;\n      this.panSensitivity = 1;\n      this.touchAction = TouchAction.NONE;\n      this.disableZoom = false;\n      this.disablePan = false;\n      this.disableTap = false;\n      this.interpolationDecay = DECAY_MILLISECONDS;\n      this[_a] = this.shadowRoot.querySelector('.interaction-prompt');\n      this[_b] = this.shadowRoot.querySelector('#prompt');\n      this[_c] = [this.shadowRoot.querySelector('#finger0'), this.shadowRoot.querySelector('#finger1')];\n      this[_d] = this.shadowRoot.querySelector('.pan-target');\n      this[_e] = 0;\n      this[_f] = Infinity;\n      this[_g] = false;\n      this[_h] = false;\n      this[_j] = ChangeSource.AUTOMATIC;\n      this[_k] = new SmoothControls(this[$scene].camera, this[$userInputElement], this[$scene]);\n      this[_l] = new Spherical();\n      this[_m] = false;\n      this[_o] = false;\n      this[_p] = false;\n      this[_q] = () => {\n        const source = this[$controls].changeSource;\n        this[$cancellationSource] = source;\n        if (source === ChangeSource.USER_INTERACTION) {\n          this[$userHasInteracted] = true;\n          this[$deferInteractionPrompt]();\n        }\n      };\n      this[_r] = () => {\n        this[$updateAria]();\n        this[$needsRender]();\n        const source = this[$controls].changeSource;\n        this.dispatchEvent(new CustomEvent('camera-change', {\n          detail: {\n            source\n          }\n        }));\n      };\n      this[_s] = event => {\n        if (event.type === 'pointer-change-start') {\n          this[$container].classList.add('pointer-tumbling');\n        } else {\n          this[$container].classList.remove('pointer-tumbling');\n        }\n      };\n    }\n    get inputSensitivity() {\n      return this[$controls].inputSensitivity;\n    }\n    set inputSensitivity(value) {\n      this[$controls].inputSensitivity = value;\n    }\n    getCameraOrbit() {\n      const {\n        theta,\n        phi,\n        radius\n      } = this[$lastSpherical];\n      return {\n        theta,\n        phi,\n        radius,\n        toString() {\n          return `${this.theta}rad ${this.phi}rad ${this.radius}m`;\n        }\n      };\n    }\n    getCameraTarget() {\n      return toVector3D(this[$renderer].isPresenting ? this[$renderer].arRenderer.target : this[$scene].getTarget());\n    }\n    getFieldOfView() {\n      return this[$controls].getFieldOfView();\n    }\n    // Provided so user code does not have to parse these from attributes.\n    getMinimumFieldOfView() {\n      return this[$controls].options.minimumFieldOfView;\n    }\n    getMaximumFieldOfView() {\n      return this[$controls].options.maximumFieldOfView;\n    }\n    getIdealAspect() {\n      return this[$scene].idealAspect;\n    }\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] = this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls;\n    }\n    zoom(keyPresses) {\n      const event = new WheelEvent('wheel', {\n        deltaY: -30 * keyPresses\n      });\n      this[$userInputElement].dispatchEvent(event);\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      this[$controls].addEventListener('user-interaction', this[$cancelPrompts]);\n      this[$controls].addEventListener('pointer-change-start', this[$onPointerChange]);\n      this[$controls].addEventListener('pointer-change-end', this[$onPointerChange]);\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$controls].removeEventListener('user-interaction', this[$cancelPrompts]);\n      this[$controls].removeEventListener('pointer-change-start', this[$onPointerChange]);\n      this[$controls].removeEventListener('pointer-change-end', this[$onPointerChange]);\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      const controls = this[$controls];\n      const scene = this[$scene];\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n        } else {\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n        this[$userInputElement].setAttribute('aria-label', this[$ariaLabel]);\n      }\n      if (changedProperties.has('disableZoom')) {\n        controls.disableZoom = this.disableZoom;\n      }\n      if (changedProperties.has('disablePan')) {\n        controls.enablePan = !this.disablePan;\n      }\n      if (changedProperties.has('disableTap')) {\n        controls.enableTap = !this.disableTap;\n      }\n      if (changedProperties.has('interactionPrompt') || changedProperties.has('cameraControls') || changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls && !this[$userHasInteracted]) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptAnimatedContainer].style.opacity = this.interactionPromptStyle == InteractionPromptStyle.BASIC ? '1' : '0';\n      }\n      if (changedProperties.has('touchAction')) {\n        const touchAction = this.touchAction;\n        controls.applyOptions({\n          touchAction\n        });\n        controls.updateTouchActionStyle();\n      }\n      if (changedProperties.has('orbitSensitivity')) {\n        controls.orbitSensitivity = this.orbitSensitivity;\n      }\n      if (changedProperties.has('zoomSensitivity')) {\n        controls.zoomSensitivity = this.zoomSensitivity;\n      }\n      if (changedProperties.has('panSensitivity')) {\n        controls.panSensitivity = this.panSensitivity;\n      }\n      if (changedProperties.has('interpolationDecay')) {\n        controls.setDamperDecayTime(this.interpolationDecay);\n        scene.setTargetDamperDecayTime(this.interpolationDecay);\n      }\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          controls.jumpToGoal();\n          scene.jumpToGoal();\n          this[$onChange]();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n    async updateFraming() {\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      await scene.updateFraming();\n      const newFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      const zoom = this[$controls].getFieldOfView() / oldFramedFoV;\n      this[$controls].setFieldOfView(newFramedFoV * zoom);\n      this[$maintainThetaPhi] = true;\n      this.requestUpdate('maxFieldOfView');\n      this.requestUpdate('fieldOfView');\n      this.requestUpdate('minCameraOrbit');\n      this.requestUpdate('maxCameraOrbit');\n      this.requestUpdate('cameraOrbit');\n      await this.updateComplete;\n    }\n    interact(duration, finger0, finger1) {\n      const inputElement = this[$userInputElement];\n      const fingerElements = this[$fingerAnimatedContainers];\n      if (fingerElements[0].style.opacity === '1') {\n        console.warn('interact() failed because an existing interaction is running.');\n        return;\n      }\n      const xy = new Array();\n      xy.push({\n        x: timeline(finger0.x),\n        y: timeline(finger0.y)\n      });\n      const positions = [{\n        x: xy[0].x(0),\n        y: xy[0].y(0)\n      }];\n      if (finger1 != null) {\n        xy.push({\n          x: timeline(finger1.x),\n          y: timeline(finger1.y)\n        });\n        positions.push({\n          x: xy[1].x(0),\n          y: xy[1].y(0)\n        });\n      }\n      let startTime = performance.now();\n      const {\n        width,\n        height\n      } = this[$scene];\n      const rect = this.getBoundingClientRect();\n      const dispatchTouches = type => {\n        for (const [i, position] of positions.entries()) {\n          const {\n            style\n          } = fingerElements[i];\n          style.transform = `translateX(${width * position.x}px) translateY(${height * position.y}px)`;\n          if (type === 'pointerdown') {\n            style.opacity = '1';\n          } else if (type === 'pointerup') {\n            style.opacity = '0';\n          }\n          const init = {\n            pointerId: i - 5678,\n            pointerType: 'touch',\n            target: inputElement,\n            clientX: width * position.x + rect.x,\n            clientY: height * position.y + rect.y,\n            altKey: true // flag that this is not a user interaction\n          };\n          inputElement.dispatchEvent(new PointerEvent(type, init));\n        }\n      };\n      const moveTouches = () => {\n        // Cancel interaction if something else moves the camera or input is\n        // removed from the DOM.\n        const changeSource = this[$cancellationSource];\n        if (changeSource !== ChangeSource.AUTOMATIC || !inputElement.isConnected) {\n          for (const fingerElement of this[$fingerAnimatedContainers]) {\n            fingerElement.style.opacity = '0';\n          }\n          dispatchTouches('pointercancel');\n          this.dispatchEvent(new CustomEvent('interact-stopped', {\n            detail: {\n              source: changeSource\n            }\n          }));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n          return;\n        }\n        const time = Math.min(1, (performance.now() - startTime) / duration);\n        for (const [i, position] of positions.entries()) {\n          position.x = xy[i].x(time);\n          position.y = xy[i].y(time);\n        }\n        dispatchTouches('pointermove');\n        if (time < 1) {\n          requestAnimationFrame(moveTouches);\n        } else {\n          dispatchTouches('pointerup');\n          this.dispatchEvent(new CustomEvent('interact-stopped', {\n            detail: {\n              source: ChangeSource.AUTOMATIC\n            }\n          }));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n        }\n      };\n      const onVisibilityChange = () => {\n        let elapsed = 0;\n        if (document.visibilityState === 'hidden') {\n          elapsed = performance.now() - startTime;\n        } else {\n          startTime = performance.now() - elapsed;\n        }\n      };\n      document.addEventListener('visibilitychange', onVisibilityChange);\n      dispatchTouches('pointerdown');\n      this[$cancellationSource] = ChangeSource.AUTOMATIC;\n      requestAnimationFrame(moveTouches);\n    }\n    [(_a = $promptElement, _b = $promptAnimatedContainer, _c = $fingerAnimatedContainers, _d = $panElement, _e = $lastPromptOffset, _f = $promptElementVisibleTime, _g = $userHasInteracted, _h = $waitingToPromptUser, _j = $cancellationSource, _k = $controls, _l = $lastSpherical, _m = $jumpCamera, _o = $initialized, _p = $maintainThetaPhi, $syncFieldOfView)](style) {\n      const controls = this[$controls];\n      const scene = this[$scene];\n      scene.framedFoVDeg = style[0] * 180 / Math.PI;\n      controls.changeSource = ChangeSource.NONE;\n      controls.setFieldOfView(scene.adjustedFoV(scene.framedFoVDeg));\n      this[$cancelPrompts]();\n    }\n    [$syncCameraOrbit](style) {\n      const controls = this[$controls];\n      if (this[$maintainThetaPhi]) {\n        const {\n          theta,\n          phi\n        } = this.getCameraOrbit();\n        style[0] = theta;\n        style[1] = phi;\n        this[$maintainThetaPhi] = false;\n      }\n      controls.changeSource = ChangeSource.NONE;\n      controls.setOrbit(style[0], style[1], style[2]);\n      this[$cancelPrompts]();\n    }\n    [$syncMinCameraOrbit](style) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncMaxCameraOrbit](style) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this[$updateCameraForRadius](style[2]);\n      this.jumpCameraToGoal();\n    }\n    [$syncMinFieldOfView](style) {\n      this[$controls].applyOptions({\n        minimumFieldOfView: style[0] * 180 / Math.PI\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncMaxFieldOfView](style) {\n      const fov = this[$scene].adjustedFoV(style[0] * 180 / Math.PI);\n      this[$controls].applyOptions({\n        maximumFieldOfView: fov\n      });\n      this.jumpCameraToGoal();\n    }\n    [$syncCameraTarget](style) {\n      const [x, y, z] = style;\n      if (!this[$renderer].arRenderer.isPresenting) {\n        this[$scene].setTarget(x, y, z);\n      }\n      this[$controls].changeSource = ChangeSource.NONE;\n      this[$renderer].arRenderer.updateTarget();\n      this[$cancelPrompts]();\n    }\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n      if (this[$renderer].isPresenting || !this[$getModelIsVisible]()) {\n        return;\n      }\n      const controls = this[$controls];\n      const scene = this[$scene];\n      const now = performance.now();\n      if (this[$waitingToPromptUser]) {\n        if (this.loaded && now > this[$loadedTime] + this.interactionPromptThreshold) {\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n          this[$promptElement].classList.add('visible');\n        }\n      }\n      if (isFinite(this[$promptElementVisibleTime]) && this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const animationTime = (now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME % 1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n        if (offset !== this[$lastPromptOffset]) {\n          const xOffset = offset * scene.width * 0.05;\n          const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n          this[$promptAnimatedContainer].style.transform = `translateX(${xOffset}px)`;\n          controls.changeSource = ChangeSource.AUTOMATIC;\n          controls.adjustOrbit(deltaTheta, 0, 0);\n          this[$lastPromptOffset] = offset;\n        }\n      }\n      const cameraMoved = controls.update(time, delta);\n      const targetMoved = scene.updateTarget(delta);\n      if (cameraMoved || targetMoved) {\n        this[$onChange]();\n      }\n    }\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n    [$updateCameraForRadius](radius) {\n      const maximumRadius = Math.max(this[$scene].boundingSphere.radius, radius);\n      const near = 0;\n      const far = Math.abs(2 * maximumRadius);\n      this[$controls].updateNearFar(near, far);\n    }\n    [$updateAria]() {\n      const {\n        theta,\n        phi\n      } = this[$controls].getCameraSpherical(this[$lastSpherical]);\n      const azimuthalQuadrant = (4 + Math.floor((theta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n      const polarTrient = Math.floor(phi / THIRD_PI);\n      const azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n      const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n      this[$updateStatus](`View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`);\n    }\n    get [$ariaLabel]() {\n      return super[$ariaLabel].replace(/\\.$/, '') + (this.cameraControls ? INTERACTION_PROMPT : '');\n    }\n    async [$onResize](event) {\n      const controls = this[$controls];\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      // The super of $onResize may update the scene's adjustedFoV, so we\n      // compare the before and after to calculate the proper zoom.\n      super[$onResize](event);\n      const fovRatio = scene.adjustedFoV(scene.framedFoVDeg) / oldFramedFoV;\n      const fov = controls.getFieldOfView() * (isFinite(fovRatio) ? fovRatio : 1);\n      controls.updateAspect(this[$scene].aspect);\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      await this.updateComplete;\n      this[$controls].setFieldOfView(fov);\n      this.jumpCameraToGoal();\n    }\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      if (this[$initialized]) {\n        this[$maintainThetaPhi] = true;\n      } else {\n        this[$initialized] = true;\n      }\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n  }\n  _q = $cancelPrompts, _r = $onChange, _s = $onPointerChange;\n  __decorate([property({\n    type: Boolean,\n    attribute: 'camera-controls'\n  })], ControlsModelViewerElement.prototype, \"cameraControls\", void 0);\n  __decorate([style({\n    intrinsics: cameraOrbitIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraOrbit\", void 0);\n  __decorate([style({\n    intrinsics: cameraTargetIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraTarget\n  }), property({\n    type: String,\n    attribute: 'camera-target',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraTarget\", void 0);\n  __decorate([style({\n    intrinsics: fieldOfViewIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncFieldOfView\n  }), property({\n    type: String,\n    attribute: 'field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"fieldOfView\", void 0);\n  __decorate([style({\n    intrinsics: minCameraOrbitIntrinsics,\n    updateHandler: $syncMinCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'min-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minCameraOrbit\", void 0);\n  __decorate([style({\n    intrinsics: maxCameraOrbitIntrinsics,\n    updateHandler: $syncMaxCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'max-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxCameraOrbit\", void 0);\n  __decorate([style({\n    intrinsics: minFieldOfViewIntrinsics,\n    updateHandler: $syncMinFieldOfView\n  }), property({\n    type: String,\n    attribute: 'min-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minFieldOfView\", void 0);\n  __decorate([style({\n    intrinsics: fieldOfViewIntrinsics,\n    updateHandler: $syncMaxFieldOfView\n  }), property({\n    type: String,\n    attribute: 'max-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxFieldOfView\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'interaction-prompt-threshold'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptThreshold\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt'\n  })], ControlsModelViewerElement.prototype, \"interactionPrompt\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt-style'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptStyle\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'orbit-sensitivity'\n  })], ControlsModelViewerElement.prototype, \"orbitSensitivity\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'zoom-sensitivity'\n  })], ControlsModelViewerElement.prototype, \"zoomSensitivity\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'pan-sensitivity'\n  })], ControlsModelViewerElement.prototype, \"panSensitivity\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'touch-action'\n  })], ControlsModelViewerElement.prototype, \"touchAction\", void 0);\n  __decorate([property({\n    type: Boolean,\n    attribute: 'disable-zoom'\n  })], ControlsModelViewerElement.prototype, \"disableZoom\", void 0);\n  __decorate([property({\n    type: Boolean,\n    attribute: 'disable-pan'\n  })], ControlsModelViewerElement.prototype, \"disablePan\", void 0);\n  __decorate([property({\n    type: Boolean,\n    attribute: 'disable-tap'\n  })], ControlsModelViewerElement.prototype, \"disableTap\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'interpolation-decay'\n  })], ControlsModelViewerElement.prototype, \"interpolationDecay\", void 0);\n  return ControlsModelViewerElement;\n};","map":{"version":3,"names":["property","Spherical","Vector3","style","$ariaLabel","$container","$getModelIsVisible","$loadedTime","$needsRender","$onModelLoad","$onResize","$renderer","$scene","$tick","$updateStatus","$userInputElement","toVector3D","degreesToRadians","normalizeUnit","StyleEvaluator","numberNode","parseExpressions","DECAY_MILLISECONDS","ChangeSource","SmoothControls","timeline","PROMPT_ANIMATION_TIME","wiggle","initialValue","keyframes","frames","value","fade","DEFAULT_FOV_DEG","DEFAULT_MIN_FOV_DEG","DEFAULT_CAMERA_ORBIT","DEFAULT_CAMERA_TARGET","DEFAULT_FIELD_OF_VIEW","MINIMUM_RADIUS_RATIO","AZIMUTHAL_QUADRANT_LABELS","POLAR_TRIENT_LABELS","DEFAULT_INTERACTION_PROMPT_THRESHOLD","INTERACTION_PROMPT","InteractionPromptStrategy","AUTO","NONE","InteractionPromptStyle","BASIC","WIGGLE","TouchAction","PAN_Y","PAN_X","fieldOfViewIntrinsics","basis","keywords","auto","minFieldOfViewIntrinsics","cameraOrbitIntrinsics","defaultTerms","terms","theta","phi","element","radius","idealCameraDistance","minCameraOrbitIntrinsics","boundingSphere","Infinity","Math","PI","maxCameraOrbitIntrinsics","orbitIntrinsics","evaluator","defaultRadius","evaluate","cameraTargetIntrinsics","center","boundingBox","getCenter","x","y","z","HALF_PI","THIRD_PI","QUARTER_PI","TAU","$controls","Symbol","$panElement","$promptElement","$promptAnimatedContainer","$fingerAnimatedContainers","$deferInteractionPrompt","$updateAria","$updateCameraForRadius","$cancelPrompts","$onChange","$onPointerChange","$waitingToPromptUser","$userHasInteracted","$promptElementVisibleTime","$lastPromptOffset","$cancellationSource","$lastSpherical","$jumpCamera","$initialized","$maintainThetaPhi","$syncCameraOrbit","$syncFieldOfView","$syncCameraTarget","$syncMinCameraOrbit","$syncMaxCameraOrbit","$syncMinFieldOfView","$syncMaxFieldOfView","ControlsMixin","ModelViewerElement","ControlsModelViewerElement","constructor","cameraControls","cameraOrbit","cameraTarget","fieldOfView","minCameraOrbit","maxCameraOrbit","minFieldOfView","maxFieldOfView","interactionPromptThreshold","interactionPrompt","interactionPromptStyle","orbitSensitivity","zoomSensitivity","panSensitivity","touchAction","disableZoom","disablePan","disableTap","interpolationDecay","_a","shadowRoot","querySelector","_b","_c","_d","_e","_f","_g","_h","_j","AUTOMATIC","_k","camera","_l","_m","_o","_p","_q","source","changeSource","USER_INTERACTION","_r","dispatchEvent","CustomEvent","detail","_s","event","type","classList","add","remove","inputSensitivity","getCameraOrbit","toString","getCameraTarget","isPresenting","arRenderer","target","getTarget","getFieldOfView","getMinimumFieldOfView","options","minimumFieldOfView","getMaximumFieldOfView","maximumFieldOfView","getIdealAspect","idealAspect","jumpCameraToGoal","requestUpdate","resetInteractionPrompt","zoom","keyPresses","WheelEvent","deltaY","connectedCallback","addEventListener","disconnectedCallback","removeEventListener","updated","changedProperties","controls","scene","has","enableInteraction","disableInteraction","setAttribute","enablePan","enableTap","opacity","applyOptions","updateTouchActionStyle","setDamperDecayTime","setTargetDamperDecayTime","Promise","resolve","then","jumpToGoal","updateFraming","oldFramedFoV","adjustedFoV","framedFoVDeg","newFramedFoV","setFieldOfView","updateComplete","interact","duration","finger0","finger1","inputElement","fingerElements","console","warn","xy","Array","push","positions","startTime","performance","now","width","height","rect","getBoundingClientRect","dispatchTouches","i","position","entries","transform","init","pointerId","pointerType","clientX","clientY","altKey","PointerEvent","moveTouches","isConnected","fingerElement","document","onVisibilityChange","time","min","requestAnimationFrame","elapsed","visibilityState","setOrbit","minimumAzimuthalAngle","minimumPolarAngle","minimumRadius","maximumAzimuthalAngle","maximumPolarAngle","maximumRadius","fov","setTarget","updateTarget","delta","loaded","isFinite","animationTime","offset","xOffset","deltaTheta","adjustOrbit","cameraMoved","update","targetMoved","max","near","far","abs","updateNearFar","getCameraSpherical","azimuthalQuadrant","floor","polarTrient","azimuthalQuadrantLabel","polarTrientLabel","replace","fovRatio","updateAspect","aspect","__decorate","Boolean","attribute","intrinsics","observeEffects","updateHandler","String","hasChanged","Number"],"sources":["../../src/features/controls.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit/decorators.js';\nimport {Event, PerspectiveCamera, Spherical, Vector3} from 'three';\n\nimport {style} from '../decorators.js';\nimport ModelViewerElementBase, {$ariaLabel, $container, $getModelIsVisible, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $updateStatus, $userInputElement, toVector3D, Vector3D} from '../model-viewer-base.js';\nimport {degreesToRadians, normalizeUnit} from '../styles/conversions.js';\nimport {EvaluatedStyle, Intrinsics, SphericalIntrinsics, StyleEvaluator, Vector3Intrinsics} from '../styles/evaluators.js';\nimport {IdentNode, NumberNode, numberNode, parseExpressions} from '../styles/parsers.js';\nimport {DECAY_MILLISECONDS} from '../three-components/Damper.js';\nimport {ChangeSource, PointerChangeEvent, SmoothControls} from '../three-components/SmoothControls.js';\nimport {Constructor} from '../utilities.js';\nimport {Path, timeline, TimingFunction} from '../utilities/animation.js';\n\n\n\n// NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/google/model-viewer/issues/839\nconst PROMPT_ANIMATION_TIME = 5000;\n\n// For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the Frame.\nconst wiggle = timeline({\n  initialValue: 0,\n  keyframes: [\n    {frames: 5, value: -1},\n    {frames: 1, value: -1},\n    {frames: 8, value: 1},\n    {frames: 1, value: 1},\n    {frames: 5, value: 0},\n    {frames: 18, value: 0}\n  ]\n});\n\nconst fade = timeline({\n  initialValue: 0,\n  keyframes: [\n    {frames: 1, value: 1},\n    {frames: 5, value: 1},\n    {frames: 1, value: 0},\n    {frames: 6, value: 0}\n  ]\n});\n\nexport const DEFAULT_FOV_DEG = 30;\nexport const DEFAULT_MIN_FOV_DEG = 12;\n\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\n\nconst MINIMUM_RADIUS_RATIO = 2.2;\n\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\n\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT = '. Use mouse, touch or arrow keys to move.';\n\nexport interface CameraChangeDetails {\n  source: ChangeSource;\n}\n\nexport interface SphericalPosition {\n  theta: number;  // equator angle around the y (up) axis.\n  phi: number;    // polar angle from the y (up) axis.\n  radius: number;\n  toString(): string;\n}\n\nexport interface Finger {\n  x: Path;\n  y: Path;\n}\n\nexport type InteractionPromptStrategy = 'auto'|'none';\nexport type InteractionPromptStyle = 'basic'|'wiggle';\nexport type TouchAction = 'pan-y'|'pan-x'|'none';\n\nexport const InteractionPromptStrategy:\n    {[index: string]: InteractionPromptStrategy} = {\n      AUTO: 'auto',\n      NONE: 'none'\n    };\n\nexport const InteractionPromptStyle:\n    {[index: string]: InteractionPromptStyle} = {\n      BASIC: 'basic',\n      WIGGLE: 'wiggle'\n    };\n\nexport const TouchAction: {[index: string]: TouchAction} = {\n  PAN_Y: 'pan-y',\n  PAN_X: 'pan-x',\n  NONE: 'none'\n};\n\nexport const fieldOfViewIntrinsics = () => {\n  return {\n    basis:\n        [degreesToRadians(numberNode(DEFAULT_FOV_DEG, 'deg')) as\n         NumberNode<'rad'>],\n    keywords: {auto: [null]}\n  };\n};\n\nconst minFieldOfViewIntrinsics = () => {\n  return {\n    basis:\n        [degreesToRadians(numberNode(DEFAULT_MIN_FOV_DEG, 'deg')) as\n         NumberNode<'rad'>],\n    keywords: {auto: [null]}\n  };\n};\n\nexport const cameraOrbitIntrinsics = (() => {\n  const defaultTerms =\n      parseExpressions(DEFAULT_CAMERA_ORBIT)[0]\n          .terms as [NumberNode<'rad'>, NumberNode<'rad'>, IdentNode];\n\n  const theta = normalizeUnit(defaultTerms[0]) as NumberNode<'rad'>;\n  const phi = normalizeUnit(defaultTerms[1]) as NumberNode<'rad'>;\n\n  return (element: ModelViewerElementBase) => {\n    const radius = element[$scene].idealCameraDistance();\n\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {auto: [null, null, numberNode(105, '%')]}\n    };\n  };\n})();\n\nconst minCameraOrbitIntrinsics = (element: ModelViewerElementBase&\n                                  ControlsInterface) => {\n  const radius = MINIMUM_RADIUS_RATIO * element[$scene].boundingSphere.radius;\n\n  return {\n    basis: [\n      numberNode(-Infinity, 'rad'),\n      numberNode(Math.PI / 8, 'rad'),\n      numberNode(radius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst maxCameraOrbitIntrinsics = (element: ModelViewerElementBase) => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n\n  return {\n    basis: [\n      numberNode(Infinity, 'rad'),\n      numberNode(Math.PI - Math.PI / 8, 'rad'),\n      numberNode(defaultRadius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nexport const cameraTargetIntrinsics = (element: ModelViewerElementBase) => {\n  const center = element[$scene].boundingBox.getCenter(new Vector3());\n\n  return {\n    basis: [\n      numberNode(center.x, 'm'),\n      numberNode(center.y, 'm'),\n      numberNode(center.z, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\n\nexport const $controls = Symbol('controls');\nexport const $panElement = Symbol('panElement');\nexport const $promptElement = Symbol('promptElement');\nexport const $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport const $fingerAnimatedContainers = Symbol('fingerAnimatedContainers');\n\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\n\nconst $cancelPrompts = Symbol('cancelPrompts');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\n\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $cancellationSource = Symbol('cancellationSource');\n\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nconst $initialized = Symbol('initialized');\nconst $maintainThetaPhi = Symbol('maintainThetaPhi');\n\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\n\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\n\nexport declare interface ControlsInterface {\n  cameraControls: boolean;\n  cameraOrbit: string;\n  cameraTarget: string;\n  fieldOfView: string;\n  minCameraOrbit: string;\n  maxCameraOrbit: string;\n  minFieldOfView: string;\n  maxFieldOfView: string;\n  interactionPrompt: InteractionPromptStrategy;\n  interactionPromptStyle: InteractionPromptStyle;\n  interactionPromptThreshold: number;\n  orbitSensitivity: number;\n  zoomSensitivity: number;\n  panSensitivity: number;\n  touchAction: TouchAction;\n  interpolationDecay: number;\n  disableZoom: boolean;\n  disablePan: boolean;\n  disableTap: boolean;\n  getCameraOrbit(): SphericalPosition;\n  getCameraTarget(): Vector3D;\n  getFieldOfView(): number;\n  getMinimumFieldOfView(): number;\n  getMaximumFieldOfView(): number;\n  getIdealAspect(): number;\n  jumpCameraToGoal(): void;\n  updateFraming(): Promise<void>;\n  resetInteractionPrompt(): void;\n  zoom(keyPresses: number): void;\n  interact(duration: number, finger0: Finger, finger1?: Finger): void;\n  inputSensitivity: number;\n}\n\nexport const ControlsMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<ControlsInterface>&T => {\n  class ControlsModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean, attribute: 'camera-controls'})\n    cameraControls: boolean = false;\n\n    @style({\n      intrinsics: cameraOrbitIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraOrbit\n    })\n    @property({type: String, attribute: 'camera-orbit', hasChanged: () => true})\n    cameraOrbit: string = DEFAULT_CAMERA_ORBIT;\n\n    @style({\n      intrinsics: cameraTargetIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraTarget\n    })\n    @property(\n        {type: String, attribute: 'camera-target', hasChanged: () => true})\n    cameraTarget: string = DEFAULT_CAMERA_TARGET;\n\n    @style({\n      intrinsics: fieldOfViewIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'field-of-view', hasChanged: () => true})\n    fieldOfView: string = DEFAULT_FIELD_OF_VIEW;\n\n    @style({\n      intrinsics: minCameraOrbitIntrinsics,\n      updateHandler: $syncMinCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'min-camera-orbit', hasChanged: () => true})\n    minCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: maxCameraOrbitIntrinsics,\n      updateHandler: $syncMaxCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'max-camera-orbit', hasChanged: () => true})\n    maxCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: minFieldOfViewIntrinsics,\n      updateHandler: $syncMinFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'min-field-of-view', hasChanged: () => true})\n    minFieldOfView: string = 'auto';\n\n    @style(\n        {intrinsics: fieldOfViewIntrinsics, updateHandler: $syncMaxFieldOfView})\n    @property(\n        {type: String, attribute: 'max-field-of-view', hasChanged: () => true})\n    maxFieldOfView: string = 'auto';\n\n    @property({type: Number, attribute: 'interaction-prompt-threshold'})\n    interactionPromptThreshold: number = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n\n    @property({type: String, attribute: 'interaction-prompt'})\n    interactionPrompt: InteractionPromptStrategy =\n        InteractionPromptStrategy.AUTO;\n\n    @property({type: String, attribute: 'interaction-prompt-style'})\n    interactionPromptStyle: InteractionPromptStyle =\n        InteractionPromptStyle.WIGGLE;\n\n    @property({type: Number, attribute: 'orbit-sensitivity'})\n    orbitSensitivity: number = 1;\n\n    @property({type: Number, attribute: 'zoom-sensitivity'})\n    zoomSensitivity: number = 1;\n\n    @property({type: Number, attribute: 'pan-sensitivity'})\n    panSensitivity: number = 1;\n\n    @property({type: String, attribute: 'touch-action'})\n    touchAction: TouchAction = TouchAction.NONE;\n\n    @property({type: Boolean, attribute: 'disable-zoom'})\n    disableZoom: boolean = false;\n\n    @property({type: Boolean, attribute: 'disable-pan'})\n    disablePan: boolean = false;\n\n    @property({type: Boolean, attribute: 'disable-tap'})\n    disableTap: boolean = false;\n\n    @property({type: Number, attribute: 'interpolation-decay'})\n    interpolationDecay: number = DECAY_MILLISECONDS;\n\n    protected[$promptElement] =\n        this.shadowRoot!.querySelector('.interaction-prompt') as HTMLElement;\n    protected[$promptAnimatedContainer] =\n        this.shadowRoot!.querySelector('#prompt') as HTMLElement;\n    protected[$fingerAnimatedContainers]: HTMLElement[] = [\n      this.shadowRoot!.querySelector('#finger0')!,\n      this.shadowRoot!.querySelector('#finger1')!\n    ];\n    protected[$panElement] =\n        this.shadowRoot!.querySelector('.pan-target') as HTMLElement;\n\n    protected[$lastPromptOffset] = 0;\n    protected[$promptElementVisibleTime] = Infinity;\n    protected[$userHasInteracted] = false;\n    protected[$waitingToPromptUser] = false;\n    protected[$cancellationSource] = ChangeSource.AUTOMATIC;\n\n    protected[$controls] = new SmoothControls(\n        this[$scene].camera as PerspectiveCamera, this[$userInputElement],\n        this[$scene]);\n\n    protected[$lastSpherical] = new Spherical();\n    protected[$jumpCamera] = false;\n    protected[$initialized] = false;\n    protected[$maintainThetaPhi] = false;\n\n    get inputSensitivity(): number {\n      return this[$controls].inputSensitivity;\n    }\n\n    set inputSensitivity(value: number) {\n      this[$controls].inputSensitivity = value;\n    }\n\n    getCameraOrbit(): SphericalPosition {\n      const {theta, phi, radius} = this[$lastSpherical];\n      return {\n        theta,\n        phi,\n        radius,\n        toString() {\n          return `${this.theta}rad ${this.phi}rad ${this.radius}m`;\n        }\n      };\n    }\n\n    getCameraTarget(): Vector3D {\n      return toVector3D(\n          this[$renderer].isPresenting ? this[$renderer].arRenderer.target :\n                                         this[$scene].getTarget());\n    }\n\n    getFieldOfView(): number {\n      return this[$controls].getFieldOfView();\n    }\n\n    // Provided so user code does not have to parse these from attributes.\n    getMinimumFieldOfView(): number {\n      return this[$controls].options.minimumFieldOfView!;\n    }\n\n    getMaximumFieldOfView(): number {\n      return this[$controls].options.maximumFieldOfView!;\n    }\n\n    getIdealAspect(): number {\n      return this[$scene].idealAspect;\n    }\n\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] =\n          this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n          this.cameraControls;\n    }\n\n    zoom(keyPresses: number) {\n      const event = new WheelEvent('wheel', {deltaY: -30 * keyPresses});\n      this[$userInputElement].dispatchEvent(event);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      this[$controls].addEventListener(\n          'user-interaction', this[$cancelPrompts]);\n      this[$controls].addEventListener(\n          'pointer-change-start',\n          this[$onPointerChange] as (event: Event) => void);\n      this[$controls].addEventListener(\n          'pointer-change-end',\n          this[$onPointerChange] as (event: Event) => void);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      this[$controls].removeEventListener(\n          'user-interaction', this[$cancelPrompts]);\n      this[$controls].removeEventListener(\n          'pointer-change-start',\n          this[$onPointerChange] as (event: Event) => void);\n      this[$controls].removeEventListener(\n          'pointer-change-end',\n          this[$onPointerChange] as (event: Event) => void);\n    }\n\n    updated(changedProperties: Map<string|number|symbol, unknown>) {\n      super.updated(changedProperties);\n\n      const controls = this[$controls];\n      const scene = this[$scene];\n\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n        } else {\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n        this[$userInputElement].setAttribute('aria-label', this[$ariaLabel]);\n      }\n\n      if (changedProperties.has('disableZoom')) {\n        controls.disableZoom = this.disableZoom;\n      }\n\n      if (changedProperties.has('disablePan')) {\n        controls.enablePan = !this.disablePan;\n      }\n\n      if (changedProperties.has('disableTap')) {\n        controls.enableTap = !this.disableTap;\n      }\n\n      if (changedProperties.has('interactionPrompt') ||\n          changedProperties.has('cameraControls') ||\n          changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n            this.cameraControls && !this[$userHasInteracted]) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptAnimatedContainer].style.opacity =\n            this.interactionPromptStyle == InteractionPromptStyle.BASIC ? '1' :\n                                                                          '0';\n      }\n\n      if (changedProperties.has('touchAction')) {\n        const touchAction = this.touchAction;\n        controls.applyOptions({touchAction});\n        controls.updateTouchActionStyle();\n      }\n\n      if (changedProperties.has('orbitSensitivity')) {\n        controls.orbitSensitivity = this.orbitSensitivity;\n      }\n\n      if (changedProperties.has('zoomSensitivity')) {\n        controls.zoomSensitivity = this.zoomSensitivity;\n      }\n\n      if (changedProperties.has('panSensitivity')) {\n        controls.panSensitivity = this.panSensitivity;\n      }\n\n      if (changedProperties.has('interpolationDecay')) {\n        controls.setDamperDecayTime(this.interpolationDecay);\n        scene.setTargetDamperDecayTime(this.interpolationDecay);\n      }\n\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          controls.jumpToGoal();\n          scene.jumpToGoal();\n          this[$onChange]();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n\n    async updateFraming() {\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n\n      await scene.updateFraming();\n\n      const newFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n      const zoom = this[$controls].getFieldOfView() / oldFramedFoV;\n      this[$controls].setFieldOfView(newFramedFoV * zoom);\n      this[$maintainThetaPhi] = true;\n\n      this.requestUpdate('maxFieldOfView');\n      this.requestUpdate('fieldOfView');\n      this.requestUpdate('minCameraOrbit');\n      this.requestUpdate('maxCameraOrbit');\n      this.requestUpdate('cameraOrbit');\n      await this.updateComplete;\n    }\n\n    interact(duration: number, finger0: Finger, finger1?: Finger) {\n      const inputElement = this[$userInputElement];\n      const fingerElements = this[$fingerAnimatedContainers];\n\n      if (fingerElements[0].style.opacity === '1') {\n        console.warn(\n            'interact() failed because an existing interaction is running.')\n        return;\n      }\n\n      const xy = new Array<{x: TimingFunction, y: TimingFunction}>();\n      xy.push({x: timeline(finger0.x), y: timeline(finger0.y)});\n      const positions = [{x: xy[0].x(0), y: xy[0].y(0)}];\n\n      if (finger1 != null) {\n        xy.push({x: timeline(finger1.x), y: timeline(finger1.y)});\n        positions.push({x: xy[1].x(0), y: xy[1].y(0)});\n      }\n\n      let startTime = performance.now();\n      const {width, height} = this[$scene];\n      const rect = this.getBoundingClientRect();\n\n      const dispatchTouches = (type: string) => {\n        for (const [i, position] of positions.entries()) {\n          const {style} = fingerElements[i];\n          style.transform = `translateX(${width * position.x}px) translateY(${\n              height * position.y}px)`;\n          if (type === 'pointerdown') {\n            style.opacity = '1';\n          } else if (type === 'pointerup') {\n            style.opacity = '0';\n          }\n\n          const init = {\n            pointerId: i - 5678,  // help ensure uniqueness\n            pointerType: 'touch',\n            target: inputElement,\n            clientX: width * position.x + rect.x,\n            clientY: height * position.y + rect.y,\n            altKey: true  // flag that this is not a user interaction\n          } as PointerEventInit;\n\n          inputElement.dispatchEvent(new PointerEvent(type, init));\n        }\n      };\n\n      const moveTouches = () => {\n        // Cancel interaction if something else moves the camera or input is\n        // removed from the DOM.\n        const changeSource = this[$cancellationSource];\n        if (changeSource !== ChangeSource.AUTOMATIC ||\n            !inputElement.isConnected) {\n          for (const fingerElement of this[$fingerAnimatedContainers]) {\n            fingerElement.style.opacity = '0';\n          }\n          dispatchTouches('pointercancel');\n          this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n              'interact-stopped', {detail: {source: changeSource}}));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n          return;\n        }\n\n        const time = Math.min(1, (performance.now() - startTime) / duration);\n        for (const [i, position] of positions.entries()) {\n          position.x = xy[i].x(time);\n          position.y = xy[i].y(time);\n        }\n        dispatchTouches('pointermove');\n\n        if (time < 1) {\n          requestAnimationFrame(moveTouches);\n        } else {\n          dispatchTouches('pointerup');\n          this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n              'interact-stopped', {detail: {source: ChangeSource.AUTOMATIC}}));\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n        }\n      };\n\n      const onVisibilityChange = () => {\n        let elapsed = 0;\n        if (document.visibilityState === 'hidden') {\n          elapsed = performance.now() - startTime;\n        } else {\n          startTime = performance.now() - elapsed;\n        }\n      };\n\n      document.addEventListener('visibilitychange', onVisibilityChange);\n\n      dispatchTouches('pointerdown');\n\n      this[$cancellationSource] = ChangeSource.AUTOMATIC;\n\n      requestAnimationFrame(moveTouches);\n    }\n\n    [$syncFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      const controls = this[$controls];\n      const scene = this[$scene];\n      scene.framedFoVDeg = style[0] * 180 / Math.PI;\n      controls.changeSource = ChangeSource.NONE;\n      controls.setFieldOfView(scene.adjustedFoV(scene.framedFoVDeg));\n      this[$cancelPrompts]();\n    }\n\n    [$syncCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      const controls = this[$controls];\n      if (this[$maintainThetaPhi]) {\n        const {theta, phi} = this.getCameraOrbit();\n        style[0] = theta;\n        style[1] = phi;\n        this[$maintainThetaPhi] = false;\n      }\n      controls.changeSource = ChangeSource.NONE;\n      controls.setOrbit(style[0], style[1], style[2]);\n      this[$cancelPrompts]();\n    }\n\n    [$syncMinCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this[$updateCameraForRadius](style[2]);\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMinFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].applyOptions(\n          {minimumFieldOfView: style[0] * 180 / Math.PI});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      const fov = this[$scene].adjustedFoV(style[0] * 180 / Math.PI);\n      this[$controls].applyOptions({maximumFieldOfView: fov});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncCameraTarget](style: EvaluatedStyle<Vector3Intrinsics>) {\n      const [x, y, z] = style;\n      if (!this[$renderer].arRenderer.isPresenting) {\n        this[$scene].setTarget(x, y, z);\n      }\n      this[$controls].changeSource = ChangeSource.NONE;\n      this[$renderer].arRenderer.updateTarget();\n      this[$cancelPrompts]();\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n\n      if (this[$renderer].isPresenting || !this[$getModelIsVisible]()) {\n        return;\n      }\n\n      const controls = this[$controls];\n      const scene = this[$scene];\n\n      const now = performance.now();\n      if (this[$waitingToPromptUser]) {\n        if (this.loaded &&\n            now > this[$loadedTime] + this.interactionPromptThreshold) {\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n\n          this[$promptElement].classList.add('visible');\n        }\n      }\n\n      if (isFinite(this[$promptElementVisibleTime]) &&\n          this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const animationTime =\n            ((now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME) %\n            1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n\n        if (offset !== this[$lastPromptOffset]) {\n          const xOffset = offset * scene.width * 0.05;\n          const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n\n          this[$promptAnimatedContainer].style.transform =\n              `translateX(${xOffset}px)`;\n\n          controls.changeSource = ChangeSource.AUTOMATIC;\n          controls.adjustOrbit(deltaTheta, 0, 0);\n\n          this[$lastPromptOffset] = offset;\n        }\n      }\n\n      const cameraMoved = controls.update(time, delta);\n      const targetMoved = scene.updateTarget(delta);\n\n      if (cameraMoved || targetMoved) {\n        this[$onChange]();\n      }\n    }\n\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n    [$updateCameraForRadius](radius: number) {\n      const maximumRadius =\n          Math.max(this[$scene].boundingSphere.radius, radius);\n\n      const near = 0;\n      const far = Math.abs(2 * maximumRadius);\n      this[$controls].updateNearFar(near, far);\n    }\n\n    [$updateAria]() {\n      const {theta, phi} =\n          this[$controls]!.getCameraSpherical(this[$lastSpherical]);\n\n      const azimuthalQuadrant =\n          (4 + Math.floor(((theta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n\n      const polarTrient = Math.floor(phi / THIRD_PI);\n\n      const azimuthalQuadrantLabel =\n          AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n      const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n\n      this[$updateStatus](\n          `View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`);\n    }\n\n    get[$ariaLabel]() {\n      return super[$ariaLabel].replace(/\\.$/, '') +\n          (this.cameraControls ? INTERACTION_PROMPT : '');\n    }\n\n    async[$onResize](event: any) {\n      const controls = this[$controls];\n      const scene = this[$scene];\n      const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);\n\n      // The super of $onResize may update the scene's adjustedFoV, so we\n      // compare the before and after to calculate the proper zoom.\n      super[$onResize](event);\n\n      const fovRatio = scene.adjustedFoV(scene.framedFoVDeg) / oldFramedFoV;\n      const fov =\n          controls.getFieldOfView() * (isFinite(fovRatio) ? fovRatio : 1);\n\n      controls.updateAspect(this[$scene].aspect);\n\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      await this.updateComplete;\n      this[$controls].setFieldOfView(fov);\n\n      this.jumpCameraToGoal();\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      if (this[$initialized]) {\n        this[$maintainThetaPhi] = true;\n      } else {\n        this[$initialized] = true;\n      }\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n\n    [$cancelPrompts] = () => {\n      const source = this[$controls].changeSource;\n      this[$cancellationSource] = source;\n\n      if (source === ChangeSource.USER_INTERACTION) {\n        this[$userHasInteracted] = true;\n        this[$deferInteractionPrompt]();\n      }\n    };\n\n    [$onChange] = () => {\n      this[$updateAria]();\n      this[$needsRender]();\n      const source = this[$controls].changeSource;\n\n      this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n          'camera-change', {detail: {source}}));\n    };\n\n    [$onPointerChange] = (event: PointerChangeEvent) => {\n      if (event.type === 'pointer-change-start') {\n        this[$container].classList.add('pointer-tumbling');\n      } else {\n        this[$container].classList.remove('pointer-tumbling');\n      }\n    };\n  }\n\n  return ControlsModelViewerElement;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}