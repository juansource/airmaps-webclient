{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Mesh, MeshBasicMaterial, OrthographicCamera, PlaneGeometry, Scene, WebGLRenderTarget } from 'three';\nimport { blobCanvas } from '../../model-viewer-base.js';\nimport { Renderer } from '../../three-components/Renderer.js';\nimport { $correlatedObjects, $onUpdate, ThreeDOMElement } from './three-dom-element.js';\nconst quadMaterial = new MeshBasicMaterial();\nconst quad = new PlaneGeometry(2, 2);\nlet adhocNum = 0;\nexport const $threeTexture = Symbol('threeTexture');\nexport const $threeTextures = Symbol('threeTextures');\nexport const $applyTexture = Symbol('applyTexture');\n/**\n * Image facade implementation for Three.js textures\n */\nexport class Image extends ThreeDOMElement {\n  get [$threeTexture]() {\n    var _a;\n    return (_a = this[$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;\n  }\n  get [$threeTextures]() {\n    return this[$correlatedObjects];\n  }\n  constructor(onUpdate, texture) {\n    super(onUpdate, new Set(texture ? [texture] : []));\n    if (!this[$threeTexture].image.src) {\n      this[$threeTexture].image.src = 'adhoc_image' + adhocNum++;\n    }\n    if (!this[$threeTexture].image.name) {\n      this[$threeTexture].image.name = texture && texture.image && texture.image.src ? texture.image.src.split('/').pop() : 'adhoc_image';\n    }\n  }\n  get name() {\n    return this[$threeTexture].image.name || '';\n  }\n  get uri() {\n    return this[$threeTexture].image.src;\n  }\n  get bufferView() {\n    return this[$threeTexture].image.bufferView;\n  }\n  get element() {\n    const texture = this[$threeTexture];\n    if (texture && (texture.isCanvasTexture || texture.isVideoTexture)) {\n      return texture.image;\n    }\n    return;\n  }\n  get animation() {\n    const texture = this[$threeTexture];\n    if (texture && texture.isCanvasTexture && texture.animation) {\n      return texture.animation;\n    }\n    return;\n  }\n  get type() {\n    return this.uri != null ? 'external' : 'embedded';\n  }\n  set name(name) {\n    for (const texture of this[$threeTextures]) {\n      texture.image.name = name;\n    }\n  }\n  update() {\n    const texture = this[$threeTexture];\n    // Applies to non-Lottie canvas textures only\n    if (texture && texture.isCanvasTexture && !texture.animation) {\n      this[$threeTexture].needsUpdate = true;\n      this[$onUpdate]();\n    }\n  }\n  async createThumbnail(width, height) {\n    const scene = new Scene();\n    quadMaterial.map = this[$threeTexture];\n    const mesh = new Mesh(quad, quadMaterial);\n    scene.add(mesh);\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const {\n      threeRenderer\n    } = Renderer.singleton;\n    const renderTarget = new WebGLRenderTarget(width, height);\n    threeRenderer.setRenderTarget(renderTarget);\n    threeRenderer.render(scene, camera);\n    threeRenderer.setRenderTarget(null);\n    const buffer = new Uint8Array(width * height * 4);\n    threeRenderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);\n    blobCanvas.width = width;\n    blobCanvas.height = height;\n    const blobContext = blobCanvas.getContext('2d');\n    const imageData = blobContext.createImageData(width, height);\n    imageData.data.set(buffer);\n    blobContext.putImageData(imageData, 0, 0);\n    return new Promise(async (resolve, reject) => {\n      blobCanvas.toBlob(blob => {\n        if (!blob) {\n          return reject('Failed to capture thumbnail.');\n        }\n        resolve(URL.createObjectURL(blob));\n      }, 'image/png');\n    });\n  }\n}","map":{"version":3,"names":["Mesh","MeshBasicMaterial","OrthographicCamera","PlaneGeometry","Scene","WebGLRenderTarget","blobCanvas","Renderer","$correlatedObjects","$onUpdate","ThreeDOMElement","quadMaterial","quad","adhocNum","$threeTexture","Symbol","$threeTextures","$applyTexture","Image","_a","values","next","value","constructor","onUpdate","texture","Set","image","src","name","split","pop","uri","bufferView","element","isCanvasTexture","isVideoTexture","animation","type","update","needsUpdate","createThumbnail","width","height","scene","map","mesh","add","camera","threeRenderer","singleton","renderTarget","setRenderTarget","render","buffer","Uint8Array","readRenderTargetPixels","blobContext","getContext","imageData","createImageData","data","set","putImageData","Promise","resolve","reject","toBlob","blob","URL","createObjectURL"],"sources":["../../../src/features/scene-graph/image.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Mesh, MeshBasicMaterial, OrthographicCamera, PlaneGeometry, Scene, Texture as ThreeTexture, WebGLRenderTarget} from 'three';\n\nimport {blobCanvas} from '../../model-viewer-base.js';\nimport {Renderer} from '../../three-components/Renderer.js';\n\nimport {Image as ImageInterface} from './api.js';\nimport {$correlatedObjects, $onUpdate, ThreeDOMElement} from './three-dom-element.js';\n\n\nconst quadMaterial = new MeshBasicMaterial();\nconst quad = new PlaneGeometry(2, 2);\nlet adhocNum = 0;\n\nexport const $threeTexture = Symbol('threeTexture');\nexport const $threeTextures = Symbol('threeTextures');\nexport const $applyTexture = Symbol('applyTexture');\n\n/**\n * Image facade implementation for Three.js textures\n */\nexport class Image extends ThreeDOMElement implements ImageInterface {\n  get[$threeTexture]() {\n    return this[$correlatedObjects]?.values().next().value as ThreeTexture;\n  }\n\n  get[$threeTextures](): Set<ThreeTexture> {\n    return this[$correlatedObjects] as Set<ThreeTexture>;\n  }\n\n  constructor(onUpdate: () => void, texture: ThreeTexture) {\n    super(onUpdate, new Set<ThreeTexture>(texture ? [texture] : []));\n\n    if (!this[$threeTexture].image.src) {\n      this[$threeTexture].image.src = 'adhoc_image' + adhocNum++;\n    }\n    if (!this[$threeTexture].image.name) {\n      this[$threeTexture].image.name =\n          (texture && texture.image && texture.image.src) ?\n          texture.image.src.split('/').pop() :\n          'adhoc_image';\n    }\n  }\n\n  get name(): string {\n    return this[$threeTexture].image.name || '';\n  }\n\n  get uri(): string|undefined {\n    return this[$threeTexture].image.src;\n  }\n\n  get bufferView(): number|undefined {\n    return this[$threeTexture].image.bufferView;\n  }\n\n  get element(): HTMLVideoElement|HTMLCanvasElement|undefined {\n    const texture = this[$threeTexture] as any;\n    if (texture && (texture.isCanvasTexture || texture.isVideoTexture)) {\n      return texture.image;\n    }\n    return;\n  }\n\n  get animation(): any|undefined {\n    const texture = this[$threeTexture] as any;\n    if (texture && texture.isCanvasTexture && texture.animation) {\n      return texture.animation;\n    }\n    return;\n  }\n\n  get type(): 'embedded'|'external' {\n    return this.uri != null ? 'external' : 'embedded';\n  }\n\n  set name(name: string) {\n    for (const texture of this[$threeTextures]) {\n      texture.image.name = name;\n    }\n  }\n\n  update() {\n    const texture = this[$threeTexture] as any;\n    // Applies to non-Lottie canvas textures only\n    if (texture && texture.isCanvasTexture && !texture.animation) {\n      this[$threeTexture].needsUpdate = true;\n      this[$onUpdate]();\n    }\n  }\n\n  async createThumbnail(width: number, height: number): Promise<string> {\n    const scene = new Scene();\n    quadMaterial.map = this[$threeTexture];\n    const mesh = new Mesh(quad, quadMaterial);\n    scene.add(mesh);\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n    const {threeRenderer} = Renderer.singleton;\n    const renderTarget = new WebGLRenderTarget(width, height);\n    threeRenderer.setRenderTarget(renderTarget);\n    threeRenderer.render(scene, camera);\n    threeRenderer.setRenderTarget(null);\n\n    const buffer = new Uint8Array(width * height * 4);\n    threeRenderer.readRenderTargetPixels(\n        renderTarget, 0, 0, width, height, buffer);\n\n    blobCanvas.width = width;\n    blobCanvas.height = height;\n    const blobContext = blobCanvas.getContext('2d')!;\n    const imageData = blobContext.createImageData(width, height);\n    imageData.data.set(buffer);\n    blobContext.putImageData(imageData, 0, 0);\n\n    return new Promise<string>(async (resolve, reject) => {\n      blobCanvas.toBlob(blob => {\n        if (!blob) {\n          return reject('Failed to capture thumbnail.');\n        }\n        resolve(URL.createObjectURL(blob));\n      }, 'image/png');\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}