{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { parseExpressions } from './parsers.js';\n/**\n * For our purposes, an enumeration is a fixed set of CSS-expression-compatible\n * names. When serialized, a selected subset of the members may be specified as\n * whitespace-separated strings. An enumeration deserializer is a function that\n * parses a serialized subset of an enumeration and returns any members that are\n * found as a Set.\n *\n * The following example will produce a deserializer for the days of the\n * week:\n *\n * const deserializeDaysOfTheWeek = enumerationDeserializer([\n *   'Monday',\n *   'Tuesday',\n *   'Wednesday',\n *   'Thursday',\n *   'Friday',\n *   'Saturday',\n *   'Sunday'\n * ]);\n */\nexport const enumerationDeserializer = allowedNames => valueString => {\n  try {\n    const expressions = parseExpressions(valueString);\n    const names = (expressions.length ? expressions[0].terms : []).filter(valueNode => valueNode && valueNode.type === 'ident').map(valueNode => valueNode.value).filter(name => allowedNames.indexOf(name) > -1);\n    // NOTE(cdata): IE11 does not support constructing a Set directly from\n    // an iterable, so we need to manually add all the items:\n    const result = new Set();\n    for (const name of names) {\n      result.add(name);\n    }\n    return result;\n  } catch (_error) {}\n  return new Set();\n};","map":{"version":3,"names":["parseExpressions","enumerationDeserializer","allowedNames","valueString","expressions","names","length","terms","filter","valueNode","type","map","value","name","indexOf","result","Set","add","_error"],"sources":["../../src/styles/deserializers.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {IdentNode, parseExpressions} from './parsers.js';\n\n\n/**\n * For our purposes, an enumeration is a fixed set of CSS-expression-compatible\n * names. When serialized, a selected subset of the members may be specified as\n * whitespace-separated strings. An enumeration deserializer is a function that\n * parses a serialized subset of an enumeration and returns any members that are\n * found as a Set.\n *\n * The following example will produce a deserializer for the days of the\n * week:\n *\n * const deserializeDaysOfTheWeek = enumerationDeserializer([\n *   'Monday',\n *   'Tuesday',\n *   'Wednesday',\n *   'Thursday',\n *   'Friday',\n *   'Saturday',\n *   'Sunday'\n * ]);\n */\nexport const enumerationDeserializer = <T extends string>(allowedNames: T[]) =>\n    (valueString: string): Set<T> => {\n      try {\n        const expressions = parseExpressions(valueString);\n        const names = (expressions.length ? expressions[0].terms : [])\n                          .filter<IdentNode>(\n                              (valueNode): valueNode is IdentNode =>\n                                  valueNode && valueNode.type === 'ident')\n                          .map(valueNode => valueNode.value as T)\n                          .filter(name => allowedNames.indexOf(name) > -1);\n\n        // NOTE(cdata): IE11 does not support constructing a Set directly from\n        // an iterable, so we need to manually add all the items:\n        const result = new Set<T>();\n        for (const name of names) {\n          result.add(name);\n        }\n        return result;\n      } catch (_error) {\n      }\n      return new Set();\n    };"],"mappings":"AAAA;;;;;;;;;;;;;;AAeA,SAAmBA,gBAAgB,QAAO,cAAc;AAGxD;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,MAAMC,uBAAuB,GAAsBC,YAAiB,IACtEC,WAAmB,IAAY;EAC9B,IAAI;IACF,MAAMC,WAAW,GAAGJ,gBAAgB,CAACG,WAAW,CAAC;IACjD,MAAME,KAAK,GAAG,CAACD,WAAW,CAACE,MAAM,GAAGF,WAAW,CAAC,CAAC,CAAC,CAACG,KAAK,GAAG,EAAE,EAC1CC,MAAM,CACFC,SAAS,IACNA,SAAS,IAAIA,SAAS,CAACC,IAAI,KAAK,OAAO,CAAC,CAC/CC,GAAG,CAACF,SAAS,IAAIA,SAAS,CAACG,KAAU,CAAC,CACtCJ,MAAM,CAACK,IAAI,IAAIX,YAAY,CAACY,OAAO,CAACD,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAElE;IACA;IACA,MAAME,MAAM,GAAG,IAAIC,GAAG,EAAK;IAC3B,KAAK,MAAMH,IAAI,IAAIR,KAAK,EAAE;MACxBU,MAAM,CAACE,GAAG,CAACJ,IAAI,CAAC;;IAElB,OAAOE,MAAM;GACd,CAAC,OAAOG,MAAM,EAAE,C;EAEjB,OAAO,IAAIF,GAAG,EAAE;AAClB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}