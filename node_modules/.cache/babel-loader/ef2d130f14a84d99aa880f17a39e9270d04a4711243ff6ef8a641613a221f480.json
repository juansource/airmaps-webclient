{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { BufferAttribute, ClampToEdgeWrapping, Color, DoubleSide, InterpolateDiscrete, InterpolateLinear, NoColorSpace, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MathUtils, Matrix4, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, PropertyBinding, RGBAFormat, RepeatWrapping, Scene, Source, SRGBColorSpace, CompressedTexture, Vector3 } from 'three';\nimport { decompress } from './../utils/TextureUtils.js';\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: ['byte', 'byte normalized', 'unsigned byte', 'unsigned byte normalized', 'short', 'short normalized', 'unsigned short', 'unsigned short normalized'],\n  NORMAL: ['byte normalized', 'short normalized'],\n  TANGENT: ['byte normalized', 'short normalized'],\n  TEXCOORD: ['byte', 'byte normalized', 'unsigned byte', 'short', 'short normalized', 'unsigned short']\n};\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options).catch(onError);\n  }\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  BYTE: 0x1400,\n  UNSIGNED_BYTE: 0x1401,\n  SHORT: 0x1402,\n  UNSIGNED_SHORT: 0x1403,\n  INT: 0x1404,\n  UNSIGNED_INT: 0x1405,\n  FLOAT: 0x1406,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n};\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement('canvas');\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== undefined) {\n    return new Promise(resolve => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n\n  // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n  if (mimeType === 'image/jpeg') {\n    quality = 0.92;\n  } else if (mimeType === 'image/webp') {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality\n  });\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign({\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n\n    // Merge buffers.\n    const blob = new Blob(buffers, {\n      type: 'application/octet-stream'\n    });\n\n    // Declare extensions.\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n\n    // Update bytelength of the single buffer.\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function () {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(reader.result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n\n        // JSON chunk.\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n\n        // GLB header.\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream'\n        });\n        const glbReader = new FileReader();\n        glbReader.readAsArrayBuffer(glbBlob);\n        glbReader.onloadend = function () {\n          onDone(glbReader.result);\n        };\n      };\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = function () {\n          const base64data = reader.result;\n          json.buffers[0].uri = base64data;\n          onDone(json);\n        };\n      } else {\n        onDone(json);\n      }\n    }\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn('THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' + 'won\\'t be serialized because of JSON.stringify error - ' + error.message);\n    }\n  }\n\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids = new Map();\n      uids.set(true, this.uid++);\n      uids.set(false, this.uid++);\n      this.uids.set(attribute, uids);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap;\n    function getEncodingConversion(map) {\n      if (map.colorSpace === SRGBColorSpace) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.');\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d');\n    context.fillStyle = '#00ffff';\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n\n    //\n\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Source(canvas);\n    texture.colorSpace = NoColorSpace;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn('THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.');\n    }\n    return texture;\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }];\n\n    // All buffers are merged before export.\n    buffers.push(buffer);\n    return 0;\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = [];\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(function (resolve) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function () {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      9: 'MAT3',\n      16: 'MAT4'\n    };\n    let componentType;\n\n    // Detect the component type of the attribute array\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name);\n    }\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count;\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = 'image/png') {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + ':flipY/' + flipY.toString();\n      if (cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = {\n        mimeType: mimeType\n      };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d');\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.', format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(getToBlobPromise(canvas, mimeType).then(blob => writer.processBufferViewImage(blob)).then(bufferViewIndex => {\n          imageDef.bufferView = bufferViewIndex;\n        }));\n      } else {\n        if (canvas.toDataURL !== undefined) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(getToBlobPromise(canvas, mimeType).then(blob => new FileReader().readAsDataURL(blob)).then(dataURL => {\n            imageDef.uri = dataURL;\n          }));\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error('THREE.GLTFExporter: No valid image data found. Unable to process texture.');\n    }\n  }\n\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n\n    // make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === 'image/webp') mimeType = 'image/png';\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name) textureDef.name = map.name;\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n    if (!json.materials) json.materials = [];\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n\n    // pbrMetallicRoughness.baseColorTexture\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv1: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n\n      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith('_')) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal);\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null;\n\n    // Morph targets\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null) delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n    let attrType = undefined;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = 'byte';\n        break;\n      case Uint8Array:\n        attrType = 'unsigned byte';\n        break;\n      case Int16Array:\n        attrType = 'short';\n        break;\n      case Uint16Array:\n        attrType = 'unsigned short';\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized) attrType += ' normalized';\n    const attrNamePrefix = attributeName.split('_', 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE';\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === undefined) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === undefined) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === undefined) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh) this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n      if (children.length > 0) nodeDef.children = children;\n    }\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (1.0 - light.penumbra) * light.angle;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      light: lights.length - 1\n    };\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_clearcoat';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_iridescence';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_ior';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_specular';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1.0 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_sheen';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0.0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_anisotropy';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0.0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = {\n        index: writer.processTexture(material.anisotropyMap)\n      };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_emissive_strength';\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1.0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n      let mergedTrack;\n\n      // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n\n        // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n\n      // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n\n      // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport { GLTFExporter };","map":{"version":3,"names":["BufferAttribute","ClampToEdgeWrapping","Color","DoubleSide","InterpolateDiscrete","InterpolateLinear","NoColorSpace","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MathUtils","Matrix4","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","PropertyBinding","RGBAFormat","RepeatWrapping","Scene","Source","SRGBColorSpace","CompressedTexture","Vector3","decompress","KHR_mesh_quantization_ExtraAttrTypes","POSITION","NORMAL","TANGENT","TEXCOORD","GLTFExporter","constructor","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","callback","indexOf","push","unregister","splice","parse","input","onDone","onError","options","GLTFWriter","plugins","i","il","length","setPlugins","write","catch","parseAsync","scope","Promise","resolve","reject","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","DEFAULT_SPECULAR_COLOR","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","value","array","getX","getY","getZ","getW","normalized","normalize","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","toBlob","undefined","quality","convertToBlob","type","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","extensionsRequired","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","all","blob","Blob","extensionsUsedList","keys","extensionsRequiredList","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","console","warn","name","message","getUID","isRelativeCopy","has","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTexture","metalnessMap","roughnessMap","getEncodingConversion","map","colorSpace","SRGBToLinear","c","pow","LinearToLinear","metalness","image","roughness","width","height","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","convert","data","putImageData","reference","source","channel","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","dataView","setFloat32","setInt32","setInt16","setUint16","setInt8","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","processAccessor","geometry","types","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","Error","minMax","bufferViewTarget","bufferView","accessorDef","accessors","processImage","format","flipY","cachedImages","key","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","then","bufferViewIndex","toDataURL","dataURL","processSampler","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTexture","textureDef","sampler","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","texCoord","baseColorTexture","emissive","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","uv","uv1","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","slice","toUpperCase","validVertexAttributes","test","accessor","startsWith","detectMeshQuantization","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setY","setZ","setW","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","attrType","attrNamePrefix","split","includes","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex","writeNode","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isMeshPhysicalMaterial","clearcoat","extensionDef","clearcoatFactor","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","iridescence","iridescenceFactor","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","ior","specularIntensity","specularColor","equals","specularIntensityMap","specularColorTexture","specularIntensityMapDef","specularTexture","specularColorMap","specularColorMapDef","specularFactor","specularColorFactor","sheen","sheenRoughnessMap","sheenRoughnessMapDef","sheenRoughnessTexture","sheenColorMap","sheenColorMapDef","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenColorFactor","sheenColor","anisotropy","anisotropyMap","anisotropyMapDef","anisotropyTexture","anisotropyStrength","anisotropyRotation","emissiveIntensity","emissiveStrength","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"sources":["/Users/juangonzalez/Documents/GitHub/vue-project-kiwi/node_modules/three/examples/jsm/exporters/GLTFExporter.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tSRGBColorSpace,\n\tCompressedTexture,\n\tVector3\n} from 'three';\nimport { decompress } from './../utils/TextureUtils.js';\n\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n\tPOSITION: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'unsigned byte normalized',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t\t'unsigned short normalized',\n\t],\n\tNORMAL: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTANGENT: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTEXCOORD: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t],\n};\n\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Function} onError  Callback on errors\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.write( input, onDone, options ).catch( onError );\n\n\t}\n\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tBYTE: 0x1400,\n\tUNSIGNED_BYTE: 0x1401,\n\tSHORT: 0x1402,\n\tUNSIGNED_SHORT: 0x1403,\n\tINT: 0x1404,\n\tUNSIGNED_INT: 0x1405,\n\tFLOAT: 0x1406,\n\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\n\t\tthis.extensionsUsed = {};\n\t\tthis.extensionsRequired = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\tasync write( input, onDone, options = {} ) {\n\n\t\tthis.options = Object.assign( {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tthis.processInput( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\t\tconst extensionsRequired = writer.extensionsRequired;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t * @param  {Object} object\n\t * @return {Integer}\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tbuildMetalRoughTexture( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\tif ( metalnessMap instanceof CompressedTexture ) {\n\n\t\t\tmetalnessMap = decompress( metalnessMap );\n\n\t\t}\n\n\t\tif ( roughnessMap instanceof CompressedTexture ) {\n\n\t\t\troughnessMap = decompress( roughnessMap );\n\n\t\t}\n\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\n\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.colorSpace = NoColorSpace;\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\n\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {Integer}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number} target (Optional) Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tswitch ( componentType ) {\n\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\n\n\t\t\t\t\tdataView.setInt32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\n\n\t\t\t\t\tdataView.setInt16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\n\n\t\t\t\t\tdataView.setInt8( offset, value );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Integer>}\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t * @param  {Integer} start (Optional)\n\t * @param  {Integer} count (Optional)\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t9: 'MAT3',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Integer} format of the image (RGBAFormat)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @param  {String} mimeType export format\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tif ( image !== null ) {\n\n\t\t\tconst writer = this;\n\t\t\tconst cache = writer.cache;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tconst cachedImages = cache.images.get( image );\n\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tconst imageDef = { mimeType: mimeType };\n\n\t\t\tconst canvas = getCanvas();\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.', format );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( canvas.toDataURL !== undefined ) {\n\n\t\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpending.push(\n\n\t\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\n\t\t\t\t\t\t\t.then( dataURL => {\n\n\t\t\t\t\t\t\t\timageDef.uri = dataURL;\n\n\t\t\t\t\t\t\t} )\n\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t */\n\tprocessTexture( map ) {\n\n\t\tconst writer = this;\n\t\tconst options = writer.options;\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\t// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n\t\tif ( map instanceof CompressedTexture ) {\n\n\t\t\tmap = decompress( map, options.maxTextureSize );\n\n\t\t}\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t */\n\tprocessMaterial( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = {\n\t\t\t\tindex: this.processTexture( metalRoughTexture ),\n\t\t\t\tchannel: metalRoughTexture.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = {\n\t\t\t\tindex: this.processTexture( material.map ),\n\t\t\t\ttexCoord: material.map.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tconst emissive = material.emissive;\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = {\n\t\t\t\t\tindex: this.processTexture( material.emissiveMap ),\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\n\t\t\t\t};\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = {\n\t\t\t\tindex: this.processTexture( material.normalMap ),\n\t\t\t\ttexCoord: material.normalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\ttexCoord: material.aoMap.channel\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t */\n\tprocessMesh( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv1: 'TEXCOORD_1',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * If a vertex attribute with a\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n\t * is used, it is checked whether it is a valid data type according to the\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n\t * extension.\n\t * In this case the extension is automatically added to the list of used extensions.\n\t *\n\t * @param {string} attributeName\n\t * @param {THREE.BufferAttribute} attribute\n\t */\n\tdetectMeshQuantization( attributeName, attribute ) {\n\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\n\n\t\tlet attrType = undefined;\n\n\t\tswitch ( attribute.array.constructor ) {\n\n\t\t\tcase Int8Array:\n\n\t\t\t\tattrType = 'byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint8Array:\n\n\t\t\t\tattrType = 'unsigned byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Int16Array:\n\n\t\t\t\tattrType = 'short';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint16Array:\n\n\t\t\t\tattrType = 'unsigned short';\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.normalized ) attrType += ' normalized';\n\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\n\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\n\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} node Object3D to processNode\n\t * @return {Integer} Index of the node in the nodes list\n\t */\n\tprocessNode( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = this.processMesh( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} node Scene to process\n\t */\n\tprocessScene( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array} objects List of objects to process\n\t */\n\tprocessObjects( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tthis.processScene( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tprocessInput( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tfunc( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatMap ),\n\t\t\t\ttexCoord: material.clearcoatMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatRoughnessMap ),\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatNormalMap ),\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = {\n\t\t\t\tindex: writer.processTexture( material.iridescenceMap ),\n\t\t\t\ttexCoord: material.iridescenceMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.iridescenceThicknessMap ),\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = {\n\t\t\t\tindex: writer.processTexture( material.transmissionMap ),\n\t\t\t\ttexCoord: material.transmissionMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.thicknessMap ),\n\t\t\t\ttexCoord: material.thicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_ior';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.ior = material.ior;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_specular';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\n\t\t     ! material.specularIntensityMap && ! material.specularColorTexture ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tconst specularIntensityMapDef = {\n\t\t\t\tindex: writer.processTexture( material.specularIntensityMap ),\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\n\n\t\t}\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tconst specularColorMapDef = {\n\t\t\t\tindex: writer.processTexture( material.specularColorMap ),\n\t\t\t\ttexCoord: material.specularColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\n\n\t\t}\n\n\t\textensionDef.specularFactor = material.specularIntensity;\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_sheen';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\tconst sheenRoughnessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.sheenRoughnessMap ),\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.sheenColorMap ) {\n\n\t\t\tconst sheenColorMapDef = {\n\t\t\t\tindex: writer.processTexture( material.sheenColorMap ),\n\t\t\t\ttexCoord: material.sheenColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\n\n\t\t}\n\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_anisotropy';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.anisotropyMap ) {\n\n\t\t\tconst anisotropyMapDef = { index: writer.processTexture( material.anisotropyMap ) };\n\t\t\twriter.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );\n\t\t\textensionDef.anisotropyTexture = anisotropyMapDef;\n\n\t\t}\n\n\t\textensionDef.anisotropyStrength = material.anisotropy;\n\t\textensionDef.anisotropyRotation = material.anisotropyRotation;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_emissive_strength';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t}\n\n};\n\nexport { GLTFExporter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}