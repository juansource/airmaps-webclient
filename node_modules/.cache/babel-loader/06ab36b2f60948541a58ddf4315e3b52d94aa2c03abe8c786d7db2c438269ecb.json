{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f;\nimport { Mesh } from 'three';\nimport { $setActive, $variantSet, Material } from './material.js';\nimport { Node, PrimitiveNode } from './nodes/primitive-node.js';\nimport { $correlatedObjects } from './three-dom-element.js';\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $nodeFromPoint = Symbol('nodeFromPoint');\nexport const $nodeFromIndex = Symbol('nodeFromIndex');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n  constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model {\n  constructor(correlatedSceneGraph, onUpdate = () => {}) {\n    this[_a] = new Array();\n    this[_b] = new Array();\n    this[_c] = new Array();\n    this[_d] = new Array();\n    this[_e] = () => {};\n    this[_f] = new Map();\n    this[$modelOnUpdate] = onUpdate;\n    const {\n      gltf,\n      threeGLTF,\n      gltfElementMap\n    } = correlatedSceneGraph;\n    for (const [i, material] of gltf.materials.entries()) {\n      const correlatedMaterial = gltfElementMap.get(material);\n      if (correlatedMaterial != null) {\n        this[$materials].push(new Material(onUpdate, i, true, this[$variantData], correlatedMaterial, material.name));\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n        // Loads the three.js material.\n        const capturedMatIndex = i;\n        const materialLoadCallback = async () => {\n          const threeMaterial = await threeGLTF.parser.getDependency('material', capturedMatIndex);\n          // Adds correlation, maps the variant gltf-def to the\n          // three material set containing the variant material.\n          const threeMaterialSet = new Set();\n          gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n          threeMaterialSet.add(threeMaterial);\n          return {\n            set: threeMaterialSet,\n            material: threeMaterial\n          };\n        };\n        // Configures the material for lazy loading.\n        this[$materials].push(new Material(onUpdate, i, false, this[$variantData], correlatedMaterial, material.name, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n      }\n    }\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n    // Prepares for scene iteration.\n    const parentMap = new Map();\n    const nodeStack = new Array();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop();\n      let node = null;\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(object, this.materials, this[$variantData], correlatedSceneGraph);\n        this[$primitivesList].push(node);\n      } else {\n        node = new Node(object.name);\n      }\n      const parent = parentMap.get(object);\n      if (parent != null) {\n        parent.children.push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials() {\n    return this[$materials];\n  }\n  [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitivesList, _e = $modelOnUpdate, _f = $variantData, $availableVariants)]() {\n    const variants = Array.from(this[$variantData].values());\n    variants.sort((a, b) => {\n      return a.index - b.index;\n    });\n    return variants.map(data => {\n      return data.name;\n    });\n  }\n  getMaterialByName(name) {\n    const matches = this[$materials].filter(material => {\n      return material.name === name;\n    });\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n  [$nodeFromIndex](mesh, primitive) {\n    const found = this[$hierarchy].find(node => {\n      if (node instanceof PrimitiveNode) {\n        const {\n          meshes,\n          primitives\n        } = node.mesh.userData.associations;\n        if (meshes == mesh && primitives == primitive) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return found == null ? null : found;\n  }\n  [$nodeFromPoint](hit) {\n    return this[$hierarchy].find(node => {\n      if (node instanceof PrimitiveNode) {\n        const primitive = node;\n        if (primitive.mesh === hit.object) {\n          return true;\n        }\n      }\n      return false;\n    });\n  }\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](hit) {\n    return this[$nodeFromPoint](hit).getActiveMaterial();\n  }\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async [$switchVariant](variantName) {\n    for (const primitive of this[$primitivesList]) {\n      await primitive.enableVariant(variantName);\n    }\n    for (const material of this.materials) {\n      material[$setActive](false);\n    }\n    // Marks the materials that are now in use after the variant switch.\n    for (const primitive of this[$primitivesList]) {\n      this.materials[primitive.getActiveMaterial().index][$setActive](true);\n    }\n  }\n  async [$prepareVariantsForExport]() {\n    const promises = new Array();\n    for (const primitive of this[$primitivesList]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n  [$cloneMaterial](index, newMaterialName) {\n    const material = this.materials[index];\n    if (!material.isLoaded) {\n      console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n    }\n    const threeMaterialSet = material[$correlatedObjects];\n    const clonedSet = new Set();\n    for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n      const clone = threeMaterial.clone();\n      clone.name = newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n      clonedSet.add(clone);\n    }\n    const clonedMaterial = new Material(this[$modelOnUpdate], this[$materials].length, false,\n    // Cloned as inactive.\n    this[$variantData], clonedSet, newMaterialName);\n    this[$materials].push(clonedMaterial);\n    return clonedMaterial;\n  }\n  createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = true) {\n    let variantMaterialInstance = null;\n    for (const primitive of this[$primitivesList]) {\n      const variantData = this[$variantData].get(variantName);\n      // Skips the primitive if the variant already exists.\n      if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n        continue;\n      }\n      // Skips the primitive if the source/original material does not exist.\n      if (primitive.getMaterial(originalMaterialIndex) == null) {\n        continue;\n      }\n      if (!this.hasVariant(variantName)) {\n        this.createVariant(variantName);\n      }\n      if (variantMaterialInstance == null) {\n        variantMaterialInstance = this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n      }\n      primitive.addVariant(variantMaterialInstance, variantName);\n    }\n    if (activateVariant && variantMaterialInstance != null) {\n      variantMaterialInstance[$setActive](true);\n      this.materials[originalMaterialIndex][$setActive](false);\n      for (const primitive of this[$primitivesList]) {\n        primitive.enableVariant(variantName);\n      }\n    }\n    return variantMaterialInstance;\n  }\n  createVariant(variantName) {\n    if (!this[$variantData].has(variantName)) {\n      // Adds the name if it's not already in the list.\n      this[$variantData].set(variantName, {\n        name: variantName,\n        index: this[$variantData].size\n      });\n    } else {\n      console.warn(`Variant '${variantName}'' already exists`);\n    }\n  }\n  hasVariant(variantName) {\n    return this[$variantData].has(variantName);\n  }\n  setMaterialToVariant(materialIndex, targetVariantName) {\n    if (this[$availableVariants]().find(name => name === targetVariantName) == null) {\n      console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);\n      return;\n    }\n    if (materialIndex < 0 || materialIndex >= this.materials.length) {\n      console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n      return;\n    }\n    for (const primitive of this[$primitivesList]) {\n      const material = primitive.getMaterial(materialIndex);\n      // Ensures the material exists on the primitive before setting it to a\n      // variant.\n      if (material != null) {\n        primitive.addVariant(material, targetVariantName);\n      }\n    }\n  }\n  updateVariantName(currentName, newName) {\n    const variantData = this[$variantData].get(currentName);\n    if (variantData == null) {\n      return;\n    }\n    variantData.name = newName;\n    this[$variantData].set(newName, variantData);\n    this[$variantData].delete(currentName);\n  }\n  deleteVariant(variantName) {\n    const variant = this[$variantData].get(variantName);\n    if (variant == null) {\n      return;\n    }\n    for (const material of this.materials) {\n      if (material.hasVariant(variantName)) {\n        material[$variantSet].delete(variant.index);\n      }\n    }\n    for (const primitive of this[$primitivesList]) {\n      primitive.deleteVariant(variant.index);\n    }\n    this[$variantData].delete(variantName);\n  }\n}","map":{"version":3,"names":["Mesh","$setActive","$variantSet","Material","Node","PrimitiveNode","$correlatedObjects","$materials","Symbol","$hierarchy","$roots","$primitivesList","$loadVariant","$prepareVariantsForExport","$switchVariant","$materialFromPoint","$nodeFromPoint","$nodeFromIndex","$variantData","$availableVariants","$modelOnUpdate","$cloneMaterial","LazyLoader","constructor","gltf","gltfElementMap","mapKey","doLazyLoad","Model","correlatedSceneGraph","onUpdate","_a","Array","_b","_c","_d","_e","_f","Map","threeGLTF","i","material","materials","entries","correlatedMaterial","get","push","name","elementArray","gltfMaterialDef","capturedMatIndex","materialLoadCallback","threeMaterial","parser","getDependency","threeMaterialSet","Set","set","add","parentMap","nodeStack","object","scene","children","length","pop","node","parent","child","variants","from","values","sort","a","b","index","map","data","getMaterialByName","matches","filter","mesh","primitive","found","find","meshes","primitives","userData","associations","hit","getActiveMaterial","variantName","enableVariant","promises","instantiateVariants","Promise","all","newMaterialName","isLoaded","console","error","clonedSet","clone","size","clonedMaterial","createMaterialInstanceForVariant","originalMaterialIndex","activateVariant","variantMaterialInstance","variantData","variantInfo","has","getMaterial","hasVariant","createVariant","addVariant","warn","setMaterialToVariant","materialIndex","targetVariantName","updateVariantName","currentName","newName","delete","deleteVariant","variant"],"sources":["../../../src/features/scene-graph/model.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Intersection, Material as ThreeMaterial, Mesh, MeshPhysicalMaterial, Object3D} from 'three';\n\nimport {CorrelatedSceneGraph, GLTFElementToThreeObjectMap, ThreeObjectSet} from '../../three-components/gltf-instance/correlated-scene-graph.js';\nimport {GLTF, GLTFElement} from '../../three-components/gltf-instance/gltf-2.0.js';\n\nimport {Model as ModelInterface} from './api.js';\nimport {$setActive, $variantSet, Material} from './material.js';\nimport {Node, PrimitiveNode} from './nodes/primitive-node.js';\nimport {$correlatedObjects} from './three-dom-element.js';\n\n\n\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $nodeFromPoint = Symbol('nodeFromPoint');\nexport const $nodeFromIndex = Symbol('nodeFromIndex');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n  gltf: GLTF;\n  gltfElementMap: GLTFElementToThreeObjectMap;\n  mapKey: GLTFElement;\n  doLazyLoad: () => Promise<{set: ThreeObjectSet, material: ThreeMaterial}>;\n  constructor(\n      gltf: GLTF, gltfElementMap: GLTFElementToThreeObjectMap,\n      mapKey: GLTFElement,\n      doLazyLoad:\n          () => Promise<{set: ThreeObjectSet, material: ThreeMaterial}>) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n\n/**\n * Facades variant mapping data.\n */\nexport interface VariantData {\n  name: string;\n  index: number;\n}\n\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model implements ModelInterface {\n  private[$materials] = new Array<Material>();\n  private[$hierarchy] = new Array<Node>();\n  private[$roots] = new Array<Node>();\n  private[$primitivesList] = new Array<PrimitiveNode>();\n  private[$modelOnUpdate]: () => void = () => {};\n  private[$variantData] = new Map<string, VariantData>();\n\n  constructor(\n      correlatedSceneGraph: CorrelatedSceneGraph,\n      onUpdate: () => void = () => {}) {\n    this[$modelOnUpdate] = onUpdate;\n    const {gltf, threeGLTF, gltfElementMap} = correlatedSceneGraph;\n\n    for (const [i, material] of gltf.materials!.entries()) {\n      const correlatedMaterial =\n          gltfElementMap.get(material) as Set<MeshPhysicalMaterial>;\n\n      if (correlatedMaterial != null) {\n        this[$materials].push(new Material(\n            onUpdate, i, true, this[$variantData], correlatedMaterial, material.name));\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n\n        // Loads the three.js material.\n        const capturedMatIndex = i;\n        const materialLoadCallback = async () => {\n          const threeMaterial =\n              await threeGLTF.parser.getDependency(\n                  'material', capturedMatIndex) as MeshPhysicalMaterial;\n\n          // Adds correlation, maps the variant gltf-def to the\n          // three material set containing the variant material.\n          const threeMaterialSet = new Set<MeshPhysicalMaterial>();\n          gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n          threeMaterialSet.add(threeMaterial);\n\n          return {set: threeMaterialSet, material: threeMaterial};\n        };\n\n        // Configures the material for lazy loading.\n        this[$materials].push(new Material(\n            onUpdate,\n            i,\n            false,\n            this[$variantData],\n            correlatedMaterial,\n            material.name,\n            new LazyLoader(\n                gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n      }\n    }\n\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n\n    // Prepares for scene iteration.\n    const parentMap = new Map<object, Node>();\n    const nodeStack = new Array<Object3D>();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop()!;\n\n      let node: Node|null = null;\n\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(\n            object as Mesh,\n            this.materials,\n            this[$variantData],\n            correlatedSceneGraph);\n        this[$primitivesList].push(node as PrimitiveNode);\n      } else {\n        node = new Node(object.name);\n      }\n\n      const parent: Node|undefined = parentMap.get(object);\n      if (parent != null) {\n        parent.children.push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials(): Material[] {\n    return this[$materials];\n  }\n\n  [$availableVariants]() {\n    const variants = Array.from(this[$variantData].values());\n    variants.sort((a, b) => {\n      return a.index - b.index;\n    });\n\n    return variants.map((data) => {\n      return data.name;\n    });\n  }\n\n  getMaterialByName(name: string): Material|null {\n    const matches = this[$materials].filter(material => {\n      return material.name === name;\n    });\n\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n\n  [$nodeFromIndex](mesh: number, primitive: number): PrimitiveNode|null {\n    const found = this[$hierarchy].find((node: Node) => {\n      if (node instanceof PrimitiveNode) {\n        const {meshes, primitives} = node.mesh.userData.associations;\n        if (meshes == mesh && primitives == primitive) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return found == null ? null : found as PrimitiveNode;\n  }\n\n  [$nodeFromPoint](hit: Intersection<Object3D>): PrimitiveNode {\n    return this[$hierarchy].find((node: Node) => {\n      if (node instanceof PrimitiveNode) {\n        const primitive = node as PrimitiveNode;\n        if (primitive.mesh === hit.object) {\n          return true;\n        }\n      }\n      return false;\n    }) as PrimitiveNode;\n  }\n\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](hit: Intersection<Object3D>): Material {\n    return this[$nodeFromPoint](hit).getActiveMaterial();\n  }\n\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async[$switchVariant](variantName: string|null) {\n    for (const primitive of this[$primitivesList]) {\n      await primitive.enableVariant(variantName);\n    }\n\n    for (const material of this.materials) {\n      material[$setActive](false);\n    }\n    // Marks the materials that are now in use after the variant switch.\n    for (const primitive of this[$primitivesList]) {\n      this.materials[primitive.getActiveMaterial().index][$setActive](true);\n    }\n  }\n\n  async[$prepareVariantsForExport]() {\n    const promises = new Array<Promise<void>>();\n    for (const primitive of this[$primitivesList]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n\n  [$cloneMaterial](index: number, newMaterialName: string): Material {\n    const material = this.materials[index];\n\n    if (!material.isLoaded) {\n      console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n    }\n\n    const threeMaterialSet =\n        material[$correlatedObjects] as Set<MeshPhysicalMaterial>;\n\n    const clonedSet = new Set<MeshPhysicalMaterial>();\n    for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n      const clone = threeMaterial.clone() as MeshPhysicalMaterial;\n      clone.name =\n          newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n      clonedSet.add(clone);\n    }\n\n    const clonedMaterial = new Material(\n        this[$modelOnUpdate],\n        this[$materials].length,\n        false,  // Cloned as inactive.\n        this[$variantData],\n        clonedSet,\n        newMaterialName);\n\n    this[$materials].push(clonedMaterial);\n\n    return clonedMaterial;\n  }\n\n  createMaterialInstanceForVariant(\n      originalMaterialIndex: number, newMaterialName: string,\n      variantName: string, activateVariant: boolean = true): Material|null {\n    let variantMaterialInstance: Material|null = null;\n\n    for (const primitive of this[$primitivesList]) {\n      const variantData = this[$variantData].get(variantName);\n      // Skips the primitive if the variant already exists.\n      if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n        continue;\n      }\n\n      // Skips the primitive if the source/original material does not exist.\n      if (primitive.getMaterial(originalMaterialIndex) == null) {\n        continue;\n      }\n\n      if (!this.hasVariant(variantName)) {\n        this.createVariant(variantName);\n      }\n\n      if (variantMaterialInstance == null) {\n        variantMaterialInstance =\n            this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n      }\n      primitive.addVariant(variantMaterialInstance, variantName)\n    }\n\n    if (activateVariant && variantMaterialInstance != null) {\n      (variantMaterialInstance as Material)[$setActive](true);\n      this.materials[originalMaterialIndex][$setActive](false);\n      for (const primitive of this[$primitivesList]) {\n        primitive.enableVariant(variantName);\n      }\n    }\n\n    return variantMaterialInstance;\n  }\n\n  createVariant(variantName: string) {\n    if (!this[$variantData].has(variantName)) {\n      // Adds the name if it's not already in the list.\n      this[$variantData].set(\n          variantName,\n          {name: variantName, index: this[$variantData].size} as VariantData);\n    } else {\n      console.warn(`Variant '${variantName}'' already exists`);\n    }\n  }\n\n  hasVariant(variantName: string) {\n    return this[$variantData].has(variantName);\n  }\n\n  setMaterialToVariant(materialIndex: number, targetVariantName: string) {\n    if (this[$availableVariants]().find(name => name === targetVariantName) ==\n        null) {\n      console.warn(`Can't add material to '${\n          targetVariantName}', the variant does not exist.'`);\n      return;\n    }\n\n    if (materialIndex < 0 || materialIndex >= this.materials.length) {\n      console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n      return;\n    }\n\n    for (const primitive of this[$primitivesList]) {\n      const material = primitive.getMaterial(materialIndex);\n      // Ensures the material exists on the primitive before setting it to a\n      // variant.\n      if (material != null) {\n        primitive.addVariant(material, targetVariantName);\n      }\n    }\n  }\n\n  updateVariantName(currentName: string, newName: string) {\n    const variantData = this[$variantData].get(currentName);\n    if (variantData == null) {\n      return;\n    }\n    variantData.name = newName;\n    this[$variantData].set(newName, variantData!);\n    this[$variantData].delete(currentName);\n  }\n\n  deleteVariant(variantName: string) {\n    const variant = this[$variantData].get(variantName);\n    if (variant == null) {\n      return;\n    }\n\n    for (const material of this.materials) {\n      if (material.hasVariant(variantName)) {\n        material[$variantSet].delete(variant.index);\n      }\n    }\n\n    for (const primitive of this[$primitivesList]) {\n      primitive.deleteVariant(variant.index);\n    }\n\n    this[$variantData].delete(variantName);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}